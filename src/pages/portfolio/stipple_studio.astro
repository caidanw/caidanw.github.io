---
import HeaderLayout from '@/layouts/HeaderLayout.astro'
import ssImage from '@/assets/stipple_studio.png'
---

<HeaderLayout
  title="Stipple Studio"
  description="Interactive stippling tool with real-time visualization of the image processing pipeline"
  image={ssImage}
  favicon={ssImage}
>
  <div class="main-layout">
    <aside class="sidebar">
      <div class="controls">
        <h2>Image Processing</h2>

        <div class="control-group">
          <input type="file" id="imageInput" accept="image/*" />
        </div>

        <div class="control-group">
          <label>
            Region Size: <span class="slider-value" id="regionSizeValue">1</span> px
          </label>
          <input type="range" id="regionSize" min="1" max="16" value="1" step="1" />
        </div>

        <div class="control-group">
          <label>
            Brightness Levels: <span class="slider-value" id="levelsValue">10</span>
          </label>
          <input type="range" id="levels" min="1" max="50" value="10" step="1" />
        </div>

        <div class="control-group">
          <label>
            Diffusion Amount: <span class="slider-value" id="diffusionValue">0</span>
          </label>
          <input type="range" id="diffusion" min="0" max="10" value="0" step="1" />
        </div>
      </div>

      <div class="controls">
        <h2>Stippling Settings</h2>

        <div class="control-group">
          <label>
            Dot Size: <span class="slider-value" id="dotSizeValue">0.8</span> px
          </label>
          <input type="range" id="dotSize" min="0.1" max="4" value="0.8" step="0.1" />
        </div>

        <div class="control-group">
          <label>
            Base Spacing: <span class="slider-value" id="minDistValue">2</span> px
          </label>
          <input type="range" id="minDist" min="0" max="16" value="2" step="0.1" />
        </div>

        <div class="control-group">
          <label>
            Darkness Threshold: <span class="slider-value" id="thresholdValue">0.01</span>
          </label>
          <input type="range" id="threshold" min="0" max="1" value="0.01" step="0.01" />
        </div>

        <div class="control-group">
          <label>
            Max Dots: <span class="slider-value" id="maxDotsValue">30000</span>
          </label>
          <input type="range" id="maxDots" min="500" max="50000" value="30000" step="500" />
        </div>
      </div>
      <div class="controls">
        <div class="control-group btns">
          <button id="stipplingBtn" disabled>Start Stippling</button>
          <button id="stopBtn" disabled>Stop</button>
          <button id="resetBtn" disabled>Reset Dots</button>
        </div>

        <div class="control-group dots">
          <strong>Current dots: <span id="dotCount">0</span></strong>
        </div>
      </div>
    </aside>

    <div class="canvas-grid">
      <div class="canvas-container">
        <canvas id="originalCanvas"></canvas>
        <div class="info-box">
          <strong>Original source image</strong>
          <span class="description">Upload an image to begin</span>
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="brightnessCanvas"></canvas>
        <div class="info-box">
          <strong>Grayscale conversion</strong>
          <span class="description">Shows average brightness values</span>
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="quantizedCanvas"></canvas>
        <div class="info-box">
          <strong>Discrete brightness levels</strong>
          <span class="description">Image divided into <span id="currentLevels">5</span> brightness regions</span>
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="diffusedCanvas"></canvas>
        <div class="info-box">
          <strong>Smoothed transitions</strong>
          <span class="description">Gradual changes between regions</span>
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="thresholdCanvas"></canvas>
        <div class="info-box">
          <strong>Darkness threshold mask</strong>
          <span class="description">White areas receive dots, black areas do not</span>
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="stippledCanvas"></canvas>
        <div class="info-box">
          <strong>Dot placement visualization</strong>
        </div>
      </div>
    </div>
  </div>
</HeaderLayout>

<script>
  import { getInputElement, getButtonElement, getCanvasElement } from '../../lib/dom.ts'
  import { getPerceivedLuminance } from '../../lib/color.ts'

  const imageInput = getInputElement('imageInput'),
    regionSizeSlider = getInputElement('regionSize'),
    levelsSlider = getInputElement('levels'),
    diffusionSlider = getInputElement('diffusion'),
    dotSizeSlider = getInputElement('dotSize'),
    minDistSlider = getInputElement('minDist'),
    thresholdSlider = getInputElement('threshold'),
    maxDotsSlider = getInputElement('maxDots')

  const stipplingBtn = getButtonElement('stipplingBtn'),
    stopBtn = getButtonElement('stopBtn'),
    resetBtn = getButtonElement('resetBtn')

  const rootStyles = getComputedStyle(document.documentElement),
    colorBlack = rootStyles.getPropertyValue('--color-black').trim(),
    colorWhite = rootStyles.getPropertyValue('--color-white').trim(),
    colorGrayDark = rootStyles.getPropertyValue('--color-gray-dark').trim(),
    colorGrayDarker = rootStyles.getPropertyValue('--color-gray-darker').trim()

  const originalCanvas = getCanvasElement('originalCanvas'),
    brightnessCanvas = getCanvasElement('brightnessCanvas'),
    quantizedCanvas = getCanvasElement('quantizedCanvas'),
    diffusedCanvas = getCanvasElement('diffusedCanvas'),
    thresholdCanvas = getCanvasElement('thresholdCanvas'),
    stippledCanvas = getCanvasElement('stippledCanvas')

  function initializeCanvas(canvas: HTMLCanvasElement) {
    const checkSize = 16 // Size of each checker square
    const canvasSize = 480 // Initial size for checkerboard background, will be updated on image load

    canvas.width = canvasSize
    canvas.height = canvasSize

    const ctx = canvas.getContext('2d')
    if (!ctx) return

    // Draw checkerboard background
    for (let y = 0; y < canvasSize; y += checkSize) {
      for (let x = 0; x < canvasSize; x += checkSize) {
        const isEven = (Math.floor(x / checkSize) + Math.floor(y / checkSize)) % 2 === 0
        ctx.fillStyle = isEven ? colorGrayDark : colorGrayDarker
        ctx.fillRect(x, y, checkSize, checkSize)
      }
    }
  }

  initializeCanvas(originalCanvas)
  initializeCanvas(brightnessCanvas)
  initializeCanvas(quantizedCanvas)
  initializeCanvas(diffusedCanvas)
  initializeCanvas(thresholdCanvas)
  initializeCanvas(stippledCanvas)

  let currentImage: HTMLImageElement | null = null
  let regionMapData: ImageData | null = null
  let dots: { x: number; y: number }[] = []
  let isRunning = false
  let animationFrame: number | null = null
  let spatialGrid: { x: number; y: number }[][][] | null = null
  let gridCellSize = 0

  function processImage() {
    if (!currentImage) return

    const numLevels = parseInt(levelsSlider.value)
    const diffusionAmount = parseInt(diffusionSlider.value)

    // Step 1: Create brightness map
    const brightnessData = createBrightnessMap()

    // Step 2: Quantize into regions
    const regionMap = quantizeRegions(brightnessData, numLevels)

    // Step 3: Apply diffusion
    diffuseRegions(regionMap, diffusionAmount)

    // Step 4: Create threshold preview
    createThresholdPreview()
  }

  // Update slider values
  regionSizeSlider.addEventListener('input', (e) => {
    const target = e.target as HTMLInputElement
    const el = document.getElementById('regionSizeValue')
    if (el) el.textContent = target.value
    processImage()
  })

  levelsSlider.addEventListener('input', (e) => {
    const target = e.target as HTMLInputElement
    const el1 = document.getElementById('levelsValue')
    const el2 = document.getElementById('currentLevels')
    if (el1) el1.textContent = target.value
    if (el2) el2.textContent = target.value
    processImage()
  })

  diffusionSlider.addEventListener('input', (e) => {
    const target = e.target as HTMLInputElement
    const el = document.getElementById('diffusionValue')
    if (el) el.textContent = target.value
    processImage()
  })

  dotSizeSlider.addEventListener('input', (e) => {
    const target = e.target as HTMLInputElement
    const el = document.getElementById('dotSizeValue')
    if (el) el.textContent = parseFloat(target.value).toFixed(1)
    // Redraw dots if they exist
    if (dots.length > 0) {
      drawDots()
    }
  })

  minDistSlider.addEventListener('input', (e) => {
    const target = e.target as HTMLInputElement
    const el = document.getElementById('minDistValue')
    if (el) el.textContent = parseFloat(target.value).toFixed(1)
    // No auto-update for stippling parameters
  })

  thresholdSlider.addEventListener('input', (e) => {
    const target = e.target as HTMLInputElement
    const el = document.getElementById('thresholdValue')
    if (el) el.textContent = target.value
    createThresholdPreview()
  })

  maxDotsSlider.addEventListener('input', (e) => {
    const target = e.target as HTMLInputElement
    const el = document.getElementById('maxDotsValue')
    if (el) el.textContent = target.value
    // No auto-update for stippling parameters
  })

  imageInput.addEventListener('change', (e) => {
    const target = e.target as HTMLInputElement
    const file = target.files?.[0]
    if (!file) return

    const reader = new FileReader()
    reader.onload = (event) => {
      const img = new Image()
      img.onload = () => {
        currentImage = img

        drawOriginalImage()
        processImage()

        stipplingBtn.disabled = false
        resetBtn.disabled = false
      }
      const result = event.target?.result
      if (typeof result === 'string') {
        img.src = result
      }
    }
    reader.readAsDataURL(file)
  })

  function drawOriginalImage() {
    if (!currentImage) return
    const ctx = originalCanvas.getContext('2d')
    if (!ctx) return

    const maxWidth = 500
    const scale = Math.min(1, maxWidth / currentImage.width)

    originalCanvas.width = currentImage.width * scale
    originalCanvas.height = currentImage.height * scale

    ctx.drawImage(currentImage, 0, 0, originalCanvas.width, originalCanvas.height)
  }

  // Process image into brightness map
  function createBrightnessMap() {
    const ctx = originalCanvas.getContext('2d', { willReadFrequently: true })
    if (!ctx) return null

    const imageData = ctx.getImageData(0, 0, originalCanvas.width, originalCanvas.height)
    const data = imageData.data
    const width = originalCanvas.width
    const height = originalCanvas.height

    // Create brightness canvas
    brightnessCanvas.width = width
    brightnessCanvas.height = height
    const brightCtx = brightnessCanvas.getContext('2d')
    if (!brightCtx) return null

    const brightImageData = brightCtx.createImageData(width, height)
    const brightData = brightImageData.data

    // Convert to grayscale brightness
    for (let i = 0; i < data.length; i += 4) {
      const brightness = getPerceivedLuminance(data[i], data[i + 1], data[i + 2])
      brightData[i] = brightness
      brightData[i + 1] = brightness
      brightData[i + 2] = brightness
      brightData[i + 3] = 255
    }

    brightCtx.putImageData(brightImageData, 0, 0)
    return brightImageData
  }

  // Quantize into discrete regions
  function quantizeRegions(brightnessData: ImageData | null, numLevels: number) {
    if (!brightnessData) return []

    const regionSize = parseInt(regionSizeSlider.value)
    const width = brightnessData.width
    const height = brightnessData.height
    const data = brightnessData.data

    quantizedCanvas.width = width
    quantizedCanvas.height = height
    const ctx = quantizedCanvas.getContext('2d')
    if (!ctx) return []

    const quantizedImageData = ctx.createImageData(width, height)
    const quantizedData = quantizedImageData.data

    // Create grid of regions
    const cols = Math.ceil(width / regionSize)
    const rows = Math.ceil(height / regionSize)
    const regionMap: { brightness: number; level: number }[][] = []

    // Calculate average brightness for each region
    for (let ry = 0; ry < rows; ry++) {
      regionMap[ry] = []
      for (let rx = 0; rx < cols; rx++) {
        let sum = 0
        let count = 0

        // Sample all pixels in this region
        for (let py = ry * regionSize; py < Math.min((ry + 1) * regionSize, height); py++) {
          for (let px = rx * regionSize; px < Math.min((rx + 1) * regionSize, width); px++) {
            const idx = (py * width + px) * 4
            sum += data[idx]
            count++
          }
        }

        const avgBrightness = sum / count

        // Quantize to discrete level
        const level = Math.floor((avgBrightness / 255) * numLevels)
        const quantizedValue = (level / numLevels) * 255

        regionMap[ry][rx] = {
          brightness: quantizedValue,
          level: level,
        }
      }
    }

    // Draw quantized regions
    for (let ry = 0; ry < rows; ry++) {
      for (let rx = 0; rx < cols; rx++) {
        const value = regionMap[ry][rx].brightness

        for (let py = ry * regionSize; py < Math.min((ry + 1) * regionSize, height); py++) {
          for (let px = rx * regionSize; px < Math.min((rx + 1) * regionSize, width); px++) {
            const idx = (py * width + px) * 4
            quantizedData[idx] = value
            quantizedData[idx + 1] = value
            quantizedData[idx + 2] = value
            quantizedData[idx + 3] = 255
          }
        }
      }
    }

    ctx.putImageData(quantizedImageData, 0, 0)
    return regionMap
  }

  // Apply diffusion for smooth transitions
  function diffuseRegions(regionMap: { brightness: number; level: number }[][], diffusionAmount: number) {
    if (diffusionAmount === 0) {
      // No diffusion, just copy quantized
      const ctx = quantizedCanvas.getContext('2d', { willReadFrequently: true })
      if (!ctx) return
      const quantizedData = ctx.getImageData(0, 0, quantizedCanvas.width, quantizedCanvas.height)
      const diffusedCtx = diffusedCanvas.getContext('2d')
      if (!diffusedCtx) return
      diffusedCanvas.width = quantizedCanvas.width
      diffusedCanvas.height = quantizedCanvas.height
      diffusedCtx.putImageData(quantizedData, 0, 0)
      regionMapData = quantizedData
      return
    }

    const rows = regionMap.length
    const cols = regionMap[0].length
    const regionSize = parseInt(regionSizeSlider.value)
    const width = quantizedCanvas.width
    const height = quantizedCanvas.height

    diffusedCanvas.width = width
    diffusedCanvas.height = height
    const ctx = diffusedCanvas.getContext('2d')
    if (!ctx) return
    const diffusedImageData = ctx.createImageData(width, height)
    const diffusedData = diffusedImageData.data

    // Apply gaussian-like blur multiple times
    let currentMap = regionMap.map((row) => row.map((cell) => cell.brightness))

    for (let iteration = 0; iteration < diffusionAmount; iteration++) {
      const newMap: number[][] = []

      for (let ry = 0; ry < rows; ry++) {
        newMap[ry] = []
        for (let rx = 0; rx < cols; rx++) {
          let sum = currentMap[ry][rx]
          let count = 1

          // Average with neighbors
          const neighbors = [
            [-1, -1],
            [-1, 0],
            [-1, 1],
            [0, -1],
            [0, 1],
            [1, -1],
            [1, 0],
            [1, 1],
          ]

          for (const [dy, dx] of neighbors) {
            const ny = ry + dy
            const nx = rx + dx
            if (ny >= 0 && ny < rows && nx >= 0 && nx < cols) {
              sum += currentMap[ny][nx]
              count++
            }
          }

          newMap[ry][rx] = sum / count
        }
      }

      currentMap = newMap
    }

    // Draw diffused regions
    for (let ry = 0; ry < rows; ry++) {
      for (let rx = 0; rx < cols; rx++) {
        const value = currentMap[ry][rx]

        for (let py = ry * regionSize; py < Math.min((ry + 1) * regionSize, height); py++) {
          for (let px = rx * regionSize; px < Math.min((rx + 1) * regionSize, width); px++) {
            const idx = (py * width + px) * 4
            diffusedData[idx] = value
            diffusedData[idx + 1] = value
            diffusedData[idx + 2] = value
            diffusedData[idx + 3] = 255
          }
        }
      }
    }

    ctx.putImageData(diffusedImageData, 0, 0)
    regionMapData = diffusedImageData
  }

  // Create threshold preview showing which areas will receive dots
  function createThresholdPreview() {
    if (!regionMapData) return

    const threshold = parseFloat(thresholdSlider.value)
    const width = regionMapData.width
    const height = regionMapData.height
    const data = regionMapData.data

    thresholdCanvas.width = width
    thresholdCanvas.height = height
    const ctx = thresholdCanvas.getContext('2d')
    if (!ctx) return
    const thresholdImageData = ctx.createImageData(width, height)
    const thresholdData = thresholdImageData.data

    // Create black/white mask based on threshold
    for (let i = 0; i < data.length; i += 4) {
      const brightness = data[i]
      const lightness = brightness / 255

      // White if above threshold (will receive dots), black if below (pure black)
      const value = lightness >= threshold ? 255 : 0

      thresholdData[i] = value
      thresholdData[i + 1] = value
      thresholdData[i + 2] = value
      thresholdData[i + 3] = 255
    }

    ctx.putImageData(thresholdImageData, 0, 0)
  }

  // Spatial grid for fast nearest neighbor queries
  function initializeSpatialGrid(width: number, height: number, minDist: number) {
    gridCellSize = Math.max(minDist * 2, 10)
    const cols = Math.ceil(width / gridCellSize)
    const rows = Math.ceil(height / gridCellSize)
    spatialGrid = Array.from({ length: rows }, () => Array.from({ length: cols }, () => []))
  }

  function addToGrid(dot: { x: number; y: number }) {
    if (!spatialGrid || !gridCellSize) return
    const col = Math.floor(dot.x / gridCellSize)
    const row = Math.floor(dot.y / gridCellSize)
    // Bounds check
    if (row >= 0 && row < spatialGrid.length && col >= 0 && col < spatialGrid[0].length) {
      spatialGrid[row][col].push(dot)
    }
  }

  function clearGrid() {
    if (spatialGrid) {
      for (let row of spatialGrid) {
        for (let cell of row) {
          cell.length = 0
        }
      }
    }
  }

  // Fast distance check using spatial grid - returns squared distance to nearest dot
  function getNearestDotDistSq(x: number, y: number): number {
    if (!spatialGrid || dots.length === 0) return Infinity

    const col = Math.floor(x / gridCellSize)
    const row = Math.floor(y / gridCellSize)
    let minDistSq = Infinity

    // Check neighboring cells (3x3 grid around point)
    for (let dr = -1; dr <= 1; dr++) {
      for (let dc = -1; dc <= 1; dc++) {
        const r = row + dr
        const c = col + dc
        if (r >= 0 && r < spatialGrid.length && c >= 0 && c < spatialGrid[0].length) {
          const cellDots = spatialGrid[r][c]
          for (const dot of cellDots) {
            const dx = dot.x - x
            const dy = dot.y - y
            const distSq = dx * dx + dy * dy
            if (distSq < minDistSq) {
              minDistSq = distSq
            }
          }
        }
      }
    }

    return minDistSq
  }

  // Check if point is too close to any existing dot using spatial grid
  function isTooClose(x: number, y: number, minDistSq: number): boolean {
    return getNearestDotDistSq(x, y) < minDistSq
  }

  function getRegionBrightness(x: number, y: number): number {
    if (!regionMapData) return 255
    const width = regionMapData.width
    const height = regionMapData.height
    const px = Math.max(0, Math.min(Math.floor(x), width - 1))
    const py = Math.max(0, Math.min(Math.floor(y), height - 1))
    const idx = (py * width + px) * 4
    return regionMapData.data[idx]
  }

  function drawDots() {
    const ctx = stippledCanvas.getContext('2d')
    if (!ctx) return
    // Fill with dark background
    ctx.fillStyle = colorBlack
    ctx.fillRect(0, 0, stippledCanvas.width, stippledCanvas.height)

    // Draw light dots on top
    ctx.fillStyle = colorWhite
    const dotSize = parseFloat(dotSizeSlider.value)

    dots.forEach((dot) => {
      ctx.beginPath()
      ctx.arc(dot.x, dot.y, dotSize, 0, Math.PI * 2)
      ctx.fill()
    })

    const dotCountEl = document.getElementById('dotCount')
    if (dotCountEl) dotCountEl.textContent = String(dots.length)
  }

  function addDotAlgo() {
    const width = stippledCanvas.width
    const height = stippledCanvas.height
    const baseMinDist = parseInt(minDistSlider.value)
    const lightnessThreshold = parseFloat(thresholdSlider.value)

    // Sample points weighted by lightness
    let bestPoint = null
    let bestLightness = 0
    let bestMinDistSq = 0 // Memoize for reuse (Optimization 2)
    let maxScore = 0

    // Optimization 3: Early exit if we've hit max dots
    const maxDots = parseInt(maxDotsSlider.value)
    if (dots.length >= maxDots) return false

    for (let attempt = 0; attempt < 30; attempt++) {
      const x = Math.random() * width
      const y = Math.random() * height
      const brightness = getRegionBrightness(x, y)
      const lightness = brightness / 255

      // Optimization 3: Early exit if too dark
      if (lightness < lightnessThreshold) continue

      // Optimization 1: Use spatial grid for fast nearest neighbor query
      const minDistSq = getNearestDotDistSq(x, y)

      const score = minDistSq * (0.3 + lightness * 0.7)
      if (score > maxScore) {
        maxScore = score
        bestPoint = { x, y }
        bestLightness = lightness
        bestMinDistSq = minDistSq // Store for later reuse
      }
    }

    if (!bestPoint || bestLightness < lightnessThreshold) return false

    // If we have enough dots, triangulate
    if (dots.length >= 3) {
      // Find 3 nearest dots using spatial grid
      // Cap search radius to prevent infinite loops when dots are sparse or bestMinDistSq is Infinity
      const searchRadius = isFinite(bestMinDistSq) ? Math.min(Math.sqrt(bestMinDistSq) * 3, baseMinDist * 20) : baseMinDist * 10 // Reasonable default when no nearby dots
      const col = Math.floor(bestPoint.x / gridCellSize)
      const row = Math.floor(bestPoint.y / gridCellSize)
      const cellRadius = Math.min(Math.ceil(searchRadius / gridCellSize), 10) // Cap at 10 cells

      const nearbyDots = []
      for (let dr = -cellRadius; dr <= cellRadius; dr++) {
        for (let dc = -cellRadius; dc <= cellRadius; dc++) {
          const r = row + dr
          const c = col + dc
          if (spatialGrid && r >= 0 && r < spatialGrid.length && c >= 0 && c < spatialGrid[0].length) {
            nearbyDots.push(...spatialGrid[r][c])
          }
        }
      }

      if (nearbyDots.length >= 3) {
        const nearest = nearbyDots
          .map((dot) => ({
            dot,
            dist: (dot.x - bestPoint.x) ** 2 + (dot.y - bestPoint.y) ** 2,
          }))
          .sort((a, b) => a.dist - b.dist)
          .slice(0, 3)

        const centroid = {
          x: (nearest[0].dot.x + nearest[1].dot.x + nearest[2].dot.x) / 3,
          y: (nearest[0].dot.y + nearest[1].dot.y + nearest[2].dot.y) / 3,
        }

        // Check brightness at centroid
        const centroidBrightness = getRegionBrightness(centroid.x, centroid.y)
        const centroidLightness = centroidBrightness / 255

        if (centroidLightness >= lightnessThreshold) {
          // Variable min distance based on centroid brightness
          const variableMinDistSq = Math.pow(baseMinDist * (3.0 - centroidLightness * 2.8), 2)

          // Optimization 1: Use spatial grid for distance check
          if (!isTooClose(centroid.x, centroid.y, variableMinDistSq)) {
            dots.push(centroid)
            addToGrid(centroid)
            return true
          }
        }
      }
    }

    // Fallback: place at best point with variable minDist
    const fallbackMinDistSq = Math.pow(baseMinDist * (3.0 - bestLightness * 2.8), 2)

    // Optimization 1 & 2: Use spatial grid and already-computed distance
    if (bestMinDistSq >= fallbackMinDistSq && bestLightness >= lightnessThreshold) {
      dots.push(bestPoint)
      addToGrid(bestPoint)
      return true
    }

    return false
  }

  // Animation loop (Optimization 4: Improved batch processing)
  function animate() {
    if (!isRunning) {
      console.log('[ANIMATE] isRunning is false, stopping')
      return
    }

    const maxDots = parseInt(maxDotsSlider.value)
    if (dots.length >= maxDots) {
      console.log('[ANIMATE] Max dots reached:', dots.length, '>=', maxDots)
      stopStippling()
      return
    }

    // Optimization 4: Adaptive batch size - start with more dots per frame, reduce as we get fuller
    const fillRatio = dots.length / maxDots
    const batchSize = fillRatio < 0.5 ? 20 : fillRatio < 0.8 ? 10 : 5

    const startTime = performance.now()
    let successCount = 0
    let attemptCount = 0
    const maxAttempts = batchSize * 3 // Allow some failures before giving up

    console.log('[ANIMATE] Batch starting. Dots:', dots.length, 'FillRatio:', fillRatio.toFixed(2), 'BatchSize:', batchSize)

    while (successCount < batchSize && attemptCount < maxAttempts && dots.length < maxDots) {
      const success = addDotAlgo()

      if (success) successCount++
      attemptCount++

      // Emergency brake - if batch takes > 100ms, something's wrong
      if (performance.now() - startTime > 100) {
        console.error('[ANIMATE] Batch timeout! Took more than 100ms. SuccessCount:', successCount, 'AttemptCount:', attemptCount)
        break
      }
    }

    const elapsed = performance.now() - startTime
    console.log('[ANIMATE] Batch complete. Success:', successCount, 'Attempts:', attemptCount, 'Time:', elapsed.toFixed(2), 'ms')

    drawDots()
    animationFrame = requestAnimationFrame(animate)
  }

  function startStippling() {
    console.log('[START] Starting stippling...')
    if (!regionMapData) {
      console.error('[START] No regionMapData!')
      return
    }

    stippledCanvas.width = diffusedCanvas.width
    stippledCanvas.height = diffusedCanvas.height
    console.log('[START] Canvas size:', stippledCanvas.width, 'x', stippledCanvas.height)

    // Initialize spatial grid with canvas dimensions
    const baseMinDist = parseFloat(minDistSlider.value)
    console.log('[START] Base min distance:', baseMinDist)
    initializeSpatialGrid(stippledCanvas.width, stippledCanvas.height, baseMinDist)
    console.log('[START] Grid initialized. Cell size:', gridCellSize, 'Grid dimensions:', spatialGrid?.length, 'x', spatialGrid?.[0]?.length)

    isRunning = true
    stipplingBtn.disabled = true
    stopBtn.disabled = false
    console.log('[START] Calling animate()...')
    animate()
  }

  function stopStippling() {
    isRunning = false
    stipplingBtn.disabled = false
    stopBtn.disabled = true
    if (animationFrame) {
      cancelAnimationFrame(animationFrame)
      animationFrame = null
    }
  }

  function resetDots() {
    stopStippling()
    dots = []
    clearGrid() // Clear the spatial grid
    const ctx = stippledCanvas.getContext('2d')
    if (!ctx) return
    // Reset to dark background
    ctx.fillStyle = colorBlack
    ctx.fillRect(0, 0, stippledCanvas.width, stippledCanvas.height)
    const dotCountEl = document.getElementById('dotCount')
    if (dotCountEl) dotCountEl.textContent = '0'
  }

  stipplingBtn.addEventListener('click', startStippling)
  stopBtn.addEventListener('click', stopStippling)
  resetBtn.addEventListener('click', resetDots)
</script>

<style>
  header {
    text-align: center;
    margin-bottom: 2rem;
  }

  h1 {
    font-weight: 600;
    margin-bottom: 0.5rem;
  }

  .subtitle {
    color: var(--theme-text-subtle);
    font-size: 0.875rem;
  }

  .main-layout {
    margin: 0.5rem;
    margin-right: 1rem;
    display: flex;
    gap: 1rem;
    flex-direction: column;

    @media (min-width: 1024px) {
      flex-direction: row;
      align-items: flex-start;
    }
  }

  .sidebar {
    display: flex;
    flex-direction: column;

    @media (min-width: 1024px) {
      flex: 0 0 auto;
      top: 1rem;
      margin: 0 1rem;
    }
  }

  .controls {
    &:not(:last-child) {
      padding-bottom: 1rem;
    }

    & + .controls {
      border-top: 1px solid var(--theme-border);
      padding-top: 1rem;
    }

    & h2 {
      margin-bottom: 0.5rem;
      font-size: 1.25rem;
      font-weight: 600;
    }
  }

  .control-group {
    flex-shrink: 0;

    &:not(:last-child) {
      margin-bottom: 0.25rem;
    }

    &.btns {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    &.dots {
      margin-top: 1rem;

      #dotCount {
        font-size: 1.2rem;
        font-family: var(--font-mono);
        color: var(--theme-accent);
        margin-left: 0.5rem;
      }
    }

    & label {
      display: block;
    }
  }

  input[type='file'] {
    width: 100%;
    padding: 0.5rem;
    border: 2px dashed var(--theme-border);
    border-radius: 4px;
    font-size: 0.75rem;
    cursor: pointer;
    color: var(--theme-text);
  }

  input[type='range'] {
    accent-color: var(--theme-text-dim);
    width: 100%;
  }

  .control-group select {
    width: 100%;
    padding: 0.625rem;
    border: 1px solid var(--theme-border);
    border-radius: 6px;
    background: var(--theme-bg);
    color: var(--theme-text);
    font-size: 0.875rem;
    cursor: pointer;
  }

  .slider-value {
    display: inline-block;
    color: var(--theme-accent);
    font-family: var(--font-mono);
    font-size: 1.2rem;
    margin-left: 0.5rem;
  }

  button {
    background: var(--theme-accent);
    color: var(--color-white);
    border: none;
    padding: 0.25rem 0.75rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s;

    &:hover {
      background: var(--theme-accent-light);
    }

    &:active {
      background: var(--theme-accent-dark);
    }

    &:disabled {
      background: var(--color-gray);
      cursor: not-allowed;
      opacity: 0.5;
    }
  }

  .canvas-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 1rem;
    flex: 1;

    @media (min-width: 480px) {
      grid-template-columns: repeat(1, 1fr);
    }

    @media (min-width: 640px) {
      grid-template-columns: repeat(2, 1fr);
    }

    @media (min-width: 768px) {
      grid-template-columns: repeat(2, 1fr);
    }

    @media (min-width: 1440px) {
      grid-template-columns: repeat(3, 1fr);
    }

    @media (min-width: 2000px) {
      grid-template-columns: repeat(4, 1fr);
    }
  }

  .canvas-container {
    display: flex;
    flex-direction: column;
    min-width: 0; /* Allow flex items to shrink below content size */
  }

  canvas {
    width: 100%;
    height: auto;
    aspect-ratio: 1 / 1;
    display: block;
    object-fit: contain;
    border-radius: 0.25rem;
  }

  .info-box {
    background: var(--theme-bg);
    color: var(--theme-text-dim);
    line-height: 1.2;
    margin-top: 0.5rem;

    .description {
      font-size: 0.85rem;
    }

    strong {
      display: block;
      color: var(--theme-text);
    }
  }
</style>
