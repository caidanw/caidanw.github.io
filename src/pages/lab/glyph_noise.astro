---
import BreadcrumbLayout from '../../layouts/BreadcrumbLayout.astro'
---

<BreadcrumbLayout title="Glyph Noise">
  <div id="app">
    <canvas id="canvas"></canvas>

    <div class="controls" id="controls">
      <div class="controls-header">
        <button id="btnToggleControls" class="toggle-btn">Controls</button>
        <div class="controls-actions">
          <button id="btnPause">Pause</button>
          <button id="btnFullscreen">Fullscreen</button>
        </div>
      </div>

      <div class="controls-body" id="controlsBody">
        <div class="control-section">
          <div class="section-title">Presets</div>
          <div class="preset-grid">
            <button class="preset" data-preset="default">Default</button>
            <button class="preset" data-preset="moody">Moody</button>
            <button class="preset" data-preset="bright">Bright</button>
            <button class="preset" data-preset="minimal">Minimal</button>
            <button class="preset" data-preset="dense">Dense</button>
          </div>
        </div>

        <div class="control-section">
          <div class="section-title">Noise</div>
          <label class="slider">
            Cell Size
            <input type="range" id="cellSize" min="4" max="32" step="1" value="12" />
            <span class="value" id="cellSizeValue">12</span>
          </label>
          <label class="slider">
            Wave Amplitude
            <input type="range" id="waveAmplitude" min="0" max="0.05" step="0.001" value="0.008" />
            <span class="value" id="waveAmplitudeValue">0.008</span>
          </label>
          <label class="slider">
            Wave Frequency
            <input type="range" id="waveFrequency" min="1" max="10" step="0.1" value="4.0" />
            <span class="value" id="waveFrequencyValue">4.0</span>
          </label>
          <label class="slider">
            Wave Speed
            <input type="range" id="waveSpeed" min="0" max="1" step="0.01" value="0.3" />
            <span class="value" id="waveSpeedValue">0.30</span>
          </label>
          <label class="slider">
            Noise Intensity
            <input type="range" id="noiseIntensity" min="0" max="0.1" step="0.005" value="0.02" />
            <span class="value" id="noiseIntensityValue">0.020</span>
          </label>
          <label class="slider">
            Time Speed
            <input type="range" id="timeSpeed" min="0" max="3" step="0.1" value="1.0" />
            <span class="value" id="timeSpeedValue">1.0</span>
          </label>
        </div>

        <div class="control-section">
          <div class="section-title">Vignette</div>
          <label class="slider">
            Intensity
            <input type="range" id="vignetteIntensity" min="0" max="1" step="0.05" value="0.6" />
            <span class="value" id="vignetteIntensityValue">0.60</span>
          </label>
          <label class="slider">
            Radius
            <input type="range" id="vignetteRadius" min="0.3" max="1.5" step="0.05" value="0.8" />
            <span class="value" id="vignetteRadiusValue">0.80</span>
          </label>
        </div>

        <div class="control-section">
          <div class="section-title">Color</div>
          <label class="slider">
            Hue
            <input type="range" id="hue" min="0" max="360" step="1" value="30" />
            <span class="value" id="hueValue">30</span>
          </label>
          <label class="slider">
            Saturation
            <input type="range" id="saturation" min="0" max="1" step="0.05" value="0.8" />
            <span class="value" id="saturationValue">0.80</span>
          </label>
          <label class="slider">
            Brightness
            <input type="range" id="brightnessAdjust" min="-0.5" max="0.5" step="0.05" value="-0.1" />
            <span class="value" id="brightnessAdjustValue">-0.10</span>
          </label>
          <label class="slider">
            Contrast
            <input type="range" id="contrastAdjust" min="0.5" max="2" step="0.05" value="1.3" />
            <span class="value" id="contrastAdjustValue">1.30</span>
          </label>
        </div>

        <div class="control-section">
          <div class="section-title">Glyph Thresholds</div>
          <label class="slider">
            <span class="glyph-label">. dot</span>
            <input type="range" id="threshold1" min="0" max="0.5" step="0.01" value="0.10" />
            <span class="value" id="threshold1Value">0.10</span>
          </label>
          <label class="slider">
            <span class="glyph-label">- dash</span>
            <input type="range" id="threshold2" min="0" max="0.6" step="0.01" value="0.20" />
            <span class="value" id="threshold2Value">0.20</span>
          </label>
          <label class="slider">
            <span class="glyph-label">+ plus</span>
            <input type="range" id="threshold3" min="0.1" max="0.7" step="0.01" value="0.30" />
            <span class="value" id="threshold3Value">0.30</span>
          </label>
          <label class="slider">
            <span class="glyph-label">O ring</span>
            <input type="range" id="threshold4" min="0.2" max="0.8" step="0.01" value="0.40" />
            <span class="value" id="threshold4Value">0.40</span>
          </label>
          <label class="slider">
            <span class="glyph-label">X cross</span>
            <input type="range" id="threshold5" min="0.3" max="1.0" step="0.01" value="0.50" />
            <span class="value" id="threshold5Value">0.50</span>
          </label>
        </div>
      </div>
    </div>

    <div class="info">
      Drifting glyph noise â€” press <kbd>Space</kbd> to pause, <kbd>F</kbd> for fullscreen
    </div>
  </div>
</BreadcrumbLayout>

<script>
  // ============================================
  // DOM Elements
  // ============================================
  const canvas = document.getElementById('canvas') as HTMLCanvasElement
  const controls = document.getElementById('controls') as HTMLDivElement
  const controlsBody = document.getElementById('controlsBody') as HTMLDivElement
  const btnToggleControls = document.getElementById('btnToggleControls') as HTMLButtonElement
  const btnPause = document.getElementById('btnPause') as HTMLButtonElement
  const btnFullscreen = document.getElementById('btnFullscreen') as HTMLButtonElement

  // ============================================
  // State
  // ============================================
  interface State {
    cellSize: number
    waveAmplitude: number
    waveFrequency: number
    waveSpeed: number
    noiseIntensity: number
    vignetteIntensity: number
    vignetteRadius: number
    brightnessAdjust: number
    contrastAdjust: number
    timeSpeed: number
    hue: number
    saturation: number
    threshold1: number
    threshold2: number
    threshold3: number
    threshold4: number
    threshold5: number
  }

  const state: State = {
    cellSize: 12,
    waveAmplitude: 0.008,
    waveFrequency: 4.0,
    waveSpeed: 0.3,
    noiseIntensity: 0.02,
    vignetteIntensity: 0.6,
    vignetteRadius: 0.8,
    brightnessAdjust: -0.1,
    contrastAdjust: 1.3,
    timeSpeed: 1.0,
    hue: 30,
    saturation: 0.8,
    threshold1: 0.10,
    threshold2: 0.20,
    threshold3: 0.30,
    threshold4: 0.40,
    threshold5: 0.50,
  }

  let isPaused = false
  let time = 0
  let controlsVisible = true

  // ============================================
  // Presets
  // ============================================
  const presets: Record<string, Partial<State>> = {
    default: {
      cellSize: 12,
      waveAmplitude: 0.008,
      waveFrequency: 4.0,
      waveSpeed: 0.3,
      noiseIntensity: 0.02,
      vignetteIntensity: 0.6,
      vignetteRadius: 0.8,
      brightnessAdjust: -0.1,
      contrastAdjust: 1.3,
      timeSpeed: 1.0,
      hue: 30,
      saturation: 0.8,
      threshold1: 0.10,
      threshold2: 0.20,
      threshold3: 0.30,
      threshold4: 0.40,
      threshold5: 0.50,
    },
    moody: {
      cellSize: 16,
      waveAmplitude: 0.015,
      waveFrequency: 2.5,
      waveSpeed: 0.15,
      noiseIntensity: 0.04,
      vignetteIntensity: 0.9,
      vignetteRadius: 0.5,
      brightnessAdjust: -0.3,
      contrastAdjust: 1.6,
      timeSpeed: 0.5,
      hue: 270,
      saturation: 0.5,
      threshold1: 0.15,
      threshold2: 0.30,
      threshold3: 0.45,
      threshold4: 0.60,
      threshold5: 0.75,
    },
    bright: {
      cellSize: 10,
      waveAmplitude: 0.005,
      waveFrequency: 5.0,
      waveSpeed: 0.5,
      noiseIntensity: 0.01,
      vignetteIntensity: 0.3,
      vignetteRadius: 1.0,
      brightnessAdjust: 0.1,
      contrastAdjust: 1.1,
      timeSpeed: 1.5,
      hue: 45,
      saturation: 0.9,
      threshold1: 0.05,
      threshold2: 0.15,
      threshold3: 0.25,
      threshold4: 0.35,
      threshold5: 0.45,
    },
    minimal: {
      cellSize: 24,
      waveAmplitude: 0.02,
      waveFrequency: 2.0,
      waveSpeed: 0.2,
      noiseIntensity: 0.03,
      vignetteIntensity: 0.7,
      vignetteRadius: 0.6,
      brightnessAdjust: 0.0,
      contrastAdjust: 1.5,
      timeSpeed: 0.8,
      hue: 180,
      saturation: 0.6,
      threshold1: 0.20,
      threshold2: 0.35,
      threshold3: 0.50,
      threshold4: 0.65,
      threshold5: 0.80,
    },
    dense: {
      cellSize: 6,
      waveAmplitude: 0.003,
      waveFrequency: 6.0,
      waveSpeed: 0.4,
      noiseIntensity: 0.015,
      vignetteIntensity: 0.4,
      vignetteRadius: 0.9,
      brightnessAdjust: -0.05,
      contrastAdjust: 1.2,
      timeSpeed: 1.2,
      hue: 15,
      saturation: 0.95,
      threshold1: 0.08,
      threshold2: 0.16,
      threshold3: 0.24,
      threshold4: 0.32,
      threshold5: 0.40,
    },
  }

  // ============================================
  // WebGL Setup
  // ============================================
  const gl = canvas.getContext('webgl2')
  if (!gl) {
    throw new Error('WebGL 2.0 not supported')
  }

  // Shader sources
  const vertexShaderSource = `#version 300 es
    in vec2 a_position;
    out vec2 v_uv;

    void main() {
      v_uv = a_position * 0.5 + 0.5;
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  `

  const noiseFragmentShaderSource = `#version 300 es
    precision highp float;

    in vec2 v_uv;
    out vec4 fragColor;

    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_waveAmplitude;
    uniform float u_waveFrequency;
    uniform float u_waveSpeed;
    uniform float u_noiseIntensity;
    uniform float u_vignetteIntensity;
    uniform float u_vignetteRadius;
    uniform float u_brightnessAdjust;
    uniform float u_contrastAdjust;

    // Simplex 3D noise
    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

    float snoise(vec3 v) {
      const vec2 C = vec2(1.0/6.0, 1.0/3.0);
      const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

      vec3 i  = floor(v + dot(v, C.yyy));
      vec3 x0 = v - i + dot(i, C.xxx);

      vec3 g = step(x0.yzx, x0.xyz);
      vec3 l = 1.0 - g;
      vec3 i1 = min(g.xyz, l.zxy);
      vec3 i2 = max(g.xyz, l.zxy);

      vec3 x1 = x0 - i1 + C.xxx;
      vec3 x2 = x0 - i2 + C.yyy;
      vec3 x3 = x0 - D.yyy;

      i = mod289(i);
      vec4 p = permute(permute(permute(
                i.z + vec4(0.0, i1.z, i2.z, 1.0))
              + i.y + vec4(0.0, i1.y, i2.y, 1.0))
              + i.x + vec4(0.0, i1.x, i2.x, 1.0));

      float n_ = 0.142857142857;
      vec3 ns = n_ * D.wyz - D.xzx;

      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

      vec4 x_ = floor(j * ns.z);
      vec4 y_ = floor(j - 7.0 * x_);

      vec4 x = x_ *ns.x + ns.yyyy;
      vec4 y = y_ *ns.x + ns.yyyy;
      vec4 h = 1.0 - abs(x) - abs(y);

      vec4 b0 = vec4(x.xy, y.xy);
      vec4 b1 = vec4(x.zw, y.zw);

      vec4 s0 = floor(b0)*2.0 + 1.0;
      vec4 s1 = floor(b1)*2.0 + 1.0;
      vec4 sh = -step(h, vec4(0.0));

      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;

      vec3 p0 = vec3(a0.xy, h.x);
      vec3 p1 = vec3(a0.zw, h.y);
      vec3 p2 = vec3(a1.xy, h.z);
      vec3 p3 = vec3(a1.zw, h.w);

      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
      p0 *= norm.x;
      p1 *= norm.y;
      p2 *= norm.z;
      p3 *= norm.w;

      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
      m = m * m;
      return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
    }

    // Fractional Brownian Motion
    float fbm(vec3 p) {
      float value = 0.0;
      float amplitude = 0.5;
      float frequency = 1.0;
      for (int i = 0; i < 4; i++) {
        value += amplitude * snoise(p * frequency);
        amplitude *= 0.5;
        frequency *= 2.0;
      }
      return value;
    }

    void main() {
      vec2 uv = v_uv;
      vec2 center = vec2(0.5, 0.5);
      float dist = length(uv - center);

      // Domain warping - first layer (slow drift)
      vec2 warp1 = vec2(
        fbm(vec3(uv * 2.0, u_time * 0.03 * u_waveSpeed)),
        fbm(vec3(uv * 2.0 + vec2(5.3, 1.3), u_time * 0.025 * u_waveSpeed))
      );

      // Domain warping - second layer (subtle turbulence)
      vec2 warp2 = vec2(
        fbm(vec3(uv * 3.0 + warp1 * 0.5, u_time * 0.02 * u_waveSpeed)),
        fbm(vec3(uv * 3.0 + vec2(2.7, 4.1) + warp1 * 0.5, u_time * 0.018 * u_waveSpeed))
      );

      // Apply warping
      vec2 cloudUV = uv + warp1 * 0.15 * u_waveAmplitude * 20.0 + warp2 * 0.08 * u_waveAmplitude * 20.0;

      // Wave distortion
      cloudUV += vec2(
        sin(uv.y * u_waveFrequency * 10.0 + u_time * u_waveSpeed) * u_waveAmplitude,
        cos(uv.x * u_waveFrequency * 10.0 + u_time * u_waveSpeed) * u_waveAmplitude
      );

      // Sample cloud density
      float clouds = fbm(vec3(cloudUV * 4.0, u_time * 0.01 * u_waveSpeed)) * 0.5 + 0.5;
      float detail = fbm(vec3(cloudUV * 8.0, -u_time * 0.015 * u_waveSpeed)) * 0.5 + 0.5;
      float density = clouds * 0.7 + detail * 0.3;

      // Add noise intensity
      density += (snoise(vec3(uv * 50.0, u_time * 0.1)) * 0.5 + 0.5) * u_noiseIntensity;

      // Soft threshold for billowing edges
      float visible = smoothstep(0.35, 0.70, density);

      // Vignette
      float edgeFade = 1.0 - smoothstep(u_vignetteRadius * 0.5, u_vignetteRadius, dist) * u_vignetteIntensity;
      visible *= edgeFade;

      // Brightness and contrast adjustments
      visible = (visible + u_brightnessAdjust) * u_contrastAdjust;
      visible = clamp(visible, 0.0, 1.0);

      fragColor = vec4(vec3(visible), 1.0);
    }
  `

  const glyphFragmentShaderSource = `#version 300 es
    precision highp float;

    in vec2 v_uv;
    out vec4 fragColor;

    uniform sampler2D u_noiseTexture;
    uniform vec2 u_resolution;
    uniform float u_cellSize;
    uniform float u_hue;
    uniform float u_saturation;
    uniform float u_threshold1;
    uniform float u_threshold2;
    uniform float u_threshold3;
    uniform float u_threshold4;
    uniform float u_threshold5;

    // HSL to RGB conversion
    vec3 hsl2rgb(float h, float s, float l) {
      float c = (1.0 - abs(2.0 * l - 1.0)) * s;
      float hp = h / 60.0;
      float x = c * (1.0 - abs(mod(hp, 2.0) - 1.0));
      vec3 rgb;
      if (hp < 1.0) rgb = vec3(c, x, 0.0);
      else if (hp < 2.0) rgb = vec3(x, c, 0.0);
      else if (hp < 3.0) rgb = vec3(0.0, c, x);
      else if (hp < 4.0) rgb = vec3(0.0, x, c);
      else if (hp < 5.0) rgb = vec3(x, 0.0, c);
      else rgb = vec3(c, 0.0, x);
      float m = l - c * 0.5;
      return rgb + m;
    }

    // Glyph drawing functions (SDF-based)
    float drawDot(vec2 uv) {
      vec2 center = vec2(0.5, 0.5);
      float dist = length(uv - center);
      return smoothstep(0.2, 0.15, dist);
    }

    float drawDash(vec2 uv) {
      float h = smoothstep(0.35, 0.4, uv.y) * smoothstep(0.65, 0.6, uv.y);
      float w = smoothstep(0.15, 0.2, uv.x) * smoothstep(0.85, 0.8, uv.x);
      return h * w;
    }

    float drawPlus(vec2 uv) {
      float horiz = smoothstep(0.35, 0.4, uv.y) * smoothstep(0.65, 0.6, uv.y) *
                    smoothstep(0.1, 0.15, uv.x) * smoothstep(0.9, 0.85, uv.x);
      float vert = smoothstep(0.35, 0.4, uv.x) * smoothstep(0.65, 0.6, uv.x) *
                   smoothstep(0.1, 0.15, uv.y) * smoothstep(0.9, 0.85, uv.y);
      return max(horiz, vert);
    }

    float drawO(vec2 uv) {
      vec2 center = vec2(0.5, 0.5);
      float dist = length(uv - center);
      float outer = smoothstep(0.4, 0.35, dist);
      float inner = smoothstep(0.2, 0.25, dist);
      return outer * inner;
    }

    float drawX(vec2 uv) {
      vec2 c = uv - 0.5;
      float d1 = abs(c.x - c.y);
      float d2 = abs(c.x + c.y);
      float line1 = smoothstep(0.15, 0.1, d1);
      float line2 = smoothstep(0.15, 0.1, d2);
      float bounds = smoothstep(0.45, 0.4, abs(c.x)) * smoothstep(0.45, 0.4, abs(c.y));
      return max(line1, line2) * bounds;
    }

    float getGlyph(float brightness, vec2 localUV) {
      if (brightness < u_threshold1) {
        return 0.0; // Empty
      } else if (brightness < u_threshold2) {
        return drawDot(localUV);
      } else if (brightness < u_threshold3) {
        return drawDash(localUV);
      } else if (brightness < u_threshold4) {
        return drawPlus(localUV);
      } else if (brightness < u_threshold5) {
        return drawO(localUV);
      } else {
        return drawX(localUV);
      }
    }

    void main() {
      // Calculate cell coordinates
      vec2 cellCount = u_resolution / u_cellSize;
      vec2 cellCoord = floor(v_uv * cellCount);
      vec2 cellUV = (cellCoord + 0.5) / cellCount;

      // Sample brightness at cell center
      float brightness = texture(u_noiseTexture, cellUV).r;

      // Get local position within cell (0-1)
      vec2 localUV = fract(v_uv * cellCount);

      // Get glyph value
      float glyphValue = getGlyph(brightness, localUV);

      // Apply color
      vec3 glyphColor = hsl2rgb(u_hue, u_saturation, 0.5 + brightness * 0.3);
      vec3 bgColor = vec3(0.02, 0.02, 0.02);

      vec3 finalColor = mix(bgColor, glyphColor, glyphValue * brightness);

      fragColor = vec4(finalColor, 1.0);
    }
  `

  // Compile shader
  function compileShader(type: number, source: string): WebGLShader {
    const shader = gl!.createShader(type)
    if (!shader) throw new Error('Failed to create shader')

    gl!.shaderSource(shader, source)
    gl!.compileShader(shader)

    if (!gl!.getShaderParameter(shader, gl!.COMPILE_STATUS)) {
      const info = gl!.getShaderInfoLog(shader)
      gl!.deleteShader(shader)
      throw new Error('Shader compilation error: ' + info)
    }

    return shader
  }

  // Create program
  function createProgram(vertSource: string, fragSource: string): WebGLProgram {
    const vertShader = compileShader(gl!.VERTEX_SHADER, vertSource)
    const fragShader = compileShader(gl!.FRAGMENT_SHADER, fragSource)

    const program = gl!.createProgram()
    if (!program) throw new Error('Failed to create program')

    gl!.attachShader(program, vertShader)
    gl!.attachShader(program, fragShader)
    gl!.linkProgram(program)

    if (!gl!.getProgramParameter(program, gl!.LINK_STATUS)) {
      const info = gl!.getProgramInfoLog(program)
      throw new Error('Program link error: ' + info)
    }

    return program
  }

  // Create programs
  const noiseProgram = createProgram(vertexShaderSource, noiseFragmentShaderSource)
  const glyphProgram = createProgram(vertexShaderSource, glyphFragmentShaderSource)

  // Get uniform locations - noise program
  const noiseUniforms = {
    time: gl.getUniformLocation(noiseProgram, 'u_time'),
    resolution: gl.getUniformLocation(noiseProgram, 'u_resolution'),
    waveAmplitude: gl.getUniformLocation(noiseProgram, 'u_waveAmplitude'),
    waveFrequency: gl.getUniformLocation(noiseProgram, 'u_waveFrequency'),
    waveSpeed: gl.getUniformLocation(noiseProgram, 'u_waveSpeed'),
    noiseIntensity: gl.getUniformLocation(noiseProgram, 'u_noiseIntensity'),
    vignetteIntensity: gl.getUniformLocation(noiseProgram, 'u_vignetteIntensity'),
    vignetteRadius: gl.getUniformLocation(noiseProgram, 'u_vignetteRadius'),
    brightnessAdjust: gl.getUniformLocation(noiseProgram, 'u_brightnessAdjust'),
    contrastAdjust: gl.getUniformLocation(noiseProgram, 'u_contrastAdjust'),
  }

  // Get uniform locations - glyph program
  const glyphUniforms = {
    noiseTexture: gl.getUniformLocation(glyphProgram, 'u_noiseTexture'),
    resolution: gl.getUniformLocation(glyphProgram, 'u_resolution'),
    cellSize: gl.getUniformLocation(glyphProgram, 'u_cellSize'),
    hue: gl.getUniformLocation(glyphProgram, 'u_hue'),
    saturation: gl.getUniformLocation(glyphProgram, 'u_saturation'),
    threshold1: gl.getUniformLocation(glyphProgram, 'u_threshold1'),
    threshold2: gl.getUniformLocation(glyphProgram, 'u_threshold2'),
    threshold3: gl.getUniformLocation(glyphProgram, 'u_threshold3'),
    threshold4: gl.getUniformLocation(glyphProgram, 'u_threshold4'),
    threshold5: gl.getUniformLocation(glyphProgram, 'u_threshold5'),
  }

  // Create full-screen quad
  const quadBuffer = gl.createBuffer()
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer)
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,
     1, -1,
    -1,  1,
     1,  1,
  ]), gl.STATIC_DRAW)

  // Create VAO
  const quadVAO = gl.createVertexArray()
  gl.bindVertexArray(quadVAO)

  const positionLoc = gl.getAttribLocation(noiseProgram, 'a_position')
  gl.enableVertexAttribArray(positionLoc)
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0)

  // Create framebuffer and texture for noise pass
  let framebuffer: WebGLFramebuffer | null = null
  let noiseTexture: WebGLTexture | null = null

  function createFramebuffer(width: number, height: number) {
    // Clean up old resources
    if (framebuffer) gl!.deleteFramebuffer(framebuffer)
    if (noiseTexture) gl!.deleteTexture(noiseTexture)

    // Create texture
    noiseTexture = gl!.createTexture()
    gl!.bindTexture(gl!.TEXTURE_2D, noiseTexture)
    gl!.texImage2D(gl!.TEXTURE_2D, 0, gl!.RGBA, width, height, 0, gl!.RGBA, gl!.UNSIGNED_BYTE, null)
    gl!.texParameteri(gl!.TEXTURE_2D, gl!.TEXTURE_MIN_FILTER, gl!.LINEAR)
    gl!.texParameteri(gl!.TEXTURE_2D, gl!.TEXTURE_MAG_FILTER, gl!.LINEAR)
    gl!.texParameteri(gl!.TEXTURE_2D, gl!.TEXTURE_WRAP_S, gl!.CLAMP_TO_EDGE)
    gl!.texParameteri(gl!.TEXTURE_2D, gl!.TEXTURE_WRAP_T, gl!.CLAMP_TO_EDGE)

    // Create framebuffer
    framebuffer = gl!.createFramebuffer()
    gl!.bindFramebuffer(gl!.FRAMEBUFFER, framebuffer)
    gl!.framebufferTexture2D(gl!.FRAMEBUFFER, gl!.COLOR_ATTACHMENT0, gl!.TEXTURE_2D, noiseTexture, 0)

    gl!.bindFramebuffer(gl!.FRAMEBUFFER, null)
  }

  // Resize handler
  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1))
    const rect = canvas.getBoundingClientRect()
    const width = Math.floor(rect.width * dpr)
    const height = Math.floor(rect.height * dpr)

    if (canvas.width !== width || canvas.height !== height) {
      canvas.width = width
      canvas.height = height
      createFramebuffer(width, height)
    }
  }

  resize()
  window.addEventListener('resize', resize)

  // ============================================
  // Render Loop
  // ============================================
  let lastTime = 0

  function render(currentTime: number) {
    const deltaTime = (currentTime - lastTime) / 1000
    lastTime = currentTime

    if (!isPaused) {
      time += deltaTime * state.timeSpeed
    }

    resize()

    const width = canvas.width
    const height = canvas.height

    // Pass 1: Render noise to framebuffer
    gl!.bindFramebuffer(gl!.FRAMEBUFFER, framebuffer)
    gl!.viewport(0, 0, width, height)
    gl!.useProgram(noiseProgram)

    gl!.uniform1f(noiseUniforms.time, time)
    gl!.uniform2f(noiseUniforms.resolution, width, height)
    gl!.uniform1f(noiseUniforms.waveAmplitude, state.waveAmplitude)
    gl!.uniform1f(noiseUniforms.waveFrequency, state.waveFrequency)
    gl!.uniform1f(noiseUniforms.waveSpeed, state.waveSpeed)
    gl!.uniform1f(noiseUniforms.noiseIntensity, state.noiseIntensity)
    gl!.uniform1f(noiseUniforms.vignetteIntensity, state.vignetteIntensity)
    gl!.uniform1f(noiseUniforms.vignetteRadius, state.vignetteRadius)
    gl!.uniform1f(noiseUniforms.brightnessAdjust, state.brightnessAdjust)
    gl!.uniform1f(noiseUniforms.contrastAdjust, state.contrastAdjust)

    gl!.bindVertexArray(quadVAO)
    gl!.drawArrays(gl!.TRIANGLE_STRIP, 0, 4)

    // Pass 2: Render glyphs to screen
    gl!.bindFramebuffer(gl!.FRAMEBUFFER, null)
    gl!.viewport(0, 0, width, height)
    gl!.useProgram(glyphProgram)

    gl!.activeTexture(gl!.TEXTURE0)
    gl!.bindTexture(gl!.TEXTURE_2D, noiseTexture)
    gl!.uniform1i(glyphUniforms.noiseTexture, 0)

    gl!.uniform2f(glyphUniforms.resolution, width, height)
    gl!.uniform1f(glyphUniforms.cellSize, state.cellSize * (window.devicePixelRatio || 1))
    gl!.uniform1f(glyphUniforms.hue, state.hue)
    gl!.uniform1f(glyphUniforms.saturation, state.saturation)
    gl!.uniform1f(glyphUniforms.threshold1, state.threshold1)
    gl!.uniform1f(glyphUniforms.threshold2, state.threshold2)
    gl!.uniform1f(glyphUniforms.threshold3, state.threshold3)
    gl!.uniform1f(glyphUniforms.threshold4, state.threshold4)
    gl!.uniform1f(glyphUniforms.threshold5, state.threshold5)

    gl!.drawArrays(gl!.TRIANGLE_STRIP, 0, 4)

    requestAnimationFrame(render)
  }

  requestAnimationFrame(render)

  // ============================================
  // Controls
  // ============================================
  function updateSliderValue(id: string, value: number, decimals: number = 2) {
    const valueEl = document.getElementById(id + 'Value')
    if (valueEl) {
      valueEl.textContent = value.toFixed(decimals)
    }
  }

  function setupSlider(id: keyof State, decimals: number = 2) {
    const input = document.getElementById(id) as HTMLInputElement
    if (!input) return

    input.addEventListener('input', () => {
      const value = parseFloat(input.value)
      state[id] = value as never
      updateSliderValue(id, value, decimals)
    })
  }

  // Setup all sliders
  setupSlider('cellSize', 0)
  setupSlider('waveAmplitude', 3)
  setupSlider('waveFrequency', 1)
  setupSlider('waveSpeed', 2)
  setupSlider('noiseIntensity', 3)
  setupSlider('vignetteIntensity', 2)
  setupSlider('vignetteRadius', 2)
  setupSlider('brightnessAdjust', 2)
  setupSlider('contrastAdjust', 2)
  setupSlider('timeSpeed', 1)
  setupSlider('hue', 0)
  setupSlider('saturation', 2)
  setupSlider('threshold1', 2)
  setupSlider('threshold2', 2)
  setupSlider('threshold3', 2)
  setupSlider('threshold4', 2)
  setupSlider('threshold5', 2)

  // Apply preset
  function applyPreset(presetName: string) {
    const preset = presets[presetName]
    if (!preset) return

    Object.entries(preset).forEach(([key, value]) => {
      const k = key as keyof State
      state[k] = value as never

      const input = document.getElementById(key) as HTMLInputElement
      if (input) {
        input.value = String(value)
        const decimals = key === 'cellSize' || key === 'hue' ? 0 :
                        key.includes('Amplitude') || key.includes('Intensity') && key !== 'vignetteIntensity' ? 3 : 2
        updateSliderValue(key, value as number, decimals)
      }
    })
  }

  // Preset buttons
  document.querySelectorAll('.preset').forEach((btn) => {
    btn.addEventListener('click', () => {
      const presetName = (btn as HTMLElement).dataset.preset
      if (presetName) applyPreset(presetName)
    })
  })

  // Toggle controls
  btnToggleControls.addEventListener('click', () => {
    controlsVisible = !controlsVisible
    controlsBody.style.display = controlsVisible ? 'block' : 'none'
    btnToggleControls.textContent = controlsVisible ? 'Controls' : 'Show Controls'
  })

  // Pause button
  btnPause.addEventListener('click', () => {
    isPaused = !isPaused
    btnPause.textContent = isPaused ? 'Resume' : 'Pause'
  })

  // Fullscreen button
  btnFullscreen.addEventListener('click', () => {
    if (document.fullscreenElement) {
      document.exitFullscreen()
    } else {
      document.getElementById('app')?.requestFullscreen()
    }
  })

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      e.preventDefault()
      isPaused = !isPaused
      btnPause.textContent = isPaused ? 'Resume' : 'Pause'
    } else if (e.code === 'KeyF') {
      if (document.fullscreenElement) {
        document.exitFullscreen()
      } else {
        document.getElementById('app')?.requestFullscreen()
      }
    }
  })
</script>

<style>
  #app {
    position: relative;
    width: 100%;
    height: calc(100dvh - 2rem);
    background: #000;
    overflow: hidden;
  }

  #app:fullscreen {
    height: 100dvh;
  }

  #canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
  }

  .controls {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: rgba(0, 0, 0, 0.85);
    border: 1px solid var(--theme-border);
    border-radius: 8px;
    padding: 0.75rem;
    max-width: 320px;
    max-height: calc(100% - 4rem);
    overflow-y: auto;
    z-index: 10;
  }

  .controls-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.75rem;
  }

  .controls-actions {
    display: flex;
    gap: 0.5rem;
  }

  .controls-body {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .control-section {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .section-title {
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--theme-text-subtle);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    padding-bottom: 0.25rem;
    border-bottom: 1px solid var(--theme-border);
  }

  .preset-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .preset {
    flex: 1;
    min-width: 60px;
    padding: 0.4rem 0.6rem;
    font-size: 0.75rem;
  }

  button {
    background: var(--theme-bg);
    color: var(--theme-text);
    border: 1px solid var(--theme-border);
    border-radius: 4px;
    padding: 0.4rem 0.8rem;
    font-family: var(--font-sans);
    font-size: 0.8rem;
    cursor: pointer;
    transition: background 0.15s, border-color 0.15s;
  }

  button:hover {
    background: var(--theme-border);
  }

  button:active {
    background: var(--theme-accent);
  }

  .toggle-btn {
    font-weight: 600;
  }

  .slider {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 0.25rem 0.5rem;
    align-items: center;
    color: var(--theme-text-subtle);
    font-size: 0.75rem;
  }

  .slider input[type='range'] {
    grid-column: 1 / -1;
    width: 100%;
    height: 4px;
    -webkit-appearance: none;
    appearance: none;
    background: var(--theme-border);
    border-radius: 2px;
    cursor: pointer;
  }

  .slider input[type='range']::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 12px;
    height: 12px;
    background: var(--theme-accent);
    border-radius: 50%;
    cursor: pointer;
  }

  .slider input[type='range']::-moz-range-thumb {
    width: 12px;
    height: 12px;
    background: var(--theme-accent);
    border-radius: 50%;
    cursor: pointer;
    border: none;
  }

  .slider .value {
    font-family: var(--font-mono);
    color: var(--theme-text);
    min-width: 3.5em;
    text-align: right;
  }

  .glyph-label {
    font-family: var(--font-mono);
  }

  .info {
    position: absolute;
    bottom: 1rem;
    left: 50%;
    transform: translateX(-50%);
    color: var(--theme-text-dim);
    font-size: 0.75rem;
    text-align: center;
    pointer-events: none;
  }

  kbd {
    background: var(--theme-border);
    border-radius: 3px;
    padding: 0.1em 0.4em;
    font-family: var(--font-mono);
    font-size: 0.9em;
  }

  @media (max-width: 640px) {
    .controls {
      top: auto;
      bottom: 3rem;
      right: 0.5rem;
      left: 0.5rem;
      max-width: none;
      max-height: 50vh;
    }

    .info {
      bottom: 0.5rem;
      font-size: 0.65rem;
    }
  }
</style>
