---
import HeaderLayout from '../../layouts/HeaderLayout.astro'
---

<HeaderLayout title="Orbit Simulation">
  <div id="simulation">
    <canvas id="orbitCanvas"></canvas>

    <div class="controls-panel">
      <h1>Orbit Simulator</h1>

      <div class="control-group">
        <label>
          Preset
          <select id="preset">
            <option value="default">Simple Orbit</option>
            <option value="binary">Binary System</option>
            <option value="moon">Planet with Moon</option>
            <option value="triple">Triple System</option>
            <option value="empty">Empty</option>
          </select>
        </label>
      </div>

      <div class="control-group">
        <label>
          Speed <span id="speedValue">1x</span>
          <input type="range" id="speed" min="0" max="5" step="1" value="1" />
        </label>
      </div>

      <div class="control-group">
        <label>
          Trail Length <span id="trailLengthValue">100</span>
          <input type="range" id="trailLength" min="0" max="1000" step="10" value="100" />
        </label>
      </div>

      <div class="control-group">
        <label>
          Time Step <span id="dtValue">0.01</span>
          <input type="range" id="dt" min="0.01" max="0.2" step="0.01" value="0.01" />
        </label>
      </div>

      <div class="control-group">
        <label>
          New Body Mass <span id="defaultMassValue">1.0</span>
          <input type="range" id="defaultMass" min="0.1" max="10" step="0.1" value="1" />
        </label>
      </div>

      <div class="instructions">
        <p><strong>Controls:</strong></p>
        <p>• Click & drag to add bodies</p>
        <p>• Drag existing bodies to move</p>
        <p>• Scroll on body to change mass</p>
        <p>• Right-click to delete</p>
      </div>
    </div>
  </div>
</HeaderLayout>

<style>
  #simulation {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
  }

  #orbitCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #000;
    cursor: crosshair;
  }

  .controls-panel {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(8px);
    border: 1px solid var(--theme-border);
    border-radius: 0.5rem;
    padding: 1rem;
    min-width: fit-content;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    z-index: 1000;
  }

  h1 {
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 1rem;
    text-align: center;
    border-bottom: 1px solid var(--theme-border);
  }

  .control-group {
    margin-bottom: 16px;
  }

  label {
    opacity: 0.9;
  }

  label span {
    float: right;
    font-family: var(--font-mono);
    color: var(--theme-accent);
  }

  select {
    padding: 0.25rem 0.5rem;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid var(--theme-border);
    border-radius: 0.25rem;
    font-size: 0.875rem;
    cursor: pointer;

    &:hover {
      background: rgba(255, 255, 255, 0.15);
    }
  }

  select option {
    background: #222;
  }

  input[type='range'] {
    width: 100%;
    height: 0.3rem;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
    outline: none;
    -webkit-appearance: none;
    cursor: pointer;

    &::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 1rem;
      height: 1rem;
      background: white;
      border-radius: 50%;
    }

    &::-moz-range-thumb {
      width: 1rem;
      height: 1rem;
      background: white;
      border: none;
      border-radius: 50%;
    }
  }

  .instructions {
    margin-top: 20px;
    padding-top: 16px;
    border-top: 1px solid var(--theme-border);
  }

  .instructions p {
    margin: 0 0 8px 0;
    font-size: 0.8rem;
    color: rgba(255, 255, 255, 0.7);
    line-height: 1.4;
  }

  .instructions strong {
    color: white;
    font-size: 0.875rem;
  }
</style>

<script>
  const canvas = document.getElementById('orbitCanvas') as HTMLCanvasElement
  const ctx = canvas.getContext('2d')!
  const presetSelect = document.getElementById('preset') as HTMLSelectElement
  const speedSlider = document.getElementById('speed') as HTMLInputElement
  const speedValue = document.getElementById('speedValue') as HTMLSpanElement
  const trailLengthSlider = document.getElementById('trailLength') as HTMLInputElement
  const trailLengthValue = document.getElementById('trailLengthValue') as HTMLSpanElement
  const dtSlider = document.getElementById('dt') as HTMLInputElement
  const dtValue = document.getElementById('dtValue') as HTMLSpanElement
  const defaultMassSlider = document.getElementById('defaultMass') as HTMLInputElement
  const defaultMassValue = document.getElementById('defaultMassValue') as HTMLSpanElement

  // Set canvas size to window size
  function resizeCanvas() {
    canvas.width = window.innerWidth
    canvas.height = window.innerHeight
  }

  resizeCanvas()
  window.addEventListener('resize', resizeCanvas)

  // Body type definition
  type Body = {
    x: [number, number] // position
    v: [number, number] // velocity
    mass: number
    color: string
    trail: [number, number][]
  }

  type PreviewBody = {
    x: [number, number]
    v: [number, number]
    mass: number
    color: string
  }

  // Array of all bodies
  let bodies: Body[] = []

  // Simulation parameters
  const G = 1.0 // Gravitational constant
  let dt = dtSlider.valueAsNumber // Time step
  const scale = 150 // pixels per unit

  // Default mass for new bodies
  let defaultMass = defaultMassSlider.valueAsNumber
  let maxTrailLength = trailLengthSlider.valueAsNumber
  let animationSpeed = speedSlider.valueAsNumber
  let animationId: number

  // Mouse interaction state
  let isDragging = false
  let dragStartPos: [number, number] | null = null
  let draggedBody: Body | null = null
  let hoveredBody: Body | null = null
  let previewBody: PreviewBody | null = null
  let isDraggingNewBody = false

  // Color palette for bodies
  const colors = ['#ffff00', '#ff0000', '#00ff00', '#ff00ff', '#00ffff', '#ffa500', '#ff1493', '#00bfff']
  let colorIndex = 0

  // Convert simulation coordinates to canvas coordinates
  function toCanvasCoords(simX: number, simY: number): [number, number] {
    return [
      canvas.width / 2 + simX * scale,
      canvas.height / 2 - simY * scale, // Flip Y axis
    ]
  }

  // Convert canvas coordinates to simulation coordinates
  function toSimCoords(canvasX: number, canvasY: number): [number, number] {
    return [
      (canvasX - canvas.width / 2) / scale,
      -(canvasY - canvas.height / 2) / scale, // Flip Y axis back
    ]
  }

  // Get body radius based on mass
  function getBodyRadius(mass: number): number {
    return Math.max(5, Math.sqrt(mass) * 8)
  }

  // Check if point is inside body
  function isPointInBody(canvasX: number, canvasY: number, body: Body): boolean {
    const [bodyCanvasX, bodyCanvasY] = toCanvasCoords(body.x[0], body.x[1])
    const radius = getBodyRadius(body.mass)
    const dx = canvasX - bodyCanvasX
    const dy = canvasY - bodyCanvasY
    return dx * dx + dy * dy <= radius * radius
  }

  // Find body at canvas position
  function getBodyAt(canvasX: number, canvasY: number): Body | null {
    for (let i = bodies.length - 1; i >= 0; i--) {
      if (isPointInBody(canvasX, canvasY, bodies[i])) {
        return bodies[i]
      }
    }
    return null
  }

  // N-body simulation step using Euler method
  function step() {
    // Softening parameter to prevent singularities when bodies get too close
    const epsilon = 0.5

    // Calculate accelerations for all bodies
    const accelerations: [number, number][] = []

    for (let i = 0; i < bodies.length; i++) {
      let ax = 0
      let ay = 0

      // Sum gravitational forces from all other bodies
      for (let j = 0; j < bodies.length; j++) {
        if (i === j) continue

        const dx = bodies[j].x[0] - bodies[i].x[0]
        const dy = bodies[j].x[1] - bodies[i].x[1]
        const r2 = dx * dx + dy * dy

        // Softened gravity: use (r² + ε²)^(3/2) instead of r³
        // This prevents extreme forces when bodies get very close
        const r2_soft = r2 + epsilon * epsilon
        const r3_soft = Math.pow(r2_soft, 1.5)
        const force = (G * bodies[j].mass) / r3_soft

        ax += force * dx
        ay += force * dy
      }

      accelerations.push([ax, ay])
    }

    // Update velocities and positions
    for (let i = 0; i < bodies.length; i++) {
      const body = bodies[i]
      const [ax, ay] = accelerations[i]

      // Update velocity: v_new = v + a * dt
      body.v[0] += ax * dt
      body.v[1] += ay * dt

      // Update position: x_new = x + v * dt
      body.x[0] += body.v[0] * dt
      body.x[1] += body.v[1] * dt

      // Add to trail
      body.trail.push([body.x[0], body.x[1]])
      // Limit trail length
      body.trail.splice(0, body.trail.length - maxTrailLength)
    }
  }

  // Draw the simulation
  function draw() {
    // Clear canvas fully
    ctx.fillStyle = '#000'
    ctx.fillRect(0, 0, canvas.width, canvas.height)

    // Draw all bodies
    for (const body of bodies) {
      // Draw trail with fading effect
      if (body.trail.length > 1) {
        for (let i = 1; i < body.trail.length; i++) {
          const alpha = (i / body.trail.length) * 0.6
          const rgb = hexToRgb(body.color)
          ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`
          ctx.lineWidth = 2
          ctx.beginPath()
          const [x1, y1] = toCanvasCoords(body.trail[i - 1][0], body.trail[i - 1][1])
          const [x2, y2] = toCanvasCoords(body.trail[i][0], body.trail[i][1])
          ctx.moveTo(x1, y1)
          ctx.lineTo(x2, y2)
          ctx.stroke()
        }
      }

      // Draw body
      const [bodyX, bodyY] = toCanvasCoords(body.x[0], body.x[1])
      const radius = getBodyRadius(body.mass)

      // Highlight if hovered
      if (body === hoveredBody) {
        ctx.strokeStyle = '#fff'
        ctx.lineWidth = 2
        ctx.beginPath()
        ctx.arc(bodyX, bodyY, radius + 3, 0, Math.PI * 2)
        ctx.stroke()
      }

      ctx.fillStyle = body.color
      ctx.beginPath()
      ctx.arc(bodyX, bodyY, radius, 0, Math.PI * 2)
      ctx.fill()
    }

    // Draw preview body while creating new body
    if (previewBody && isDraggingNewBody) {
      const [previewX, previewY] = toCanvasCoords(previewBody.x[0], previewBody.x[1])
      const radius = getBodyRadius(previewBody.mass)

      // Draw preview body with dashed outline
      ctx.strokeStyle = previewBody.color
      ctx.lineWidth = 2
      ctx.setLineDash([5, 5])
      ctx.beginPath()
      ctx.arc(previewX, previewY, radius, 0, Math.PI * 2)
      ctx.stroke()
      ctx.setLineDash([])

      // Draw semi-transparent fill
      const rgb = hexToRgb(previewBody.color)
      ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.3)`
      ctx.beginPath()
      ctx.arc(previewX, previewY, radius, 0, Math.PI * 2)
      ctx.fill()
    }

    // Draw velocity vector while dragging
    if (isDragging && dragStartPos) {
      const mousePos = getMousePos(canvas)
      if (mousePos) {
        let startX, startY

        if (previewBody && isDraggingNewBody) {
          ;[startX, startY] = toCanvasCoords(previewBody.x[0], previewBody.x[1])
        } else if (draggedBody) {
          ;[startX, startY] = toCanvasCoords(draggedBody.x[0], draggedBody.x[1])
        } else {
          return
        }

        ctx.strokeStyle = '#ffffff'
        ctx.lineWidth = 2
        ctx.setLineDash([5, 5])
        ctx.beginPath()
        ctx.moveTo(startX, startY)
        ctx.lineTo(mousePos.x, mousePos.y)
        ctx.stroke()
        ctx.setLineDash([])

        // Draw arrowhead
        const angle = Math.atan2(mousePos.y - startY, mousePos.x - startX)
        const headLength = 10
        ctx.beginPath()
        ctx.moveTo(mousePos.x, mousePos.y)
        ctx.lineTo(mousePos.x - headLength * Math.cos(angle - Math.PI / 6), mousePos.y - headLength * Math.sin(angle - Math.PI / 6))
        ctx.moveTo(mousePos.x, mousePos.y)
        ctx.lineTo(mousePos.x - headLength * Math.cos(angle + Math.PI / 6), mousePos.y - headLength * Math.sin(angle + Math.PI / 6))
        ctx.stroke()
      }
    }
  }

  // Helper to convert hex color to RGB
  function hexToRgb(hex: string): { r: number; g: number; b: number } {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
    return result
      ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16),
        }
      : { r: 255, g: 255, b: 255 }
  }

  // Get mouse position relative to canvas
  let cachedMousePos: { x: number; y: number } | null = null
  function getMousePos(canvas: HTMLCanvasElement): { x: number; y: number } | null {
    return cachedMousePos
  }

  // Animation loop
  function animate() {
    // Run multiple steps based on animation speed
    const stepsPerFrame = Math.ceil(animationSpeed)
    for (let i = 0; i < stepsPerFrame; i++) {
      step()
    }

    draw()
    animationId = requestAnimationFrame(animate)
  }

  // Preset configurations
  const presets: Record<string, Body[]> = {
    default: [
      { x: [0, 0], v: [0, 0], mass: 10, color: colors[0], trail: [] },
      { x: [1, 0], v: [0, 0.32], mass: 0.5, color: colors[1], trail: [] },
    ],
    binary: [
      { x: [-0.5, 0], v: [0, -0.3], mass: 5, color: colors[0], trail: [] },
      { x: [0.5, 0], v: [0, 0.3], mass: 5, color: colors[1], trail: [] },
    ],
    moon: [
      { x: [0, 0], v: [0, 0], mass: 10, color: colors[0], trail: [] },
      { x: [1.5, 0], v: [0, 0.26], mass: 1, color: colors[1], trail: [] },
      { x: [1.7, 0], v: [0, 0.32], mass: 0.1, color: colors[2], trail: [] },
    ],
    triple: [
      { x: [0, 0], v: [0, 0], mass: 8, color: colors[0], trail: [] },
      { x: [1, 0], v: [0, 0.28], mass: 1, color: colors[1], trail: [] },
      { x: [-1, 0], v: [0, -0.28], mass: 1, color: colors[2], trail: [] },
    ],
    empty: [],
  }

  // Load preset
  function loadPreset(presetName: string) {
    const preset = presets[presetName] || presets.default
    bodies = preset.map((b) => ({
      x: [...b.x] as [number, number],
      v: [...b.v] as [number, number],
      mass: b.mass,
      color: b.color,
      trail: [],
    }))
    colorIndex = Math.max(2, bodies.length)
  }

  // Mouse event handlers
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect()
    cachedMousePos = {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top,
    }

    if (isDragging && draggedBody && dragStartPos) {
      // Dragging: update velocity vector
      return
    }

    // Update hovered body
    hoveredBody = getBodyAt(cachedMousePos.x, cachedMousePos.y)
    canvas.style.cursor = hoveredBody ? 'pointer' : 'crosshair'
  })

  canvas.addEventListener('mousedown', (e) => {
    if (e.button !== 0) return // Only left click

    const rect = canvas.getBoundingClientRect()
    const mouseX = e.clientX - rect.left
    const mouseY = e.clientY - rect.top

    const body = getBodyAt(mouseX, mouseY)

    if (body) {
      // Start dragging existing body
      draggedBody = body
      dragStartPos = [body.x[0], body.x[1]]
      isDraggingNewBody = false
    } else {
      // Create preview for new body
      const [simX, simY] = toSimCoords(mouseX, mouseY)
      previewBody = {
        x: [simX, simY],
        v: [0, 0],
        mass: defaultMass,
        color: colors[colorIndex % colors.length],
      }
      dragStartPos = [simX, simY]
      isDraggingNewBody = true
    }

    isDragging = true
  })

  canvas.addEventListener('mouseup', (e) => {
    if (!isDragging || !dragStartPos) return

    const rect = canvas.getBoundingClientRect()
    const mouseX = e.clientX - rect.left
    const mouseY = e.clientY - rect.top
    const [simX, simY] = toSimCoords(mouseX, mouseY)

    const velocityScale = 0.5

    if (isDraggingNewBody && previewBody) {
      // Create real body from preview
      const newBody: Body = {
        x: previewBody.x,
        v: [(simX - dragStartPos[0]) * velocityScale, (simY - dragStartPos[1]) * velocityScale],
        mass: previewBody.mass,
        color: previewBody.color,
        trail: [],
      }
      bodies.push(newBody)
      colorIndex++
      previewBody = null
    } else if (draggedBody) {
      // Update velocity of existing body
      draggedBody.v[0] = (simX - dragStartPos[0]) * velocityScale
      draggedBody.v[1] = (simY - dragStartPos[1]) * velocityScale
    }

    isDragging = false
    isDraggingNewBody = false
    dragStartPos = null
    draggedBody = null
  })

  canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault()
    const rect = canvas.getBoundingClientRect()
    const mouseX = e.clientX - rect.left
    const mouseY = e.clientY - rect.top

    const body = getBodyAt(mouseX, mouseY)
    if (body) {
      bodies = bodies.filter((b) => b !== body)
    }
  })

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault()
    const rect = canvas.getBoundingClientRect()
    const mouseX = e.clientX - rect.left
    const mouseY = e.clientY - rect.top

    const body = getBodyAt(mouseX, mouseY)
    if (body) {
      const delta = e.deltaY > 0 ? -0.1 : 0.1
      body.mass = Math.max(0.1, Math.min(20, body.mass + delta))
    }
  })

  // Event listeners
  presetSelect.addEventListener('change', () => {
    loadPreset(presetSelect.value)
  })

  speedSlider.addEventListener('input', () => {
    animationSpeed = speedSlider.valueAsNumber
    speedValue.textContent = animationSpeed.toString() + 'x'
  })

  trailLengthSlider.addEventListener('input', () => {
    maxTrailLength = trailLengthSlider.valueAsNumber
    trailLengthValue.textContent = maxTrailLength.toString()
  })

  dtSlider.addEventListener('input', () => {
    dt = parseFloat(dtSlider.value)
    dtValue.textContent = dt.toFixed(2)
  })

  defaultMassSlider.addEventListener('input', () => {
    defaultMass = parseFloat(defaultMassSlider.value)
    defaultMassValue.textContent = defaultMass.toFixed(1)
  })

  // Initialize and start animation
  loadPreset('default')
  animate()
</script>
