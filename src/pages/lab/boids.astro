---
import HeaderLayout from '../../layouts/HeaderLayout.astro'
---

<HeaderLayout title="Boids Ecosystem">
  <div id="app">
    <canvas id="canvas"></canvas>

    <div class="hud">
      <div class="stats" id="stats">
        <div class="row"><span class="k">FPS</span><span class="v" id="fps">--</span></div>
        <div class="row"><span class="k">Herbivores</span><span class="v" id="statHerb">0</span></div>
        <div class="row"><span class="k">Predators</span><span class="v" id="statPred">0</span></div>
        <div class="row"><span class="k">Scavengers</span><span class="v" id="statScav">0</span></div>
        <div class="row"><span class="k">Food</span><span class="v" id="statFood">0</span></div>
        <div class="row"><span class="k">Carrion</span><span class="v" id="statCarrion">0</span></div>
        <div class="row"><span class="k">Births</span><span class="v" id="statBirths">0</span></div>
        <div class="row"><span class="k">Deaths</span><span class="v" id="statDeaths">0</span></div>
        <div class="row"><span class="k">Hunts</span><span class="v" id="statHunts">0</span></div>
        <div class="row"><span class="k">Decomp</span><span class="v" id="statDecomp">0</span></div>
      </div>

      <div class="banner" id="perfBanner" hidden>
        <div class="banner-title">Low performance</div>
        <div class="banner-body" id="perfText">FPS low.</div>
        <div class="banner-actions">
          <button id="btnReduce">Reduce population 50%</button>
          <button id="btnDisableTrails">Disable trails</button>
          <button id="btnDismiss">Dismiss</button>
        </div>
      </div>
    </div>

    <div class="bottom-bar" id="bottomBar">
      <button class="species selected" data-species="herbivore" id="btnHerb">
        <span class="dot herb"></span>
        <span>Herbivore</span>
      </button>
      <button class="species" data-species="predator" id="btnPred">
        <span class="dot pred"></span>
        <span>Predator</span>
      </button>
      <button class="species" data-species="scavenger" id="btnScav">
        <span class="dot scav"></span>
        <span>Scavenger</span>
      </button>
      <button class="menu" id="btnMenu">Menu</button>
    </div>

    <aside class="panel" id="panel" hidden>
      <div class="panel-header">
        <div class="panel-title">Boids Ecosystem</div>
        <button class="panel-close" id="btnClose">Close</button>
      </div>

      <div class="tabs">
        <button class="tab selected" data-tab="presets">Presets</button>
        <button class="tab" data-tab="visuals">Visuals</button>
        <button class="tab" data-tab="settings">Settings</button>
        <button class="tab" data-tab="about">About</button>
      </div>

      <div class="tab-content" id="tab-presets">
        <button class="wide" id="presetBalanced">Balanced Ecosystem</button>
        <button class="wide" id="presetGenesis">Genesis</button>
        <button class="wide" id="presetPredator">Predator Paradise</button>
        <button class="wide" id="presetExtinction">Extinction Event</button>
        <button class="wide" id="presetEvolutionLab">Evolution Lab</button>

        <div class="seed">
          <label>
            Seed
            <input id="seedInput" type="number" min="0" max="999999" placeholder="(optional)" />
          </label>
          <div class="seed-actions">
            <button id="btnRandomSeed">Random</button>
            <button id="btnApplySeed">Apply</button>
          </div>
          <div class="seed-note" id="seedNote"></div>
        </div>
      </div>

      <div class="tab-content" id="tab-visuals" hidden>
        <label class="toggle"><input type="checkbox" id="togTrails" checked /> Trails</label>
        <label class="toggle"><input type="checkbox" id="togFov" checked /> FOV cones</label>
        <label class="toggle"><input type="checkbox" id="togVectors" /> Velocity vectors</label>
        <label class="toggle"><input type="checkbox" id="togPerception" /> Perception radius</label>
        <label class="toggle"><input type="checkbox" id="togGrid" /> Spatial grid</label>
      </div>

      <div class="tab-content" id="tab-settings" hidden>
        <label class="slider">
          Reproduction rate
          <input id="reproRate" type="range" min="0.05" max="0.25" step="0.01" value="0.15" />
          <span class="value" id="reproRateValue">0.15</span>
        </label>

        <label class="slider">
          Decomposition yield
          <input id="decompYield" type="range" min="1" max="4" step="1" value="2" />
          <span class="value" id="decompYieldValue">2</span>
        </label>

        <label class="slider">
          Mutation rate
          <input id="mutationRate" type="range" min="0.05" max="0.25" step="0.01" value="0.10" />
          <span class="value" id="mutationRateValue">0.10</span>
        </label>

        <label class="slider">
          Speed
          <input id="simSpeed" type="range" min="0.5" max="4" step="0.5" value="1" />
          <span class="value" id="simSpeedValue">1.0x</span>
        </label>

        <div class="row-buttons">
          <button class="wide" id="btnPause">Pause</button>
          <button class="wide" id="btnClear">Clear</button>
        </div>

        <div class="walls">
          <div class="walls-title">Walls</div>
          <label class="toggle"><input type="checkbox" id="wallTop" /> Top wall</label>
          <label class="toggle"><input type="checkbox" id="wallRight" /> Right wall</label>
          <label class="toggle"><input type="checkbox" id="wallBottom" /> Bottom wall</label>
          <label class="toggle"><input type="checkbox" id="wallLeft" /> Left wall</label>
        </div>
      </div>

      <div class="tab-content" id="tab-about" hidden>
        <p>
          Three-species boids ecosystem with a closed energy loop: food → herbivores → predators → carrion → scavengers → food. Energy is shown via color
          saturation.
        </p>
        <p>Tap to spawn one. Press & hold to accumulate a cluster.</p>
      </div>
    </aside>
  </div>
</HeaderLayout>

<style>
  #app {
    position: relative;
    width: 100dvw;
    height: calc(100dvh - 2.2rem);
    overflow: hidden;
    background: #0a0a0a;
  }

  #canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    touch-action: none;
  }

  .hud {
    position: absolute;
    top: 0.75rem;
    left: 0.75rem;
    right: 0.75rem;
    display: flex;
    justify-content: space-between;
    pointer-events: none;
    gap: 0.75rem;
  }

  .stats {
    pointer-events: auto;
    background: rgba(0, 0, 0, 0.45);
    border: 1px solid var(--theme-border);
    border-radius: 0.5rem;
    padding: 0.5rem 0.6rem;
    backdrop-filter: blur(10px);
    display: grid;
    gap: 0.1rem;
    width: 10.5rem;
    font-family: var(--font-mono);
    font-size: 0.75rem;
  }

  .row {
    display: flex;
    justify-content: space-between;
    gap: 0.75rem;
  }

  .k {
    color: rgba(255, 255, 255, 0.7);
  }

  .v {
    color: rgba(255, 255, 255, 0.95);
  }

  .banner {
    pointer-events: auto;
    flex: 1;
    max-width: 40rem;
    background: rgba(0, 0, 0, 0.75);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 0.75rem;
    padding: 0.75rem;
    backdrop-filter: blur(12px);
  }

  .banner-title {
    font-weight: 700;
    margin-bottom: 0.25rem;
  }

  .banner-body {
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: 0.5rem;
    font-size: 0.875rem;
  }

  .banner-actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  .bottom-bar {
    position: absolute;
    left: 0.75rem;
    right: 0.75rem;
    bottom: 0.75rem;
    display: flex;
    gap: 0.5rem;
    pointer-events: auto;
    user-select: none;
  }

  .species,
  .menu {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 0.6rem 0.75rem;
    border-radius: 999px;
    border: 1px solid rgba(255, 255, 255, 0.18);
    background: rgba(0, 0, 0, 0.6);
    color: rgba(255, 255, 255, 0.92);
    backdrop-filter: blur(8px);
    font-weight: 650;
    font-size: 0.85rem;
  }

  .species.selected {
    border-color: rgba(255, 255, 255, 0.35);
    box-shadow:
      0 0 0 1px rgba(255, 255, 255, 0.08),
      0 0 22px rgba(32, 225, 33, 0.25);
  }

  .dot {
    width: 0.7rem;
    height: 0.7rem;
    border-radius: 999px;
    display: inline-block;
    filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.1));
  }

  .dot.herb {
    background: #20e121;
  }
  .dot.pred {
    background: #e12120;
  }
  .dot.scav {
    background: #2120e1;
  }

  .panel {
    position: absolute;
    top: 0.75rem;
    right: 0.75rem;
    bottom: 4.75rem;
    width: min(24rem, calc(100dvw - 1.5rem));
    background: rgba(0, 0, 0, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 0.75rem;
    backdrop-filter: blur(12px);
    padding: 0.75rem;
    overflow: auto;
  }

  .panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 0.75rem;
    margin-bottom: 0.75rem;
  }

  .panel-title {
    font-weight: 700;
  }

  .panel-close {
    border-radius: 0.5rem;
    padding: 0.4rem 0.6rem;
    border: 1px solid rgba(255, 255, 255, 0.15);
    background: rgba(255, 255, 255, 0.07);
    color: rgba(255, 255, 255, 0.9);
  }

  .tabs {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 0.5rem;
    margin-bottom: 0.75rem;
  }

  .tab {
    border-radius: 0.6rem;
    padding: 0.45rem 0.4rem;
    border: 1px solid rgba(255, 255, 255, 0.12);
    background: rgba(255, 255, 255, 0.06);
    color: rgba(255, 255, 255, 0.85);
    font-size: 0.8rem;
  }

  .tab.selected {
    border-color: rgba(255, 255, 255, 0.25);
  }

  .tab-content {
    display: grid;
    gap: 0.6rem;
    font-size: 0.9rem;
    line-height: 1.3;
  }

  .wide {
    width: 100%;
    border-radius: 0.6rem;
    padding: 0.6rem 0.7rem;
    border: 1px solid rgba(255, 255, 255, 0.14);
    background: rgba(255, 255, 255, 0.08);
    color: rgba(255, 255, 255, 0.92);
    text-align: left;
  }

  .toggle {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: rgba(255, 255, 255, 0.9);
  }

  .slider {
    display: grid;
    gap: 0.35rem;
    color: rgba(255, 255, 255, 0.9);
  }

  .slider input[type='range'] {
    width: 100%;
  }

  .value {
    justify-self: end;
    font-family: var(--font-mono);
    color: rgba(255, 255, 255, 0.75);
  }

  .seed {
    margin-top: 0.25rem;
    border-top: 1px solid rgba(255, 255, 255, 0.12);
    padding-top: 0.75rem;
    display: grid;
    gap: 0.5rem;
  }

  .seed input {
    width: 100%;
    margin-top: 0.25rem;
    border-radius: 0.5rem;
    padding: 0.45rem 0.6rem;
    border: 1px solid rgba(255, 255, 255, 0.14);
    background: rgba(0, 0, 0, 0.4);
    color: rgba(255, 255, 255, 0.9);
  }

  .seed-actions {
    display: flex;
    gap: 0.5rem;
  }

  .seed-actions button {
    flex: 1;
  }

  .seed-note {
    font-family: var(--font-mono);
    font-size: 0.75rem;
    color: rgba(255, 255, 255, 0.6);
  }

  .row-buttons {
    display: flex;
    gap: 0.5rem;
  }

  .walls {
    margin-top: 0.25rem;
    border-top: 1px solid rgba(255, 255, 255, 0.12);
    padding-top: 0.75rem;
    display: grid;
    gap: 0.5rem;
  }

  .walls-title {
    font-weight: 650;
    margin-bottom: 0.25rem;
  }

  button {
    cursor: pointer;
  }
</style>

<script>
  type Species = 'herbivore' | 'predator' | 'scavenger'

  const opts = {
    colors: {
      herbivore: '#20e121',
      predator: '#e12120',
      scavenger: '#2120e1',
      background: '#0a0a0a',
      carrion: '#666688',
      dead: '#808080',
    },
    energy: {
      herbivoreMax: 100,
      predatorMax: 140,
      scavengerMax: 120,
      eatFoodGain: 18,
      eatHerbivoreGain: 55,
      // carrion mass is converted into energy via scavenger efficiency
      herbivoreDrain: 0.14,
      predatorDrain: 0.22,
      scavengerDrain: 0.18,
    },
    boids: {
      baseMaxSpeed: {
        herbivore: 70,
        predator: 92,
        scavenger: 78,
      },
      baseMaxForce: {
        herbivore: 150,
        predator: 190,
        scavenger: 165,
      },
      // perception radii are multiplied by gene.perception
      perception: {
        herbivore: 70,
        predator: 95,
        scavenger: 78,
      },
      // field-of-view (degrees, full cone)
      fov: {
        herbivore: 155,
        predator: 185,
        scavenger: 165,
      },
      separation: {
        herbivore: 22,
        predator: 26,
        scavenger: 22,
      },
      cohesion: {
        herbivore: 0.5,
        predator: 0.35,
        scavenger: 0.45,
      },
      alignment: {
        herbivore: 0.65,
        predator: 0.4,
        scavenger: 0.55,
      },
      wander: {
        herbivore: 0.18,
        predator: 0.08,
        scavenger: 0.14,
      },
      flee: {
        herbivore: 1.2,
        predator: 0,
        scavenger: 0.65,
      },
      chase: {
        herbivore: 0,
        predator: 1.35,
        scavenger: 0,
      },
      forage: {
        herbivore: 1.15,
        predator: 0,
        scavenger: 0,
      },
      scavenge: {
        herbivore: 0,
        predator: 0,
        scavenger: 1.2,
      },
    },
    world: {
      foodMax: 260,
      carrionMax: 220,
      foodSpawnRate: 0.75, // per second
      carrionDecaySeconds: 18,
    },
    life: {
      maturitySeconds: 12,
      juvenileScale: 0.55,
    },
    reproduction: {
      rate: 0.15,
      matingRadius: 26,
      maturity: 0.95,
      herbivoreThreshold: 80,
      predatorThreshold: 120,
      scavengerThreshold: 100,
    },
    decomposition: {
      yield: 2,
    },
    genetics: {
      mutationRate: 0.1,
      min: 0.8,
      max: 1.2,
      mutationAmount: 0.1, // ±5% since (rand-0.5)*0.1
      budgetBoost: 0.35,
    },
    walls: {
      top: false,
      right: false,
      bottom: false,
      left: false,
    },
    visuals: {
      trails: true,
      fov: true,
      vectors: false,
      perception: false,
      grid: false,
    },
    simSpeed: 1,
  }

  const els = {
    canvas: document.getElementById('canvas') as HTMLCanvasElement,
    fps: document.getElementById('fps') as HTMLSpanElement,
    herm: document.getElementById('statHerb') as HTMLSpanElement,
    pred: document.getElementById('statPred') as HTMLSpanElement,
    scav: document.getElementById('statScav') as HTMLSpanElement,
    food: document.getElementById('statFood') as HTMLSpanElement,
    carrion: document.getElementById('statCarrion') as HTMLSpanElement,
    births: document.getElementById('statBirths') as HTMLSpanElement,
    deaths: document.getElementById('statDeaths') as HTMLSpanElement,
    hunts: document.getElementById('statHunts') as HTMLSpanElement,
    decomp: document.getElementById('statDecomp') as HTMLSpanElement,

    perfBanner: document.getElementById('perfBanner') as HTMLDivElement,
    perfText: document.getElementById('perfText') as HTMLDivElement,
    btnReduce: document.getElementById('btnReduce') as HTMLButtonElement,
    btnDisableTrails: document.getElementById('btnDisableTrails') as HTMLButtonElement,
    btnDismiss: document.getElementById('btnDismiss') as HTMLButtonElement,

    btnHerb: document.getElementById('btnHerb') as HTMLButtonElement,
    btnPred: document.getElementById('btnPred') as HTMLButtonElement,
    btnScav: document.getElementById('btnScav') as HTMLButtonElement,
    btnMenu: document.getElementById('btnMenu') as HTMLButtonElement,
    panel: document.getElementById('panel') as HTMLDivElement,
    btnClose: document.getElementById('btnClose') as HTMLButtonElement,

    tabPresets: document.getElementById('tab-presets') as HTMLDivElement,
    tabVisuals: document.getElementById('tab-visuals') as HTMLDivElement,
    tabSettings: document.getElementById('tab-settings') as HTMLDivElement,
    tabAbout: document.getElementById('tab-about') as HTMLDivElement,

    presetBalanced: document.getElementById('presetBalanced') as HTMLButtonElement,
    presetGenesis: document.getElementById('presetGenesis') as HTMLButtonElement,
    presetPredator: document.getElementById('presetPredator') as HTMLButtonElement,
    presetExtinction: document.getElementById('presetExtinction') as HTMLButtonElement,
    presetEvolutionLab: document.getElementById('presetEvolutionLab') as HTMLButtonElement,

    seedInput: document.getElementById('seedInput') as HTMLInputElement,
    seedNote: document.getElementById('seedNote') as HTMLDivElement,
    btnRandomSeed: document.getElementById('btnRandomSeed') as HTMLButtonElement,
    btnApplySeed: document.getElementById('btnApplySeed') as HTMLButtonElement,

    togTrails: document.getElementById('togTrails') as HTMLInputElement,
    togFov: document.getElementById('togFov') as HTMLInputElement,
    togVectors: document.getElementById('togVectors') as HTMLInputElement,
    togPerception: document.getElementById('togPerception') as HTMLInputElement,
    togGrid: document.getElementById('togGrid') as HTMLInputElement,

    reproRate: document.getElementById('reproRate') as HTMLInputElement,
    reproRateValue: document.getElementById('reproRateValue') as HTMLSpanElement,
    decompYield: document.getElementById('decompYield') as HTMLInputElement,
    decompYieldValue: document.getElementById('decompYieldValue') as HTMLSpanElement,
    mutationRate: document.getElementById('mutationRate') as HTMLInputElement,
    mutationRateValue: document.getElementById('mutationRateValue') as HTMLSpanElement,
    simSpeed: document.getElementById('simSpeed') as HTMLInputElement,
    simSpeedValue: document.getElementById('simSpeedValue') as HTMLSpanElement,

    btnPause: document.getElementById('btnPause') as HTMLButtonElement,
    btnClear: document.getElementById('btnClear') as HTMLButtonElement,

    wallTop: document.getElementById('wallTop') as HTMLInputElement,
    wallRight: document.getElementById('wallRight') as HTMLInputElement,
    wallBottom: document.getElementById('wallBottom') as HTMLInputElement,
    wallLeft: document.getElementById('wallLeft') as HTMLInputElement,
  }

  const ctx = els.canvas.getContext('2d')!

  let simW = 0
  let simH = 0

  // HiDPI canvas sizing
  function resizeCanvas() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1))
    const rect = els.canvas.getBoundingClientRect()

    simW = rect.width
    simH = rect.height

    els.canvas.width = Math.floor(rect.width * dpr)
    els.canvas.height = Math.floor(rect.height * dpr)
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0)
  }

  resizeCanvas()
  window.addEventListener('resize', resizeCanvas)

  // --- Simulation state (placeholder; boids logic next) ---

   type Genes = { speed: number; perception: number; efficiency: number }

   type Sex = 'a' | 'b'


   type Boid = {
     id: number
     species: Species
     sex: Sex
     x: number
     y: number
     vx: number
     vy: number
     energy: number
     maxEnergy: number
     genes: Genes
     age: number
     dir: number
     cooldown: {
       eat: number
       reproduce: number
     }
     trail: { x: number; y: number }[]
   }


  type FoodSource = { x: number; y: number }
  type Carrion = { x: number; y: number; mass: number; age: number }
  type Particle = { x: number; y: number; vx: number; vy: number; life: number; color: string; size: number }

  let nextId = 1
  let boids: Boid[] = []
  let food: FoodSource[] = []
  let carrion: Carrion[] = []
  let particles: Particle[] = []

  let selectedSpecies: Species = 'herbivore'

  const counters = {
    births: 0,
    deaths: 0,
    hunts: 0,
    decomp: 0,
  }

  // --- Utilities ---

  function clamp(value: number, min: number, max: number): number {
    return Math.max(min, Math.min(max, value))
  }

  function lerp(a: number, b: number, t: number): number {
    return a + (b - a) * t
  }

  function rand(min: number, max: number): number {
    return min + Math.random() * (max - min)
  }

  type Vec = { x: number; y: number }

  function lenSq(v: Vec): number {
    return v.x * v.x + v.y * v.y
  }

  function len(v: Vec): number {
    return Math.sqrt(lenSq(v))
  }

  function distSq(ax: number, ay: number, bx: number, by: number): number {
    const dx = ax - bx
    const dy = ay - by
    return dx * dx + dy * dy
  }

  function clampLen(v: Vec, maxLen: number): Vec {
    const l = len(v)
    if (l <= maxLen || l === 0) return v
    const s = maxLen / l
    return { x: v.x * s, y: v.y * s }
  }

  function normalize(v: Vec): Vec {
    const l = len(v)
    if (l === 0) return { x: 0, y: 0 }
    return { x: v.x / l, y: v.y / l }
  }

  function heading(vx: number, vy: number): number {
    return Math.atan2(vy, vx)
  }

  function angleDelta(a: number, b: number): number {
    let d = a - b
    while (d > Math.PI) d -= Math.PI * 2
    while (d < -Math.PI) d += Math.PI * 2
    return d
  }

  function packCellKey(cx: number, cy: number): number {
    return ((cy & 0xffff) << 16) ^ (cx & 0xffff)
  }

  class SpatialGrid {
    cellSize: number
    map: Map<number, number[]>

    constructor(cellSize: number) {
      this.cellSize = cellSize
      this.map = new Map()
    }

    clear() {
      this.map.clear()
    }

    insert(x: number, y: number, index: number) {
      const cx = Math.floor(x / this.cellSize)
      const cy = Math.floor(y / this.cellSize)
      const key = packCellKey(cx, cy)
      const arr = this.map.get(key)
      if (arr) {
        arr.push(index)
      } else {
        this.map.set(key, [index])
      }
    }

    query(x: number, y: number, radius: number, out: number[]) {
      const c = this.cellSize
      const cx = Math.floor(x / c)
      const cy = Math.floor(y / c)
      const r = Math.ceil(radius / c)

      for (let oy = -r; oy <= r; oy++) {
        for (let ox = -r; ox <= r; ox++) {
          const key = packCellKey(cx + ox, cy + oy)
          const arr = this.map.get(key)
          if (!arr) continue
          for (const index of arr) out.push(index)
        }
      }
    }
  }

  const boidGrid = new SpatialGrid(80)
  const foodGrid = new SpatialGrid(70)
  const carrionGrid = new SpatialGrid(70)

  function seededRandom(seed: number) {
    // xorshift32
    let x = seed | 0
    if (x === 0) x = 123456789
    return {
      next() {
        x ^= x << 13
        x ^= x >>> 17
        x ^= x << 5
        return (x >>> 0) / 4294967296
      },
    }
  }

  function randomGenes(rng?: { next: () => number }): Genes {
    const r = rng ? rng.next.bind(rng) : Math.random
    // pseudo-normal-ish by averaging 2 uniforms
    const n = () => 1 + ((r() + r()) / 2 - 0.5) * 0.2
    return {
      speed: clamp(n(), opts.genetics.min, opts.genetics.max),
      perception: clamp(n(), opts.genetics.min, opts.genetics.max),
      efficiency: clamp(n(), opts.genetics.min, opts.genetics.max),
    }
  }

  function genesForEvolutionLab(rng: { next: () => number }): Genes {
    const r = rng.next
    const wideMin = 0.75
    const wideMax = 1.25
    return {
      speed: clamp(wideMin + r() * (wideMax - wideMin), opts.genetics.min, opts.genetics.max),
      perception: clamp(wideMin + r() * (wideMax - wideMin), opts.genetics.min, opts.genetics.max),
      efficiency: clamp(wideMin + r() * (wideMax - wideMin), opts.genetics.min, opts.genetics.max),
    }
  }

  function mutateGene(gene: number): number {
    if (Math.random() > opts.genetics.mutationRate) return gene
    const change = (Math.random() - 0.5) * opts.genetics.mutationAmount
    return clamp(gene + change, opts.genetics.min, opts.genetics.max)
  }

   function mutateGenes(genes: Genes): Genes {
     return {
       speed: mutateGene(genes.speed),
       perception: mutateGene(genes.perception),
       efficiency: mutateGene(genes.efficiency),
     }
   }

   function mixGenes(a: Genes, b: Genes): Genes {
     // uniform crossover (per gene)
     return {
       speed: Math.random() < 0.5 ? a.speed : b.speed,
       perception: Math.random() < 0.5 ? a.perception : b.perception,
       efficiency: Math.random() < 0.5 ? a.efficiency : b.efficiency,
     }
   }

   function canMate(b: Boid): boolean {
     if (b.cooldown.reproduce > 0) return false
     if (maturityForBoid(b) < opts.reproduction.maturity) return false
     if (b.energy < reproductionThresholdForSpecies(b.species)) return false
     return true
   }

   function findMateIndex(i: number, b: Boid, boidsToRemove: Set<number>): number | null {
     neighborScratch.length = 0
     boidGrid.query(b.x, b.y, opts.reproduction.matingRadius, neighborScratch)

     let bestIndex = -1
     let bestD2 = Infinity

     for (const j of neighborScratch) {
       if (j === i) continue
       if (boidsToRemove.has(j)) continue
       const o = boids[j]
       if (!o) continue
       if (o.species !== b.species) continue
       if (o.sex === b.sex) continue
       if (!canMate(o)) continue

       const d2 = distSq(b.x, b.y, o.x, o.y)
       if (d2 > opts.reproduction.matingRadius * opts.reproduction.matingRadius) continue
       if (d2 < bestD2) {
         bestD2 = d2
         bestIndex = j
       }
     }

     return bestIndex >= 0 ? bestIndex : null
   }

   function spawnChildFromParents(a: Boid, b: Boid) {
     const maxEnergy = maxEnergyForSpecies(a.species)
     const totalCost = maxEnergy * 0.35
     const costEach = totalCost / 2
     if (a.energy <= costEach + 1) return
     if (b.energy <= costEach + 1) return

     a.energy -= costEach
     b.energy -= costEach

     const childGenes = mutateGenes(mixGenes(a.genes, b.genes))

     const midX = (a.x + b.x) / 2
     const midY = (a.y + b.y) / 2
     const jitterA = Math.random() * Math.PI * 2
     const jitterR = 8 + Math.random() * 10
     const x = clamp(midX + Math.cos(jitterA) * jitterR, 1, simW - 1)
     const y = clamp(midY + Math.sin(jitterA) * jitterR, 1, simH - 1)

     const vx = (a.vx + b.vx) / 2 + rand(-18, 18)
     const vy = (a.vy + b.vy) / 2 + rand(-18, 18)

     const childEnergy = Math.min(maxEnergy * 0.6, totalCost)

     boids.push({
       id: nextId++,
       species: a.species,
       sex: Math.random() < 0.5 ? 'a' : 'b',
       x,
       y,
       vx,
       vy,
       energy: childEnergy,
       maxEnergy,
       genes: childGenes,
       age: 0,
       dir: heading(vx, vy),
       cooldown: { eat: 0.2, reproduce: 0.8 },
       trail: [],
     })

     a.cooldown.reproduce = 1.4
     b.cooldown.reproduce = 1.4
     counters.births++
     addParticle(x, y, opts.colors[a.species])
   }


  function maxEnergyForSpecies(species: Species): number {
    switch (species) {
      case 'herbivore':
        return opts.energy.herbivoreMax
      case 'predator':
        return opts.energy.predatorMax
      case 'scavenger':
        return opts.energy.scavengerMax
    }
  }

  function reproductionThresholdForSpecies(species: Species): number {
    switch (species) {
      case 'herbivore':
        return opts.reproduction.herbivoreThreshold
      case 'predator':
        return opts.reproduction.predatorThreshold
      case 'scavenger':
        return opts.reproduction.scavengerThreshold
    }
  }

  function maturityForBoid(b: Boid): number {
    return clamp(b.age / Math.max(0.01, opts.life.maturitySeconds), 0, 1)
  }

  function growthScaleForBoid(b: Boid): number {
    const m = maturityForBoid(b)
    const ratio = clamp(b.energy / Math.max(1, b.maxEnergy), 0, 1)
    const size = lerp(opts.life.juvenileScale, 1, m)
    const energyScale = lerp(0.85, 1, ratio)
    return size * energyScale
  }

  function mobilityScaleForBoid(b: Boid): number {
    return lerp(0.7, 1, maturityForBoid(b))
  }

  function shouldReproduce(b: Boid): boolean {
    if (b.cooldown.reproduce > 0) return false
    if (maturityForBoid(b) < opts.reproduction.maturity) return false
    if (b.energy < reproductionThresholdForSpecies(b.species)) return false

    // species with efficient genes reproduce slightly more
    const p = opts.reproduction.rate * (0.85 + 0.3 * b.genes.efficiency)
    return Math.random() < p
  }

  function spawnChildFromParent(parent: Boid) {
    const childGenes = mutateGenes(parent.genes)

    const a = Math.random() * Math.PI * 2
    const r = 10 + Math.random() * 16
    const x = clamp(parent.x + Math.cos(a) * r, 1, simW - 1)
    const y = clamp(parent.y + Math.sin(a) * r, 1, simH - 1)

    const maxEnergy = maxEnergyForSpecies(parent.species)
    const energyCost = maxEnergy * 0.35
    if (parent.energy <= energyCost + 1) return

    parent.energy -= energyCost

    const childEnergy = Math.min(maxEnergy * 0.6, energyCost)

    const vx = parent.vx + rand(-20, 20)
    const vy = parent.vy + rand(-20, 20)

    boids.push({
      id: nextId++,
      species: parent.species,
      sex: Math.random() < 0.5 ? 'a' : 'b',
      x,
      y,
      vx,
      vy,
      energy: childEnergy,
      maxEnergy,
      genes: childGenes,
      age: 0,
      dir: heading(vx, vy),
      cooldown: { eat: 0.2, reproduce: 0.8 },
      trail: [],
    })

    parent.cooldown.reproduce = 1.4
    counters.births++
    addParticle(x, y, opts.colors[parent.species])
  }

  function spawnBoid(species: Species, x: number, y: number, genes?: Genes) {
    const maxEnergy = maxEnergyForSpecies(species)
    const g = genes ?? randomGenes()
    const vx = rand(-1, 1)
    const vy = rand(-1, 1)
    boids.push({
      id: nextId++,
      species,
      sex: Math.random() < 0.5 ? 'a' : 'b',
      x,
      y,
      vx,
      vy,
      energy: maxEnergy,
      maxEnergy,
      genes: g,
      age: 0,
      dir: heading(vx, vy),
      cooldown: { eat: 0, reproduce: 0 },
      trail: [],
    })
  }

  function spawnFood(x: number, y: number) {
    food.push({ x, y })
  }

  function clearAll() {
    boids = []
    food = []
    carrion = []
    particles = []
    counters.births = 0
    counters.deaths = 0
    counters.hunts = 0
    counters.decomp = 0
  }

  // --- Rendering helpers (placeholder) ---

  function drawBackground() {
    if (opts.visuals.trails) {
      ctx.fillStyle = 'rgba(10, 10, 10, 0.14)'
      ctx.fillRect(0, 0, simW, simH)
      return
    }

    ctx.fillStyle = opts.colors.background
    ctx.fillRect(0, 0, simW, simH)
  }

  function draw() {
    drawBackground()

    // Food
    for (const f of food) {
      ctx.save()
      ctx.globalAlpha = 0.55
      ctx.fillStyle = opts.colors.herbivore
      ctx.shadowColor = opts.colors.herbivore
      ctx.shadowBlur = 10
      ctx.beginPath()
      ctx.arc(f.x, f.y, 2.6, 0, Math.PI * 2)
      ctx.fill()
      ctx.restore()
    }

     // Carrion
     for (const c of carrion) {
       const alpha = clamp(0.2 + (1 - c.age / opts.world.carrionDecaySeconds) * 0.8, 0, 1)
       ctx.save()
       ctx.globalAlpha = alpha
       ctx.strokeStyle = opts.colors.carrion
       ctx.shadowColor = opts.colors.carrion
       ctx.shadowBlur = 10
       ctx.lineWidth = 1
       ctx.beginPath()
       ctx.arc(c.x, c.y, 4 + c.mass * 3.2, 0, Math.PI * 2)
       ctx.stroke()
       ctx.restore()
     }

     // Spawn cluster charge indicator
     if (clusterTimer && pressPoint) {
       const color = opts.colors[selectedSpecies]
       const progress = clamp(clusterProgress, 0, 1)
       const baseR = 14
       const r = baseR + 18 * progress

       ctx.save()
       ctx.globalAlpha = 0.85
       ctx.strokeStyle = color
       ctx.shadowColor = color
       ctx.shadowBlur = 16
       ctx.lineWidth = 1.5

       ctx.beginPath()
       ctx.arc(pressPoint.x, pressPoint.y, r, 0, Math.PI * 2)
       ctx.stroke()

       ctx.globalAlpha = 0.95
       ctx.lineWidth = 2
       ctx.beginPath()
       ctx.arc(pressPoint.x, pressPoint.y, r, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2)
       ctx.stroke()

       ctx.globalAlpha = 0.9
       ctx.fillStyle = color
       ctx.font = '12px var(--font-mono)'
       ctx.textAlign = 'center'
       ctx.textBaseline = 'middle'
       ctx.fillText(String(clusterCount), pressPoint.x, pressPoint.y)

       ctx.restore()
     }


    function drawBoidArrow(b: Boid) {
      const baseSize = b.species === 'predator' ? 12 : b.species === 'scavenger' ? 10 : 9
      const ratio = clamp(b.energy / Math.max(1, b.maxEnergy), 0, 1)
      const alpha = 0.16 + ratio * 0.84

      const angle = b.dir
      const size = baseSize * (0.9 + 0.3 * b.genes.speed) * growthScaleForBoid(b)

      const color = b.species === 'predator' ? opts.colors.predator : b.species === 'scavenger' ? opts.colors.scavenger : opts.colors.herbivore

      // Flatland-ish silhouettes:
      // - predator: needle isosceles (brute soldiers)
      // - herbivore: balanced
      // - scavenger: wide/flat
      const backFactor = b.species === 'predator' ? 0.92 : b.species === 'scavenger' ? 0.62 : 0.75
      const wingFactor = b.species === 'predator' ? 0.28 : b.species === 'scavenger' ? 0.84 : 0.55

      // Arrowhead triangle (outline only)
      const tipX = b.x + Math.cos(angle) * size
      const tipY = b.y + Math.sin(angle) * size
      const backX = b.x - Math.cos(angle) * size * backFactor
      const backY = b.y - Math.sin(angle) * size * backFactor

      const wingAngle = angle + Math.PI / 2
      const wing = size * wingFactor
      const leftX = backX + Math.cos(wingAngle) * wing
      const leftY = backY + Math.sin(wingAngle) * wing
      const rightX = backX - Math.cos(wingAngle) * wing
      const rightY = backY - Math.sin(wingAngle) * wing

      if (opts.visuals.trails && b.trail.length > 2) {
        ctx.save()
        ctx.globalAlpha = alpha * 0.25
        ctx.strokeStyle = color
        ctx.shadowColor = color
        ctx.shadowBlur = 10
        ctx.lineWidth = 1
        ctx.beginPath()
        ctx.moveTo(b.trail[0].x, b.trail[0].y)
        for (let i = 1; i < b.trail.length; i++) ctx.lineTo(b.trail[i].x, b.trail[i].y)
        ctx.stroke()
        ctx.restore()
      }

      ctx.save()
      ctx.globalAlpha = alpha
      ctx.lineWidth = b.species === 'predator' ? 1.5 : 1.25
      ctx.strokeStyle = color
      ctx.shadowColor = color
      ctx.shadowBlur = 14

      ctx.beginPath()
      ctx.moveTo(tipX, tipY)
      ctx.lineTo(leftX, leftY)
      ctx.lineTo(rightX, rightY)
      ctx.closePath()
      ctx.stroke()
      ctx.restore()

      if (opts.visuals.vectors) {
        ctx.save()
        ctx.globalAlpha = 0.5
        ctx.strokeStyle = color
        ctx.lineWidth = 1
        ctx.beginPath()
        ctx.moveTo(b.x, b.y)
        ctx.lineTo(b.x + b.vx * 0.14, b.y + b.vy * 0.14)
        ctx.stroke()
        ctx.restore()
      }

      if (opts.visuals.perception) {
        const pr = perceptionForBoid(b)
        ctx.save()
        ctx.globalAlpha = 0.08
        ctx.strokeStyle = color
        ctx.lineWidth = 1
        ctx.beginPath()
        ctx.arc(b.x, b.y, pr, 0, Math.PI * 2)
        ctx.stroke()
        ctx.restore()
      }

      if (opts.visuals.fov) {
        const pr = perceptionForBoid(b)
        const half = fovForBoid(b)
        ctx.save()
        ctx.globalAlpha = 0.08
        ctx.strokeStyle = color
        ctx.lineWidth = 1
        ctx.beginPath()
        ctx.moveTo(b.x, b.y)
        ctx.arc(b.x, b.y, pr, b.dir - half, b.dir + half)
        ctx.closePath()
        ctx.stroke()
        ctx.restore()
      }
    }

    // Boids
    for (const b of boids) {
      drawBoidArrow(b)
    }

    // Particles
    for (const p of particles) {
      const a = clamp(p.life / 0.7, 0, 1)
      ctx.save()
      ctx.globalAlpha = a
      ctx.fillStyle = p.color
      ctx.shadowColor = p.color
      ctx.shadowBlur = 10
      ctx.beginPath()
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2)
      ctx.fill()
      ctx.restore()
    }

    if (opts.visuals.grid) {
      ctx.save()
      ctx.globalAlpha = 0.06
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)'
      ctx.lineWidth = 1
      const cellSize = boidGrid.cellSize
      for (let x = 0; x < simW; x += cellSize) {
        ctx.beginPath()
        ctx.moveTo(x, 0)
        ctx.lineTo(x, simH)
        ctx.stroke()
      }
      for (let y = 0; y < simH; y += cellSize) {
        ctx.beginPath()
        ctx.moveTo(0, y)
        ctx.lineTo(simW, y)
        ctx.stroke()
      }
      ctx.restore()
    }
  }

  // --- UI wiring ---

  function setSelectedSpecies(species: Species) {
    selectedSpecies = species
    els.btnHerb.classList.toggle('selected', species === 'herbivore')
    els.btnPred.classList.toggle('selected', species === 'predator')
    els.btnScav.classList.toggle('selected', species === 'scavenger')
  }

  els.btnHerb.addEventListener('click', () => setSelectedSpecies('herbivore'))
  els.btnPred.addEventListener('click', () => setSelectedSpecies('predator'))
  els.btnScav.addEventListener('click', () => setSelectedSpecies('scavenger'))

  function openPanel() {
    els.panel.hidden = false
  }

  function closePanel() {
    els.panel.hidden = true
  }

  els.btnMenu.addEventListener('click', openPanel)
  els.btnClose.addEventListener('click', closePanel)

  const tabs = Array.from(document.querySelectorAll('.tab')) as HTMLButtonElement[]
  function selectTab(name: string) {
    const map: Record<string, HTMLDivElement> = {
      presets: els.tabPresets,
      visuals: els.tabVisuals,
      settings: els.tabSettings,
      about: els.tabAbout,
    }
    for (const tab of tabs) tab.classList.toggle('selected', tab.dataset.tab === name)
    for (const [k, el] of Object.entries(map)) el.hidden = k !== name
  }

  for (const tab of tabs) {
    tab.addEventListener('click', () => {
      const name = tab.dataset.tab
      if (name) selectTab(name)
    })
  }

  // Settings
  function syncSettingsLabels() {
    els.reproRateValue.textContent = opts.reproduction.rate.toFixed(2)
    els.decompYieldValue.textContent = String(opts.decomposition.yield)
    els.mutationRateValue.textContent = opts.genetics.mutationRate.toFixed(2)
    els.simSpeedValue.textContent = `${opts.simSpeed.toFixed(1)}x`
  }

  els.reproRate.addEventListener('input', () => {
    opts.reproduction.rate = parseFloat(els.reproRate.value)
    syncSettingsLabels()
  })

  els.decompYield.addEventListener('input', () => {
    opts.decomposition.yield = parseInt(els.decompYield.value, 10)
    syncSettingsLabels()
  })

  els.mutationRate.addEventListener('input', () => {
    opts.genetics.mutationRate = parseFloat(els.mutationRate.value)
    syncSettingsLabels()
  })

  els.simSpeed.addEventListener('input', () => {
    opts.simSpeed = parseFloat(els.simSpeed.value)
    syncSettingsLabels()
  })

  els.togTrails.addEventListener('change', () => (opts.visuals.trails = els.togTrails.checked))
  els.togFov.addEventListener('change', () => (opts.visuals.fov = els.togFov.checked))
  els.togVectors.addEventListener('change', () => (opts.visuals.vectors = els.togVectors.checked))
  els.togPerception.addEventListener('change', () => (opts.visuals.perception = els.togPerception.checked))
  els.togGrid.addEventListener('change', () => (opts.visuals.grid = els.togGrid.checked))

  els.wallTop.addEventListener('change', () => (opts.walls.top = els.wallTop.checked))
  els.wallRight.addEventListener('change', () => (opts.walls.right = els.wallRight.checked))
  els.wallBottom.addEventListener('change', () => (opts.walls.bottom = els.wallBottom.checked))
  els.wallLeft.addEventListener('change', () => (opts.walls.left = els.wallLeft.checked))

  let paused = false
  els.btnPause.addEventListener('click', () => {
    paused = !paused
    els.btnPause.textContent = paused ? 'Play' : 'Pause'
  })

  els.btnClear.addEventListener('click', () => {
    clearAll()
    applyPresetBalancedFromSeed(undefined)
  })

  // Presets
  function applyPresetBalancedFromSeed(seed?: number) {
    clearAll()

    const rng = seed != null ? seededRandom(seed) : undefined

    // 30 herbivores, 5 predators, 8 scavengers, 15 food
    for (let i = 0; i < 15; i++) spawnFood(rand(20, simW - 20), rand(20, simH - 20))

    for (let i = 0; i < 30; i++) spawnBoid('herbivore', rand(0, simW), rand(0, simH), rng ? randomGenes(rng) : undefined)
    for (let i = 0; i < 5; i++) spawnBoid('predator', rand(0, simW), rand(0, simH), rng ? randomGenes(rng) : undefined)
    for (let i = 0; i < 8; i++) spawnBoid('scavenger', rand(0, simW), rand(0, simH), rng ? randomGenes(rng) : undefined)

    const note = seed != null ? `Seed: ${seed}` : ''
    els.seedNote.textContent = note
  }

  function applyPresetGenesis() {
    clearAll()
    for (let i = 0; i < 5; i++) spawnFood(rand(20, simW - 20), rand(20, simH - 20))

    els.seedNote.textContent = ''
  }

  function applyPresetPredatorParadise() {
    clearAll()
    for (let i = 0; i < 30; i++) spawnFood(rand(20, simW - 20), rand(20, simH - 20))
    for (let i = 0; i < 100; i++) spawnBoid('herbivore', rand(0, simW), rand(0, simH))
    for (let i = 0; i < 3; i++) spawnBoid('predator', rand(0, simW), rand(0, simH))
    for (let i = 0; i < 15; i++) spawnBoid('scavenger', rand(0, simW), rand(0, simH))

    els.seedNote.textContent = ''
  }

  function applyPresetExtinctionEvent() {
    clearAll()
    for (let i = 0; i < 10; i++) spawnFood(rand(20, simW - 20), rand(20, simH - 20))
    for (let i = 0; i < 30; i++) spawnBoid('herbivore', rand(0, simW), rand(0, simH))
    for (let i = 0; i < 20; i++) spawnBoid('predator', rand(0, simW), rand(0, simH))
    for (let i = 0; i < 5; i++) spawnBoid('scavenger', rand(0, simW), rand(0, simH))

    els.seedNote.textContent = ''
  }

  function applyPresetEvolutionLab() {
    clearAll()
    const rng = seededRandom(Math.floor(Math.random() * 1000000))

    for (let i = 0; i < 25; i++) spawnFood(rand(20, simW - 20), rand(20, simH - 20))

    // Wide variance + 2x mutation rate
    opts.genetics.mutationRate = clamp(opts.genetics.mutationRate * 2, 0.05, 0.25)
    els.mutationRate.value = String(opts.genetics.mutationRate)

    for (let i = 0; i < 50; i++) spawnBoid('herbivore', rand(0, simW), rand(0, simH), genesForEvolutionLab(rng))
    for (let i = 0; i < 10; i++) spawnBoid('predator', rand(0, simW), rand(0, simH), genesForEvolutionLab(rng))
    for (let i = 0; i < 15; i++) spawnBoid('scavenger', rand(0, simW), rand(0, simH), genesForEvolutionLab(rng))

    syncSettingsLabels()
    els.seedNote.textContent = 'Evolution Lab: wide genes + higher mutation'
  }

  els.presetBalanced.addEventListener('click', () => applyPresetBalancedFromSeed(undefined))
  els.presetGenesis.addEventListener('click', applyPresetGenesis)
  els.presetPredator.addEventListener('click', applyPresetPredatorParadise)
  els.presetExtinction.addEventListener('click', applyPresetExtinctionEvent)
  els.presetEvolutionLab.addEventListener('click', applyPresetEvolutionLab)

  els.btnRandomSeed.addEventListener('click', () => {
    els.seedInput.value = String(Math.floor(Math.random() * 1000000))
  })

  els.btnApplySeed.addEventListener('click', () => {
    const seed = parseInt(els.seedInput.value, 10)
    if (Number.isFinite(seed)) applyPresetBalancedFromSeed(seed)
  })

  // Performance banner actions (stub)
  els.btnReduce.addEventListener('click', () => {
    boids = boids.filter((_, i) => i % 2 === 0)
    els.perfBanner.hidden = true
  })

  els.btnDisableTrails.addEventListener('click', () => {
    opts.visuals.trails = false
    els.togTrails.checked = false
    els.perfBanner.hidden = true
  })

  els.btnDismiss.addEventListener('click', () => {
    els.perfBanner.hidden = true
  })

  // Pointer interactions: tap and long-press cluster
   let pressTimer: number | null = null
   let clusterTimer: number | null = null
   let pressPoint: { x: number; y: number } | null = null
   let clusterCount = 0
   let clusterProgress = 0


  function getCanvasPoint(e: PointerEvent): { x: number; y: number } {
    const rect = els.canvas.getBoundingClientRect()
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top,
    }
  }

   function startCluster(point: { x: number; y: number }) {
     clusterCount = 1
     clusterProgress = 0
     clusterTimer = window.setInterval(() => {
       clusterCount = Math.min(20, clusterCount + 1)
       clusterProgress = clusterCount / 20
     }, 100)
   }


   function flushCluster(point: { x: number; y: number }) {
     const n = clusterCount
     for (let i = 0; i < n; i++) {
       const a = Math.random() * Math.PI * 2
       const r = Math.random() * 12
       spawnBoid(selectedSpecies, point.x + Math.cos(a) * r, point.y + Math.sin(a) * r)
     }
     clusterProgress = 0
   }


  els.canvas.addEventListener('pointerdown', (e) => {
    els.canvas.setPointerCapture(e.pointerId)
    pressPoint = getCanvasPoint(e)

    // Tap spawns immediately; hold accumulates additional ones.
    spawnBoid(selectedSpecies, pressPoint.x, pressPoint.y)

    pressTimer = window.setTimeout(() => {
      if (!pressPoint) return
      startCluster(pressPoint)
    }, 250)
  })

   els.canvas.addEventListener('pointerup', () => {
     if (pressTimer) window.clearTimeout(pressTimer)
     pressTimer = null

     if (clusterTimer) window.clearInterval(clusterTimer)

     if (clusterTimer && pressPoint) {
       flushCluster(pressPoint)
     }

     clusterTimer = null
     clusterProgress = 0
     pressPoint = null
   })


   els.canvas.addEventListener('pointercancel', () => {
     if (pressTimer) window.clearTimeout(pressTimer)
     if (clusterTimer) window.clearInterval(clusterTimer)
     pressTimer = null
     clusterTimer = null
     clusterProgress = 0
     pressPoint = null
   })


  // --- Main loop ---

  let lastT = performance.now()
  let fpsSmoothed = 60
  let lowFpsStart: number | null = null

  const neighborScratch: number[] = []

  function maxSpeedForBoid(b: Boid): number {
    return opts.boids.baseMaxSpeed[b.species] * b.genes.speed * mobilityScaleForBoid(b)
  }

  function maxForceForBoid(b: Boid): number {
    return opts.boids.baseMaxForce[b.species] * (0.8 + 0.4 * b.genes.speed) * mobilityScaleForBoid(b)
  }

  function perceptionForBoid(b: Boid): number {
    return opts.boids.perception[b.species] * b.genes.perception
  }

  function fovForBoid(b: Boid): number {
    return (opts.boids.fov[b.species] * Math.PI) / 180 / 2
  }

  function separationRadiusForBoid(b: Boid): number {
    return opts.boids.separation[b.species]
  }

  function drainPerSecondForBoid(b: Boid): number {
    const base = b.species === 'predator' ? opts.energy.predatorDrain : b.species === 'scavenger' ? opts.energy.scavengerDrain : opts.energy.herbivoreDrain
    // efficiency stretches energy (lower drain)
    return base / b.genes.efficiency
  }

  function applyBounds(b: Boid) {
    const pad = 1

    if (opts.walls.left) {
      if (b.x < pad) {
        b.x = pad
        b.vx = Math.abs(b.vx)
      }
    } else if (b.x < 0) {
      b.x += simW
    }

    if (opts.walls.right) {
      if (b.x > simW - pad) {
        b.x = simW - pad
        b.vx = -Math.abs(b.vx)
      }
    } else if (b.x > simW) {
      b.x -= simW
    }

    if (opts.walls.top) {
      if (b.y < pad) {
        b.y = pad
        b.vy = Math.abs(b.vy)
      }
    } else if (b.y < 0) {
      b.y += simH
    }

    if (opts.walls.bottom) {
      if (b.y > simH - pad) {
        b.y = simH - pad
        b.vy = -Math.abs(b.vy)
      }
    } else if (b.y > simH) {
      b.y -= simH
    }
  }

  function inFov(b: Boid, dx: number, dy: number): boolean {
    const ang = Math.atan2(dy, dx)
    const d = Math.abs(angleDelta(ang, b.dir))
    return d <= fovForBoid(b)
  }

  function steerToward(b: Boid, tx: number, ty: number, weight: number): Vec {
    const dx = tx - b.x
    const dy = ty - b.y
    if (dx === 0 && dy === 0) return { x: 0, y: 0 }

    const desired = normalize({ x: dx, y: dy })
    const desiredV = { x: desired.x * maxSpeedForBoid(b), y: desired.y * maxSpeedForBoid(b) }
    const steer = { x: desiredV.x - b.vx, y: desiredV.y - b.vy }
    const limited = clampLen(steer, maxForceForBoid(b))
    return { x: limited.x * weight, y: limited.y * weight }
  }

  function steerAway(b: Boid, fx: number, fy: number, weight: number): Vec {
    const dx = b.x - fx
    const dy = b.y - fy
    if (dx === 0 && dy === 0) return { x: 0, y: 0 }
    const desired = normalize({ x: dx, y: dy })
    const desiredV = { x: desired.x * maxSpeedForBoid(b), y: desired.y * maxSpeedForBoid(b) }
    const steer = { x: desiredV.x - b.vx, y: desiredV.y - b.vy }
    const limited = clampLen(steer, maxForceForBoid(b))
    return { x: limited.x * weight, y: limited.y * weight }
  }

  function addParticle(x: number, y: number, color: string) {
    const count = 6
    for (let i = 0; i < count; i++) {
      const a = Math.random() * Math.PI * 2
      const s = 40 + Math.random() * 80
      particles.push({ x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s, life: 0.35 + Math.random() * 0.35, color, size: 1.2 + Math.random() * 1.8 })
    }
  }

  function updateParticles(dtSeconds: number) {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i]
      p.life -= dtSeconds
      if (p.life <= 0) {
        particles.splice(i, 1)
        continue
      }
      p.x += p.vx * dtSeconds
      p.y += p.vy * dtSeconds
      p.vx *= 0.92
      p.vy *= 0.92
    }
  }

  function removeIndicesInPlace<T>(arr: T[], toRemove: Set<number>) {
    if (toRemove.size === 0) return

    let w = 0
    for (let i = 0; i < arr.length; i++) {
      if (toRemove.has(i)) continue
      arr[w] = arr[i]
      w++
    }
    arr.length = w
  }

  function update(dtSeconds: number) {
    // rebuild grids (indices must remain stable within this tick)
    boidGrid.clear()
    foodGrid.clear()
    carrionGrid.clear()

    for (let i = 0; i < boids.length; i++) boidGrid.insert(boids[i].x, boids[i].y, i)
    for (let i = 0; i < food.length; i++) foodGrid.insert(food[i].x, food[i].y, i)
    for (let i = 0; i < carrion.length; i++) carrionGrid.insert(carrion[i].x, carrion[i].y, i)

    const boidsToRemove = new Set<number>()
    const foodToRemove = new Set<number>()
    const carrionToRemove = new Set<number>()

    // food growth
    const expectedFood = opts.world.foodSpawnRate * dtSeconds
    if (Math.random() < expectedFood) {
      spawnFood(rand(20, simW - 20), rand(20, simH - 20))
    }

    // carrion decay -> food (decomposition)
    for (let i = 0; i < carrion.length; i++) {
      if (carrionToRemove.has(i)) continue
      const c = carrion[i]
      if (!c) continue

      c.age += dtSeconds
      if (c.age > opts.world.carrionDecaySeconds) {
        carrionToRemove.add(i)
        for (let k = 0; k < opts.decomposition.yield; k++) {
          const a = Math.random() * Math.PI * 2
          const r = 6 + Math.random() * 14
          spawnFood(clamp(c.x + Math.cos(a) * r, 4, simW - 4), clamp(c.y + Math.sin(a) * r, 4, simH - 4))
        }
        counters.decomp++
      }
    }

    // boids step
    for (let i = 0; i < boids.length; i++) {
      if (boidsToRemove.has(i)) continue
      const b = boids[i]
      if (!b) continue

      b.age += dtSeconds
      b.cooldown.eat = Math.max(0, b.cooldown.eat - dtSeconds)
      b.cooldown.reproduce = Math.max(0, b.cooldown.reproduce - dtSeconds)

      // eating interactions (simple)
      if (b.cooldown.eat <= 0) {
        if (b.species === 'herbivore') {
          neighborScratch.length = 0
          foodGrid.query(b.x, b.y, 14, neighborScratch)
          let eatIndex = -1
          let eatD2 = Infinity
          for (const fi of neighborScratch) {
            if (foodToRemove.has(fi)) continue
            const f = food[fi]
            if (!f) continue
            const d2 = distSq(b.x, b.y, f.x, f.y)
            if (d2 < eatD2) {
              eatD2 = d2
              eatIndex = fi
            }
          }
          if (eatIndex >= 0 && eatD2 < 12 * 12) {
            const f = food[eatIndex]
            if (f) {
              foodToRemove.add(eatIndex)
              b.energy = clamp(b.energy + opts.energy.eatFoodGain * b.genes.efficiency, 0, b.maxEnergy)
              b.cooldown.eat = 0.25
              addParticle(f.x, f.y, opts.colors.herbivore)
            }
          }
        } else if (b.species === 'predator') {
          neighborScratch.length = 0
          boidGrid.query(b.x, b.y, 18, neighborScratch)
          let killIndex = -1
          let killD2 = Infinity
          for (const bi of neighborScratch) {
            if (bi === i) continue
            if (boidsToRemove.has(bi)) continue
            const o = boids[bi]
            if (!o || o.species !== 'herbivore') continue
            const d2 = distSq(b.x, b.y, o.x, o.y)
            if (d2 < killD2) {
              killD2 = d2
              killIndex = bi
            }
          }
          if (killIndex >= 0 && killD2 < 14 * 14) {
            const prey = boids[killIndex]
            if (prey && !boidsToRemove.has(killIndex)) {
              boidsToRemove.add(killIndex)
              counters.hunts++
              counters.deaths++
              carrion.push({ x: prey.x, y: prey.y, mass: 1.1, age: 0 })
              b.energy = clamp(b.energy + opts.energy.eatHerbivoreGain * b.genes.efficiency, 0, b.maxEnergy)
              b.cooldown.eat = 0.35
              addParticle(prey.x, prey.y, opts.colors.predator)
            }
          }
        } else if (b.species === 'scavenger') {
          neighborScratch.length = 0
          carrionGrid.query(b.x, b.y, 18, neighborScratch)
          let eatIndex = -1
          let eatD2 = Infinity
          for (const ci of neighborScratch) {
            if (carrionToRemove.has(ci)) continue
            const c = carrion[ci]
            if (!c) continue
            const d2 = distSq(b.x, b.y, c.x, c.y)
            if (d2 < eatD2) {
              eatD2 = d2
              eatIndex = ci
            }
          }
          if (eatIndex >= 0 && eatD2 < 14 * 14) {
            const c = carrion[eatIndex]
            if (c && !carrionToRemove.has(eatIndex)) {
              const take = Math.min(c.mass, 0.45)
              c.mass -= take
              b.energy = clamp(b.energy + take * 34 * b.genes.efficiency, 0, b.maxEnergy)
              b.cooldown.eat = 0.3
              addParticle(c.x, c.y, opts.colors.scavenger)
              if (c.mass <= 0.06) {
                carrionToRemove.add(eatIndex)
                for (let k = 0; k < opts.decomposition.yield; k++) {
                  const a = Math.random() * Math.PI * 2
                  const r = 6 + Math.random() * 14
                  spawnFood(clamp(c.x + Math.cos(a) * r, 4, simW - 4), clamp(c.y + Math.sin(a) * r, 4, simH - 4))
                }
                counters.decomp++
              }
            }
          }
        }
      }

      // reproduction
      if (shouldReproduce(b)) {
        const mateIndex = findMateIndex(i, b, boidsToRemove)
        if (mateIndex != null) {
          const mate = boids[mateIndex]
          if (mate) {
            // Only create one child per pair per tick
            if (i < mateIndex) {
              spawnChildFromParents(b, mate)
            }
          }
        } else {
          spawnChildFromParent(b)
        }
      }

      // energy drain
      b.energy -= drainPerSecondForBoid(b) * dtSeconds * 60
      if (b.energy <= 0) {
        // death -> carrion
        counters.deaths++
        const mass = b.species === 'predator' ? 2.1 : b.species === 'scavenger' ? 1.4 : 1.1
        carrion.push({ x: b.x, y: b.y, mass, age: 0 })
        addParticle(b.x, b.y, opts.colors.dead)
        boidsToRemove.add(i)
        continue
      }

      // neighborhood
      neighborScratch.length = 0
      const pr = perceptionForBoid(b)
      boidGrid.query(b.x, b.y, pr, neighborScratch)

      const selfDir = b.dir
      let sepX = 0
      let sepY = 0
      let aliX = 0
      let aliY = 0
      let cohX = 0
      let cohY = 0
      let neighborCount = 0

      const sepR = separationRadiusForBoid(b)
      const sepRSq = sepR * sepR

      let fleeX = 0
      let fleeY = 0

      let chaseTargetX = 0
      let chaseTargetY = 0
      let chaseTargetD2 = Infinity
      let hasChase = false

      for (const j of neighborScratch) {
        if (j === i) continue
        if (boidsToRemove.has(j)) continue
        const o = boids[j]
        if (!o) continue

        const d2 = distSq(b.x, b.y, o.x, o.y)
        if (d2 > pr * pr) continue

        const dx = o.x - b.x
        const dy = o.y - b.y
        if (!inFov(b, dx, dy)) continue

        neighborCount++
        aliX += o.vx
        aliY += o.vy
        cohX += o.x
        cohY += o.y

        if (d2 < sepRSq) {
          const inv = 1 / Math.max(1e-6, d2)
          sepX -= dx * inv
          sepY -= dy * inv
        }

        if (b.species === 'herbivore' && o.species === 'predator') {
          const s = 1 / Math.max(1e-6, d2)
          fleeX -= dx * s
          fleeY -= dy * s
        }

        if (b.species === 'scavenger' && o.species === 'predator') {
          const s = 1 / Math.max(1e-6, d2)
          fleeX -= dx * s
          fleeY -= dy * s
        }

        if (b.species === 'predator' && o.species === 'herbivore') {
          // chase nearest herbivore
          if (d2 < chaseTargetD2) {
            chaseTargetD2 = d2
            chaseTargetX = o.x
            chaseTargetY = o.y
            hasChase = true
          }
        }
      }

      const steer: Vec = { x: 0, y: 0 }

      if (neighborCount > 0) {
        // alignment
        const ali = normalize({ x: aliX / neighborCount, y: aliY / neighborCount })
        steer.x += (ali.x * maxSpeedForBoid(b) - b.vx) * opts.boids.alignment[b.species]
        steer.y += (ali.y * maxSpeedForBoid(b) - b.vy) * opts.boids.alignment[b.species]

        // cohesion
        const center = { x: cohX / neighborCount, y: cohY / neighborCount }
        const coh = steerToward(b, center.x, center.y, opts.boids.cohesion[b.species])
        steer.x += coh.x
        steer.y += coh.y

        // separation
        const sep = normalize({ x: sepX, y: sepY })
        steer.x += sep.x * maxSpeedForBoid(b) * 0.55
        steer.y += sep.y * maxSpeedForBoid(b) * 0.55
      }

      // species-specific goals
      if (b.species === 'herbivore') {
        // forage toward nearest food
        neighborScratch.length = 0
        foodGrid.query(b.x, b.y, pr * 1.25, neighborScratch)
        let bestIndex = -1
        let bestD2 = Infinity
        for (const fi of neighborScratch) {
          if (foodToRemove.has(fi)) continue
          const f = food[fi]
          if (!f) continue
          const d2 = distSq(b.x, b.y, f.x, f.y)
          if (d2 < bestD2) {
            bestD2 = d2
            bestIndex = fi
          }
        }
        if (bestIndex >= 0) {
          const f = food[bestIndex]
          if (f) {
            const v = steerToward(b, f.x, f.y, opts.boids.forage.herbivore)
            steer.x += v.x
            steer.y += v.y
          }
        }

        // flee from predators
        const flee = normalize({ x: fleeX, y: fleeY })
        steer.x += flee.x * maxSpeedForBoid(b) * opts.boids.flee.herbivore
        steer.y += flee.y * maxSpeedForBoid(b) * opts.boids.flee.herbivore
      } else if (b.species === 'predator') {
        if (hasChase) {
          const v = steerToward(b, chaseTargetX, chaseTargetY, opts.boids.chase.predator)
          steer.x += v.x
          steer.y += v.y
        }
      } else if (b.species === 'scavenger') {
        // scavenge toward nearest carrion
        neighborScratch.length = 0
        carrionGrid.query(b.x, b.y, pr * 1.25, neighborScratch)
        let bestIndex = -1
        let bestD2 = Infinity
        for (const ci of neighborScratch) {
          if (carrionToRemove.has(ci)) continue
          const c = carrion[ci]
          if (!c) continue
          const d2 = distSq(b.x, b.y, c.x, c.y)
          if (d2 < bestD2) {
            bestD2 = d2
            bestIndex = ci
          }
        }
        if (bestIndex >= 0) {
          const c = carrion[bestIndex]
          if (c) {
            const v = steerToward(b, c.x, c.y, opts.boids.scavenge.scavenger)
            steer.x += v.x
            steer.y += v.y
          }
        }

        // mild avoidance of predators
        const flee = normalize({ x: fleeX, y: fleeY })
        steer.x += flee.x * maxSpeedForBoid(b) * opts.boids.flee.scavenger
        steer.y += flee.y * maxSpeedForBoid(b) * opts.boids.flee.scavenger
      }

      // wander (deterministic-ish)
      const w = opts.boids.wander[b.species]
      steer.x += (Math.cos(b.dir + Math.sin(b.age * 0.7)) * maxSpeedForBoid(b) - b.vx) * w
      steer.y += (Math.sin(b.dir + Math.cos(b.age * 0.8)) * maxSpeedForBoid(b) - b.vy) * w

      // integrate
      const accel = clampLen(steer, maxForceForBoid(b))
      b.vx += accel.x * dtSeconds
      b.vy += accel.y * dtSeconds

      const v = clampLen({ x: b.vx, y: b.vy }, maxSpeedForBoid(b))
      b.vx = v.x
      b.vy = v.y

      b.x += b.vx * dtSeconds
      b.y += b.vy * dtSeconds

      b.dir = heading(b.vx, b.vy)
      if (lenSq(v) < 0.0001) b.dir = selfDir

      applyBounds(b)

      if (opts.visuals.trails) {
        b.trail.push({ x: b.x, y: b.y })
        if (b.trail.length > 16) b.trail.shift()
      } else {
        b.trail.length = 0
      }
    }

    removeIndicesInPlace(food, foodToRemove)
    removeIndicesInPlace(carrion, carrionToRemove)
    removeIndicesInPlace(boids, boidsToRemove)

    if (food.length > opts.world.foodMax) food.splice(0, food.length - opts.world.foodMax)
    if (carrion.length > opts.world.carrionMax) carrion.splice(0, carrion.length - opts.world.carrionMax)

    updateParticles(dtSeconds)
  }

  function syncStats() {
    const herb = boids.filter((b) => b.species === 'herbivore').length
    const pred = boids.filter((b) => b.species === 'predator').length
    const scav = boids.filter((b) => b.species === 'scavenger').length

    els.herm.textContent = String(herb)
    els.pred.textContent = String(pred)
    els.scav.textContent = String(scav)
    els.food.textContent = String(food.length)
    els.carrion.textContent = String(carrion.length)

    els.births.textContent = String(counters.births)
    els.deaths.textContent = String(counters.deaths)
    els.hunts.textContent = String(counters.hunts)
    els.decomp.textContent = String(counters.decomp)

    els.fps.textContent = fpsSmoothed.toFixed(0)
  }

  function tick(now: number) {
    const dt = Math.min(0.05, (now - lastT) / 1000)
    lastT = now

    const fps = 1 / Math.max(1e-6, dt)
    fpsSmoothed = fpsSmoothed * 0.9 + fps * 0.1

    if (!paused) {
      update(dt * opts.simSpeed)
    }

    draw()
    syncStats()

    // Perf warning: <20 fps for 3s
    if (fpsSmoothed < 20) {
      if (lowFpsStart == null) lowFpsStart = now
      if (now - lowFpsStart > 3000) {
        els.perfText.textContent = `Low performance detected (${fpsSmoothed.toFixed(0)} fps). Consider reducing population or disabling trails.`
        els.perfBanner.hidden = false
      }
    } else {
      lowFpsStart = null
      if (!els.perfBanner.hidden) els.perfBanner.hidden = true
    }

    requestAnimationFrame(tick)
  }

  // Init
  syncSettingsLabels()
  selectTab('presets')

  // Seed from URL, if present
  const url = new URL(window.location.href)
  const seedParam = url.searchParams.get('seed')
  if (seedParam) {
    els.seedInput.value = seedParam
    const seed = parseInt(seedParam, 10)
    if (Number.isFinite(seed)) {
      applyPresetBalancedFromSeed(seed)
    } else {
      applyPresetBalancedFromSeed(undefined)
    }
  } else {
    applyPresetBalancedFromSeed(undefined)
  }

  requestAnimationFrame(tick)
</script>
