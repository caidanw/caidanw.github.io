---
import HeaderLayout from '../../layouts/HeaderLayout.astro'
---

<HeaderLayout title="Boids Ecosystem">
  <div id="app">
    <canvas id="canvas"></canvas>

    <div class="hud">
      <div class="stats" id="stats">
        <div class="row"><span class="k">FPS</span><span class="v" id="fps">--</span></div>
        <div class="row"><span class="k">Herbivores</span><span class="v" id="statHerb">0</span></div>
        <div class="row"><span class="k">Predators</span><span class="v" id="statPred">0</span></div>
        <div class="row"><span class="k">Scavengers</span><span class="v" id="statScav">0</span></div>
        <div class="row"><span class="k">Food</span><span class="v" id="statFood">0</span></div>
        <div class="row"><span class="k">Carrion</span><span class="v" id="statCarrion">0</span></div>
        <div class="row"><span class="k">Births</span><span class="v" id="statBirths">0</span></div>
        <div class="row"><span class="k">Deaths</span><span class="v" id="statDeaths">0</span></div>
        <div class="row"><span class="k">Hunts</span><span class="v" id="statHunts">0</span></div>
        <div class="row"><span class="k">Decomp</span><span class="v" id="statDecomp">0</span></div>
      </div>

      <div class="banner" id="perfBanner" hidden>
        <div class="banner-title">Low performance</div>
        <div class="banner-body" id="perfText">FPS low.</div>
        <div class="banner-actions">
          <button id="btnReduce">Reduce population 50%</button>
          <button id="btnDisableTrails">Disable trails</button>
          <button id="btnDismiss">Dismiss</button>
        </div>
      </div>
    </div>

    <div class="bottom-bar" id="bottomBar">
      <button class="species selected" data-species="herbivore" id="btnHerb">
        <span class="dot herb"></span>
        <span>Herbivore</span>
      </button>
      <button class="species" data-species="predator" id="btnPred">
        <span class="dot pred"></span>
        <span>Predator</span>
      </button>
      <button class="species" data-species="scavenger" id="btnScav">
        <span class="dot scav"></span>
        <span>Scavenger</span>
      </button>
      <button class="menu" id="btnMenu">Menu</button>
    </div>

    <aside class="panel" id="panel" hidden>
      <div class="panel-header">
        <div class="panel-title">Boids Ecosystem</div>
        <button class="panel-close" id="btnClose">Close</button>
      </div>

      <div class="tabs">
        <button class="tab selected" data-tab="presets">Presets</button>
        <button class="tab" data-tab="visuals">Visuals</button>
        <button class="tab" data-tab="settings">Settings</button>
        <button class="tab" data-tab="about">About</button>
      </div>

      <div class="tab-content" id="tab-presets">
        <div class="preset-grid">
          <button class="wide" id="presetBalanced">Balanced Ecosystem</button>
          <button class="wide" id="presetGenesis">Genesis</button>
          <button class="wide" id="presetHerbBloom">Herbivore Bloom</button>
          <button class="wide" id="presetScavFeast">Scavenger Feast</button>
          <button class="wide" id="presetPredator">Predator Paradise</button>
          <button class="wide" id="presetExtinction">Extinction Event</button>
          <button class="wide" id="presetMegaswarm">Megaswarm</button>
          <button class="wide" id="presetEvolutionLab">Evolution Lab</button>
        </div>

        <div class="preset-hint">Megaswarm can be heavy. If FPS dips, disable Trails.</div>

        <div class="seed">
          <label>
            Seed
            <input id="seedInput" type="number" min="0" max="999999" placeholder="(optional)" />
          </label>
          <div class="seed-actions">
            <button id="btnRandomSeed">Random</button>
            <button id="btnApplySeed">Apply</button>
          </div>
          <div class="seed-note" id="seedNote"></div>
        </div>
      </div>

      <div class="tab-content" id="tab-visuals" hidden>
        <label class="toggle"><input type="checkbox" id="togTrails" /> Trails</label>
        <label class="toggle"><input type="checkbox" id="togFov" /> FOV cones</label>
        <label class="toggle"><input type="checkbox" id="togVectors" /> Velocity vectors</label>
        <label class="toggle"><input type="checkbox" id="togPerception" /> Perception radius</label>
        <label class="toggle"><input type="checkbox" id="togGrid" /> Spatial grid</label>
      </div>

      <div class="tab-content" id="tab-settings" hidden>
        <label class="slider">
          Reproduction rate
          <input id="reproRate" type="range" min="0.05" max="0.5" step="0.01" value="0.15" />
          <span class="value" id="reproRateValue">0.15</span>
        </label>

        <label class="slider">
          Decomposition yield
          <input id="decompYield" type="range" min="1" max="4" step="1" value="2" />
          <span class="value" id="decompYieldValue">2</span>
        </label>

        <label class="slider">
          Mutation rate
          <input id="mutationRate" type="range" min="0.05" max="0.25" step="0.01" value="0.10" />
          <span class="value" id="mutationRateValue">0.10</span>
        </label>

        <label class="slider">
          Gene budget
          <input id="geneBudget" type="range" min="2.6" max="3.5" step="0.05" value="3.05" />
          <span class="value" id="geneBudgetValue">3.05</span>
        </label>

        <label class="slider">
          Metabolism
          <input id="metabolism" type="range" min="0.5" max="1.5" step="0.05" value="1.0" />
          <span class="value" id="metabolismValue">1.00x</span>
        </label>

        <label class="slider">
          Predator satiation
          <input id="predSatiation" type="range" min="0" max="6" step="0.25" value="3.25" />
          <span class="value" id="predSatiationValue">3.25s</span>
        </label>

        <label class="slider">
          Predator hunger threshold
          <input id="predHunger" type="range" min="0.4" max="1.0" step="0.02" value="0.92" />
          <span class="value" id="predHungerValue">0.92</span>
        </label>

        <label class="slider">
          Speed
          <input id="simSpeed" type="range" min="0.5" max="4" step="0.5" value="1" />
          <span class="value" id="simSpeedValue">1.0x</span>
        </label>

        <div class="row-buttons">
          <button class="wide" id="btnPause">Pause</button>
          <button class="wide" id="btnClear">Clear</button>
        </div>

        <div class="walls">
          <div class="walls-title">Walls</div>
          <label class="toggle"><input type="checkbox" id="wallTop" /> Top wall</label>
          <label class="toggle"><input type="checkbox" id="wallRight" /> Right wall</label>
          <label class="toggle"><input type="checkbox" id="wallBottom" /> Bottom wall</label>
          <label class="toggle"><input type="checkbox" id="wallLeft" /> Left wall</label>
        </div>
      </div>

      <div class="tab-content" id="tab-about" hidden>
        <p>
          Three-species boids ecosystem with a closed energy loop: food → herbivores → predators → carrion → scavengers → food. Energy is shown via color
          saturation.
        </p>
        <p>Tap to spawn one. Press & hold to accumulate a cluster.</p>
      </div>
    </aside>
  </div>
</HeaderLayout>

<style>
  #app {
    position: relative;
    width: 100dvw;
    height: calc(100dvh - 2.2rem);
    overflow: hidden;
    background: #0a0a0a;
  }

  #canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    touch-action: none;
  }

  .hud {
    position: absolute;
    top: 0.75rem;
    left: 0.75rem;
    right: 0.75rem;
    display: flex;
    justify-content: space-between;
    pointer-events: none;
    gap: 0.75rem;
  }

  .stats {
    pointer-events: auto;
    background: rgba(0, 0, 0, 0.45);
    border: 1px solid var(--theme-border);
    border-radius: 0.5rem;
    padding: 0.5rem 0.6rem;
    backdrop-filter: blur(10px);
    display: grid;
    gap: 0.1rem;
    width: 10.5rem;
    font-family: var(--font-mono);
    font-size: 0.75rem;
  }

  .row {
    display: flex;
    justify-content: space-between;
    gap: 0.75rem;
  }

  .k {
    color: rgba(255, 255, 255, 0.7);
  }

  .v {
    color: rgba(255, 255, 255, 0.95);
  }

  .banner {
    pointer-events: auto;
    flex: 1;
    max-width: 40rem;
    background: rgba(0, 0, 0, 0.75);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 0.75rem;
    padding: 0.75rem;
    backdrop-filter: blur(12px);
  }

  .banner-title {
    font-weight: 700;
    margin-bottom: 0.25rem;
  }

  .banner-body {
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: 0.5rem;
    font-size: 0.875rem;
  }

  .banner-actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  .bottom-bar {
    position: absolute;
    left: 0.75rem;
    right: 0.75rem;
    bottom: 0.75rem;
    display: flex;
    gap: 0.5rem;
    pointer-events: auto;
    user-select: none;
  }

  .species,
  .menu {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 0.6rem 0.75rem;
    border-radius: 999px;
    border: 1px solid rgba(255, 255, 255, 0.18);
    background: rgba(0, 0, 0, 0.6);
    color: rgba(255, 255, 255, 0.92);
    backdrop-filter: blur(8px);
    font-weight: 650;
    font-size: 0.85rem;
  }

  .species.selected {
    border-color: rgba(255, 255, 255, 0.35);
    box-shadow:
      0 0 0 1px rgba(255, 255, 255, 0.08),
      0 0 22px rgba(32, 225, 33, 0.25);
  }

  .dot {
    width: 0.7rem;
    height: 0.7rem;
    border-radius: 999px;
    display: inline-block;
    filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.1));
  }

  .dot.herb {
    background: #20e121;
  }
  .dot.pred {
    background: #e12120;
  }
  .dot.scav {
    background: #2120e1;
  }

  .panel {
    position: absolute;
    top: 0.75rem;
    right: 0.75rem;
    bottom: 4.75rem;
    width: min(24rem, calc(100dvw - 1.5rem));
    background: rgba(0, 0, 0, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 0.75rem;
    backdrop-filter: blur(12px);
    padding: 0.75rem;
    overflow: auto;
  }

  .panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 0.75rem;
    margin-bottom: 0.75rem;
  }

  .panel-title {
    font-weight: 700;
  }

  .panel-close {
    border-radius: 0.5rem;
    padding: 0.4rem 0.6rem;
    border: 1px solid rgba(255, 255, 255, 0.15);
    background: rgba(255, 255, 255, 0.07);
    color: rgba(255, 255, 255, 0.9);
  }

  .tabs {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 0.5rem;
    margin-bottom: 0.75rem;
  }

  .tab {
    border-radius: 0.6rem;
    padding: 0.45rem 0.4rem;
    border: 1px solid rgba(255, 255, 255, 0.12);
    background: rgba(255, 255, 255, 0.06);
    color: rgba(255, 255, 255, 0.85);
    font-size: 0.8rem;
  }

  .tab.selected {
    border-color: rgba(255, 255, 255, 0.25);
  }

  .tab-content {
    display: grid;
    gap: 0.6rem;
    font-size: 0.9rem;
    line-height: 1.3;
  }

  .preset-grid {
    display: grid;
    gap: 0.6rem;
  }

  @media (min-width: 520px) {
    .preset-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  .preset-hint {
    color: rgba(255, 255, 255, 0.68);
    font-size: 0.8rem;
  }

  .wide {
    width: 100%;
    border-radius: 0.6rem;
    padding: 0.6rem 0.7rem;
    border: 1px solid rgba(255, 255, 255, 0.14);
    background: rgba(255, 255, 255, 0.08);
    color: rgba(255, 255, 255, 0.92);
    text-align: left;
  }

  .toggle {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: rgba(255, 255, 255, 0.9);
  }

  .slider {
    display: grid;
    gap: 0.35rem;
    color: rgba(255, 255, 255, 0.9);
  }

  .slider input[type='range'] {
    width: 100%;
  }

  .value {
    justify-self: end;
    font-family: var(--font-mono);
    color: rgba(255, 255, 255, 0.75);
  }

  .seed {
    margin-top: 0.25rem;
    border-top: 1px solid rgba(255, 255, 255, 0.12);
    padding-top: 0.75rem;
    display: grid;
    gap: 0.5rem;
  }

  .seed input {
    width: 100%;
    margin-top: 0.25rem;
    border-radius: 0.5rem;
    padding: 0.45rem 0.6rem;
    border: 1px solid rgba(255, 255, 255, 0.14);
    background: rgba(0, 0, 0, 0.4);
    color: rgba(255, 255, 255, 0.9);
  }

  .seed-actions {
    display: flex;
    gap: 0.5rem;
  }

  .seed-actions button {
    flex: 1;
  }

  .seed-note {
    font-family: var(--font-mono);
    font-size: 0.75rem;
    color: rgba(255, 255, 255, 0.6);
  }

  .row-buttons {
    display: flex;
    gap: 0.5rem;
  }

  .walls {
    margin-top: 0.25rem;
    border-top: 1px solid rgba(255, 255, 255, 0.12);
    padding-top: 0.75rem;
    display: grid;
    gap: 0.5rem;
  }

  .walls-title {
    font-weight: 650;
    margin-bottom: 0.25rem;
  }

  button {
    cursor: pointer;
  }
</style>

<script>
  import { RingBuffer } from '../../lib/ringbuffer'

  type Species = 'herbivore' | 'predator' | 'scavenger'

  const opts = {
    colors: {
      herbivore: '#20e121',
      predator: '#e12120',
      scavenger: '#2120e1',
      background: '#0a0a0a',
      carrion: '#886688',
      dead: '#808080',
    },
    energy: {
      herbivoreMax: 250,
      predatorMax: 480,
      scavengerMax: 340,
      eatFoodGain: 32,
      eatHerbivoreGain: 45,
      // carrion mass is converted into energy via scavenger efficiency
      herbivoreDrain: 0.14,
      predatorDrain: 0.22,
      scavengerDrain: 0.18,

      metabolism: 1.0,
    },
    boids: {
      baseMaxSpeed: {
        herbivore: 108,
        predator: 126,
        scavenger: 84,
      },
      baseMaxForce: {
        herbivore: 165,
        predator: 210,
        scavenger: 178,
      },
      // perception radii are multiplied by gene.perception
      perception: {
        herbivore: 142,
        predator: 220,
        scavenger: 182,
      },
      // field-of-view (degrees, full cone)
      fov: {
        herbivore: 200,
        predator: 45,
        scavenger: 360,
      },
      separation: {
        herbivore: 22,
        predator: 26,
        scavenger: 22,
      },
      cohesion: {
        herbivore: 0.5,
        predator: 0.35,
        scavenger: 0.45,
      },
      alignment: {
        herbivore: 0.65,
        predator: 0.4,
        scavenger: 0.55,
      },
      wander: {
        herbivore: 0.18,
        predator: 0.08,
        scavenger: 0.14,
      },
      flee: {
        herbivore: 1.2,
        predator: 0,
        scavenger: 0.65,
      },
      chase: {
        herbivore: 0,
        predator: 1.35,
        scavenger: 0,
      },
      forage: {
        herbivore: 1.15,
        predator: 0,
        scavenger: 0,
      },
      scavenge: {
        herbivore: 0,
        predator: 0,
        scavenger: 1.2,
      },
    },
    world: {
      foodMax: 400,
      carrionMax: 400,
      foodSpawnRate: 1, // per second
      carrionDecaySeconds: 36,
    },
    life: {
      maturitySeconds: 60,
      juvenileScale: 0.2,

      // Multiplier for speed/force at birth (lerps to 1 by maturity).
      juvenileMobility: 1.6,
    },
    reproduction: {
      rate: 0.15,
      matingRadius: 20,
      maturity: 0.95,
      herbivoreThreshold: 140,
      predatorThreshold: 120,
      scavengerThreshold: 100,

      predatorSatiationSeconds: 2.0,
      predatorHungerThreshold: 0.9,
    },
    decomposition: {
      yield: 4,
      spawnRadius: { min: 6, max: 20 },
    },
    interaction: {
      herbivoreEatQueryRadius: 14,
      herbivoreEatRadius: 12,
      predatorAttackQueryRadius: 18,
      predatorAttackRadius: 14,
      scavengerEatQueryRadius: 18,
      scavengerEatRadius: 14,
      carrionTakeAmount: 0.45,
      carrionEnergyMultiplier: 34,
      carrionDepletionThreshold: 0.06,
    },
    genetics: {
      mutationRate: 0.1,
      min: 0.5,
      max: 1.5,
      mutationAmount: 0.1, // ±5% since (rand-0.5)*0.1

      // gene budget constraint: sum of genes <= budget
      budget: 5.05,
      budgetBoost: 0.35,
    },
    walls: {
      top: false,
      right: false,
      bottom: false,
      left: false,
    },
    visuals: {
      trails: false,
      fov: false,
      vectors: false,
      perception: false,
      grid: true,
    },
    simSpeed: 1,
  }

  function clone<T>(value: T): T {
    return typeof structuredClone === 'function' ? structuredClone(value) : JSON.parse(JSON.stringify(value))
  }

  const defaultOpts = clone(opts)

  function restoreOptsDefaults() {
    Object.assign(opts, clone(defaultOpts))
  }

  function beginPreset() {
    restoreOptsDefaults()
    clearAll()
    syncSettingsLabels()
  }

  const els = {
    canvas: document.getElementById('canvas') as HTMLCanvasElement,
    fps: document.getElementById('fps') as HTMLSpanElement,
    herb: document.getElementById('statHerb') as HTMLSpanElement,
    pred: document.getElementById('statPred') as HTMLSpanElement,
    scav: document.getElementById('statScav') as HTMLSpanElement,
    food: document.getElementById('statFood') as HTMLSpanElement,
    carrion: document.getElementById('statCarrion') as HTMLSpanElement,
    births: document.getElementById('statBirths') as HTMLSpanElement,
    deaths: document.getElementById('statDeaths') as HTMLSpanElement,
    hunts: document.getElementById('statHunts') as HTMLSpanElement,
    decomp: document.getElementById('statDecomp') as HTMLSpanElement,

    perfBanner: document.getElementById('perfBanner') as HTMLDivElement,
    perfText: document.getElementById('perfText') as HTMLDivElement,
    btnReduce: document.getElementById('btnReduce') as HTMLButtonElement,
    btnDisableTrails: document.getElementById('btnDisableTrails') as HTMLButtonElement,
    btnDismiss: document.getElementById('btnDismiss') as HTMLButtonElement,

    btnHerb: document.getElementById('btnHerb') as HTMLButtonElement,
    btnPred: document.getElementById('btnPred') as HTMLButtonElement,
    btnScav: document.getElementById('btnScav') as HTMLButtonElement,
    btnMenu: document.getElementById('btnMenu') as HTMLButtonElement,
    panel: document.getElementById('panel') as HTMLDivElement,
    btnClose: document.getElementById('btnClose') as HTMLButtonElement,

    tabPresets: document.getElementById('tab-presets') as HTMLDivElement,
    tabVisuals: document.getElementById('tab-visuals') as HTMLDivElement,
    tabSettings: document.getElementById('tab-settings') as HTMLDivElement,
    tabAbout: document.getElementById('tab-about') as HTMLDivElement,

    presetBalanced: document.getElementById('presetBalanced') as HTMLButtonElement,
    presetGenesis: document.getElementById('presetGenesis') as HTMLButtonElement,
    presetHerbBloom: document.getElementById('presetHerbBloom') as HTMLButtonElement,
    presetScavFeast: document.getElementById('presetScavFeast') as HTMLButtonElement,
    presetPredator: document.getElementById('presetPredator') as HTMLButtonElement,
    presetExtinction: document.getElementById('presetExtinction') as HTMLButtonElement,
    presetMegaswarm: document.getElementById('presetMegaswarm') as HTMLButtonElement,
    presetEvolutionLab: document.getElementById('presetEvolutionLab') as HTMLButtonElement,

    seedInput: document.getElementById('seedInput') as HTMLInputElement,
    seedNote: document.getElementById('seedNote') as HTMLDivElement,
    btnRandomSeed: document.getElementById('btnRandomSeed') as HTMLButtonElement,
    btnApplySeed: document.getElementById('btnApplySeed') as HTMLButtonElement,

    togTrails: document.getElementById('togTrails') as HTMLInputElement,
    togFov: document.getElementById('togFov') as HTMLInputElement,
    togVectors: document.getElementById('togVectors') as HTMLInputElement,
    togPerception: document.getElementById('togPerception') as HTMLInputElement,
    togGrid: document.getElementById('togGrid') as HTMLInputElement,

    reproRate: document.getElementById('reproRate') as HTMLInputElement,
    reproRateValue: document.getElementById('reproRateValue') as HTMLSpanElement,
    decompYield: document.getElementById('decompYield') as HTMLInputElement,
    decompYieldValue: document.getElementById('decompYieldValue') as HTMLSpanElement,
    mutationRate: document.getElementById('mutationRate') as HTMLInputElement,
    mutationRateValue: document.getElementById('mutationRateValue') as HTMLSpanElement,

    geneBudget: document.getElementById('geneBudget') as HTMLInputElement,
    geneBudgetValue: document.getElementById('geneBudgetValue') as HTMLSpanElement,
    metabolism: document.getElementById('metabolism') as HTMLInputElement,
    metabolismValue: document.getElementById('metabolismValue') as HTMLSpanElement,
    predSatiation: document.getElementById('predSatiation') as HTMLInputElement,
    predSatiationValue: document.getElementById('predSatiationValue') as HTMLSpanElement,
    predHunger: document.getElementById('predHunger') as HTMLInputElement,
    predHungerValue: document.getElementById('predHungerValue') as HTMLSpanElement,

    simSpeed: document.getElementById('simSpeed') as HTMLInputElement,
    simSpeedValue: document.getElementById('simSpeedValue') as HTMLSpanElement,

    btnPause: document.getElementById('btnPause') as HTMLButtonElement,
    btnClear: document.getElementById('btnClear') as HTMLButtonElement,

    wallTop: document.getElementById('wallTop') as HTMLInputElement,
    wallRight: document.getElementById('wallRight') as HTMLInputElement,
    wallBottom: document.getElementById('wallBottom') as HTMLInputElement,
    wallLeft: document.getElementById('wallLeft') as HTMLInputElement,
  }

  const ctx = els.canvas.getContext('2d')!

  let simW = 0
  let simH = 0

  // HiDPI canvas sizing
  function resizeCanvas() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1))
    const rect = els.canvas.getBoundingClientRect()

    simW = rect.width
    simH = rect.height

    els.canvas.width = Math.floor(rect.width * dpr)
    els.canvas.height = Math.floor(rect.height * dpr)
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0)
  }

  resizeCanvas()
  window.addEventListener('resize', resizeCanvas)

  // --- Simulation state (placeholder; boids logic next) ---

  type Genes = { speed: number; perception: number; efficiency: number }

  type Sex = 'a' | 'b'

  type Boid = {
    id: number
    species: Species
    sex: Sex
    x: number
    y: number
    vx: number
    vy: number
    energy: number
    maxEnergy: number
    genes: Genes
    age: number
    dir: number
    cooldown: {
      eat: number
      reproduce: number
      hunt: number
    }
    trail: RingBuffer<{ x: number; y: number }>
  }

  type FoodSource = { x: number; y: number }
  type Carrion = { x: number; y: number; mass: number; age: number }
  type Particle = { x: number; y: number; vx: number; vy: number; life: number; color: string; size: number }

  let nextId = 1
  let boids: Boid[] = []
  let food: FoodSource[] = []
  let carrion: Carrion[] = []
  let particles: Particle[] = []

  let selectedSpecies: Species = 'herbivore'

  const counters = {
    births: 0,
    deaths: 0,
    hunts: 0,
    decomp: 0,
  }

  // --- Utilities ---

  function clamp(value: number, min: number, max: number): number {
    return Math.max(min, Math.min(max, value))
  }

  function lerp(a: number, b: number, t: number): number {
    return a + (b - a) * t
  }

  function rand(min: number, max: number): number {
    return min + Math.random() * (max - min)
  }

  type Vec = { x: number; y: number }

  function lenSq(v: Vec): number {
    return v.x * v.x + v.y * v.y
  }

  function len(v: Vec): number {
    return Math.sqrt(lenSq(v))
  }

  function distSq(ax: number, ay: number, bx: number, by: number): number {
    const dx = ax - bx
    const dy = ay - by
    return dx * dx + dy * dy
  }

  function clampLen(v: Vec, maxLen: number): Vec {
    const l = len(v)
    if (l <= maxLen || l === 0) return v
    const s = maxLen / l
    return { x: v.x * s, y: v.y * s }
  }

  function normalize(v: Vec): Vec {
    const l = len(v)
    if (l === 0) return { x: 0, y: 0 }
    return { x: v.x / l, y: v.y / l }
  }

  function heading(vx: number, vy: number): number {
    return Math.atan2(vy, vx)
  }

  function angleDelta(a: number, b: number): number {
    let d = a - b
    while (d > Math.PI) d -= Math.PI * 2
    while (d < -Math.PI) d += Math.PI * 2
    return d
  }

  function packCellKey(cx: number, cy: number): number {
    return ((cy & 0xffff) << 16) ^ (cx & 0xffff)
  }

  class SpatialGrid {
    cellSize: number
    map: Map<number, number[]>

    constructor(cellSize: number) {
      this.cellSize = cellSize
      this.map = new Map()
    }

    clear() {
      this.map.clear()
    }

    insert(x: number, y: number, index: number) {
      const cx = Math.floor(x / this.cellSize)
      const cy = Math.floor(y / this.cellSize)
      const key = packCellKey(cx, cy)
      const arr = this.map.get(key)
      if (arr) {
        arr.push(index)
      } else {
        this.map.set(key, [index])
      }
    }

    query(x: number, y: number, radius: number, out: number[]) {
      const c = this.cellSize
      const cx = Math.floor(x / c)
      const cy = Math.floor(y / c)
      const r = Math.ceil(radius / c)

      for (let oy = -r; oy <= r; oy++) {
        for (let ox = -r; ox <= r; ox++) {
          const key = packCellKey(cx + ox, cy + oy)
          const arr = this.map.get(key)
          if (!arr) continue
          for (const index of arr) out.push(index)
        }
      }
    }
  }

  const boidGrid = new SpatialGrid(80)
  const foodGrid = new SpatialGrid(70)
  const carrionGrid = new SpatialGrid(70)

  function seededRandom(seed: number) {
    // xorshift32
    let x = seed | 0
    if (x === 0) x = 123456789
    return {
      next() {
        x ^= x << 13
        x ^= x >>> 17
        x ^= x << 5
        return (x >>> 0) / 4294967296
      },
    }
  }

  function normalizeGenesToBudget(genes: Genes): Genes {
    const min = opts.genetics.min
    const max = opts.genetics.max

    let speed = clamp(genes.speed, min, max)
    let perception = clamp(genes.perception, min, max)
    let efficiency = clamp(genes.efficiency, min, max)

    const budget = Math.max(0.01, opts.genetics.budget)

    // Always allow a baseline of min for each gene; clamp the excess to budget.
    const base = 3 * min
    const available = Math.max(0, budget - base)

    const exSpeed = Math.max(0, speed - min)
    const exPerception = Math.max(0, perception - min)
    const exEfficiency = Math.max(0, efficiency - min)
    const exSum = exSpeed + exPerception + exEfficiency

    if (exSum > available && exSum > 0) {
      const s = available / exSum
      speed = min + exSpeed * s
      perception = min + exPerception * s
      efficiency = min + exEfficiency * s
    }

    return {
      speed: clamp(speed, min, max),
      perception: clamp(perception, min, max),
      efficiency: clamp(efficiency, min, max),
    }
  }

  function randomGenes(rng?: { next: () => number }): Genes {
    const r = rng ? rng.next.bind(rng) : Math.random
    // pseudo-normal-ish by averaging 2 uniforms
    const n = () => 1 + ((r() + r()) / 2 - 0.5) * 0.2
    return normalizeGenesToBudget({
      speed: n(),
      perception: n(),
      efficiency: n(),
    })
  }

  function genesForEvolutionLab(rng: { next: () => number }): Genes {
    const r = rng.next
    const wideMin = 0.75
    const wideMax = 1.25
    return normalizeGenesToBudget({
      speed: wideMin + r() * (wideMax - wideMin),
      perception: wideMin + r() * (wideMax - wideMin),
      efficiency: wideMin + r() * (wideMax - wideMin),
    })
  }

  function mutateGene(gene: number): number {
    if (Math.random() > opts.genetics.mutationRate) return gene
    const change = (Math.random() - 0.5) * opts.genetics.mutationAmount
    return clamp(gene + change, opts.genetics.min, opts.genetics.max)
  }

  function mutateGenes(genes: Genes): Genes {
    return normalizeGenesToBudget({
      speed: mutateGene(genes.speed),
      perception: mutateGene(genes.perception),
      efficiency: mutateGene(genes.efficiency),
    })
  }

  function mixGenes(a: Genes, b: Genes): Genes {
    // uniform crossover (per gene)
    return normalizeGenesToBudget({
      speed: Math.random() < 0.5 ? a.speed : b.speed,
      perception: Math.random() < 0.5 ? a.perception : b.perception,
      efficiency: Math.random() < 0.5 ? a.efficiency : b.efficiency,
    })
  }

  function canMate(b: Boid): boolean {
    if (b.cooldown.reproduce > 0) return false
    if (maturityForBoid(b) < opts.reproduction.maturity) return false
    if (b.energy < reproductionThresholdForSpecies(b.species)) return false
    return true
  }

  function findMateIndex(i: number, b: Boid, boidsToRemove: Set<number>): number | null {
    neighborScratch.length = 0
    boidGrid.query(b.x, b.y, opts.reproduction.matingRadius, neighborScratch)

    let bestIndex = -1
    let bestD2 = Infinity

    for (const j of neighborScratch) {
      if (j === i) continue
      if (boidsToRemove.has(j)) continue
      const o = boids[j]
      if (!o) continue
      if (o.species !== b.species) continue
      if (o.sex === b.sex) continue
      if (!canMate(o)) continue

      const d2 = distSq(b.x, b.y, o.x, o.y)
      if (d2 > opts.reproduction.matingRadius * opts.reproduction.matingRadius) continue
      if (d2 < bestD2) {
        bestD2 = d2
        bestIndex = j
      }
    }

    return bestIndex >= 0 ? bestIndex : null
  }

  function spawnChildFromParents(a: Boid, b: Boid) {
    const maxEnergy = maxEnergyForSpecies(a.species)
    const totalCost = maxEnergy * 0.35
    const costEach = totalCost / 2
    if (a.energy <= costEach + 1) return
    if (b.energy <= costEach + 1) return

    a.energy -= costEach
    b.energy -= costEach

    const childGenes = mutateGenes(mixGenes(a.genes, b.genes))

    const midX = (a.x + b.x) / 2
    const midY = (a.y + b.y) / 2
    const jitterA = Math.random() * Math.PI * 2
    const jitterR = 8 + Math.random() * 10
    const x = clamp(midX + Math.cos(jitterA) * jitterR, 1, simW - 1)
    const y = clamp(midY + Math.sin(jitterA) * jitterR, 1, simH - 1)

    const vx = (a.vx + b.vx) / 2 + rand(-18, 18)
    const vy = (a.vy + b.vy) / 2 + rand(-18, 18)

    const childEnergy = Math.min(maxEnergy * 0.6, totalCost)

    boids.push({
      id: nextId++,
      species: a.species,
      sex: Math.random() < 0.5 ? 'a' : 'b',
      x,
      y,
      vx,
      vy,
      energy: childEnergy,
      maxEnergy,
      genes: childGenes,
      age: 0,
      dir: heading(vx, vy),
      cooldown: { eat: 0.2, reproduce: 0.8, hunt: 0 },
      trail: new RingBuffer(16),
    })

    a.cooldown.reproduce = 1.4
    b.cooldown.reproduce = 1.4
    counters.births++
    addParticle(x, y, opts.colors[a.species])
  }

  function maxEnergyForSpecies(species: Species): number {
    switch (species) {
      case 'herbivore':
        return opts.energy.herbivoreMax
      case 'predator':
        return opts.energy.predatorMax
      case 'scavenger':
        return opts.energy.scavengerMax
    }
  }

  function reproductionThresholdForSpecies(species: Species): number {
    switch (species) {
      case 'herbivore':
        return opts.reproduction.herbivoreThreshold
      case 'predator':
        return opts.reproduction.predatorThreshold
      case 'scavenger':
        return opts.reproduction.scavengerThreshold
    }
  }

  function maturityForBoid(b: Boid): number {
    return clamp(b.age / Math.max(0.01, opts.life.maturitySeconds), 0, 1)
  }

  function growthScaleForBoid(b: Boid): number {
    const m = maturityForBoid(b)
    const ratio = clamp(b.energy / Math.max(1, b.maxEnergy), 0, 1)
    const size = lerp(opts.life.juvenileScale, 1, m)
    const energyScale = lerp(0.85, 1, ratio)
    return size * energyScale
  }

  function mobilityScaleForBoid(b: Boid): number {
    const m = maturityForBoid(b)
    return lerp(opts.life.juvenileMobility, 1, m)
  }

  function shouldReproduce(b: Boid, dtSeconds: number): boolean {
    if (b.cooldown.reproduce > 0) return false
    if (maturityForBoid(b) < opts.reproduction.maturity) return false
    if (b.energy < reproductionThresholdForSpecies(b.species)) return false

    // Scale probability by dt to make frame-rate independent
    // species with efficient genes reproduce slightly more
    const p = opts.reproduction.rate * (0.85 + 0.3 * b.genes.efficiency) * dtSeconds
    return Math.random() < p
  }

  function spawnChildFromParent(parent: Boid) {
    const childGenes = mutateGenes(parent.genes)

    const a = Math.random() * Math.PI * 2
    const r = 10 + Math.random() * 16
    const x = clamp(parent.x + Math.cos(a) * r, 1, simW - 1)
    const y = clamp(parent.y + Math.sin(a) * r, 1, simH - 1)

    const maxEnergy = maxEnergyForSpecies(parent.species)
    const energyCost = maxEnergy * 0.35
    if (parent.energy <= energyCost + 1) return

    parent.energy -= energyCost

    const childEnergy = Math.min(maxEnergy * 0.6, energyCost)

    const vx = parent.vx + rand(-20, 20)
    const vy = parent.vy + rand(-20, 20)

    boids.push({
      id: nextId++,
      species: parent.species,
      sex: Math.random() < 0.5 ? 'a' : 'b',
      x,
      y,
      vx,
      vy,
      energy: childEnergy,
      maxEnergy,
      genes: childGenes,
      age: 0,
      dir: heading(vx, vy),
      cooldown: { eat: 0.2, reproduce: 0.8, hunt: 0 },
      trail: new RingBuffer(16),
    })

    parent.cooldown.reproduce = 1.4
    counters.births++
    addParticle(x, y, opts.colors[parent.species])
  }

  function spawnBoid(species: Species, x: number, y: number, genes?: Genes) {
    const maxEnergy = maxEnergyForSpecies(species)
    const g = genes ?? randomGenes()
    const vx = rand(-1, 1)
    const vy = rand(-1, 1)
    boids.push({
      id: nextId++,
      species,
      sex: Math.random() < 0.5 ? 'a' : 'b',
      x,
      y,
      vx,
      vy,
      energy: maxEnergy,
      maxEnergy,
      genes: g,
      age: 0,
      dir: heading(vx, vy),
      cooldown: { eat: 0, reproduce: 0, hunt: 0 },
      trail: new RingBuffer(16),
    })
  }

  function spawnFood(x: number, y: number) {
    food.push({ x, y })
  }

  function spawnDecompositionFood(cx: number, cy: number) {
    for (let k = 0; k < opts.decomposition.yield; k++) {
      const a = Math.random() * Math.PI * 2
      const r = opts.decomposition.spawnRadius.min + Math.random() * (opts.decomposition.spawnRadius.max - opts.decomposition.spawnRadius.min)
      spawnFood(clamp(cx + Math.cos(a) * r, 4, simW - 4), clamp(cy + Math.sin(a) * r, 4, simH - 4))
    }
    counters.decomp++
  }

  function clearAll() {
    boids = []
    food = []
    carrion = []
    particles = []
    counters.births = 0
    counters.deaths = 0
    counters.hunts = 0
    counters.decomp = 0
  }

  // --- Rendering helpers (placeholder) ---

  function drawBackground() {
    // Reset state that could otherwise accumulate brightness/alpha across frames.
    ctx.save()
    ctx.globalCompositeOperation = 'source-over'
    ctx.globalAlpha = 1
    ctx.shadowBlur = 0
    ctx.shadowColor = 'transparent'

    if (opts.visuals.trails) {
      // Higher alpha = faster fade (prevents permanent burn-in).
      const fade = 0.24
      ctx.fillStyle = `rgba(10, 10, 10, ${fade})`
    } else {
      ctx.fillStyle = opts.colors.background
    }

    ctx.fillRect(0, 0, simW, simH)
    ctx.restore()
  }

  function draw() {
    drawBackground()

    // Food
    for (const f of food) {
      ctx.save()
      ctx.globalAlpha = 0.55
      ctx.fillStyle = opts.colors.herbivore
      ctx.shadowColor = opts.colors.herbivore
      ctx.shadowBlur = 10
      ctx.beginPath()
      ctx.arc(f.x, f.y, 2.6, 0, Math.PI * 2)
      ctx.fill()
      ctx.restore()
    }

    // Carrion
    for (const c of carrion) {
      const alpha = clamp(0.2 + (1 - c.age / opts.world.carrionDecaySeconds) * 0.8, 0, 1)
      ctx.save()
      ctx.globalAlpha = alpha
      ctx.strokeStyle = opts.colors.carrion
      ctx.shadowColor = opts.colors.carrion
      ctx.shadowBlur = 10
      ctx.lineWidth = 1
      ctx.beginPath()
      ctx.arc(c.x, c.y, 4 + c.mass * 3.2, 0, Math.PI * 2)
      ctx.stroke()
      ctx.restore()
    }

    // Spawn cluster charge indicator
    // Show a ring while holding; it follows the pointer until release.
    if (pressPoint && (pressTimer || clusterTimer)) {
      const color = opts.colors[selectedSpecies]
      const progress = clusterTimer ? clamp(clusterProgress, 0, 1) : 0
      const baseR = 14
      const r = baseR + 18 * progress

      // For quick taps, clusterCount may be stale; default to 1.
      const count = Math.max(1, clusterCount)

      ctx.save()
      ctx.globalAlpha = 0.85
      ctx.strokeStyle = color
      ctx.shadowColor = color
      ctx.shadowBlur = 16
      ctx.lineWidth = 1.5

      ctx.beginPath()
      ctx.arc(pressPoint.x, pressPoint.y, r, 0, Math.PI * 2)
      ctx.stroke()

      if (clusterTimer) {
        ctx.globalAlpha = 0.95
        ctx.lineWidth = 2
        ctx.beginPath()
        ctx.arc(pressPoint.x, pressPoint.y, r, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2)
        ctx.stroke()
      }

      ctx.globalAlpha = 0.9
      ctx.fillStyle = color
      ctx.font = '12px var(--font-mono)'
      ctx.textAlign = 'center'
      ctx.textBaseline = 'middle'

      const labelY = clamp(pressPoint.y - r - 14, 10, simH - 10)
      ctx.fillText(String(count), pressPoint.x, labelY)

      ctx.restore()
    }

    function drawBoidArrow(b: Boid) {
      const baseSize = b.species === 'predator' ? 12 : b.species === 'scavenger' ? 10 : 9
      const ratio = clamp(b.energy / Math.max(1, b.maxEnergy), 0, 1)
      const alpha = 0.16 + ratio * 0.84

      const angle = b.dir
      const size = baseSize * (0.9 + 0.3 * b.genes.speed) * growthScaleForBoid(b)

      const color = b.species === 'predator' ? opts.colors.predator : b.species === 'scavenger' ? opts.colors.scavenger : opts.colors.herbivore

      // Flatland-ish silhouettes:
      // - predator: needle isosceles (brute soldiers)
      // - herbivore: balanced
      // - scavenger: wide/flat
      const g = b.genes

      // more perception -> wider wings; more speed -> longer nose; more efficiency -> heavier outline
      const backFactorBase = b.species === 'predator' ? 0.92 : b.species === 'scavenger' ? 0.62 : 0.75
      const wingFactorBase = b.species === 'predator' ? 0.28 : b.species === 'scavenger' ? 0.84 : 0.55

      const backFactor = clamp(backFactorBase + (g.speed - 1) * 0.18, 0.5, 1.05)
      const wingFactor = clamp(wingFactorBase + (g.perception - 1) * 0.35, 0.18, 1.15)

      // Arrowhead triangle (outline only)
      const tipX = b.x + Math.cos(angle) * size
      const tipY = b.y + Math.sin(angle) * size
      const backX = b.x - Math.cos(angle) * size * backFactor
      const backY = b.y - Math.sin(angle) * size * backFactor

      const wingAngle = angle + Math.PI / 2
      const wing = size * wingFactor
      const leftX = backX + Math.cos(wingAngle) * wing
      const leftY = backY + Math.sin(wingAngle) * wing
      const rightX = backX - Math.cos(wingAngle) * wing
      const rightY = backY - Math.sin(wingAngle) * wing

      if (opts.visuals.trails && b.trail.length > 2) {
        ctx.save()
        ctx.globalAlpha = alpha * 0.25
        ctx.strokeStyle = color
        ctx.shadowColor = color
        ctx.shadowBlur = 10
        ctx.lineWidth = 1
        ctx.beginPath()
        const first = b.trail.at(0)
        if (first) {
          ctx.moveTo(first.x, first.y)
          for (const pt of b.trail) ctx.lineTo(pt.x, pt.y)
        }
        ctx.stroke()
        ctx.restore()
      }

      ctx.save()
      ctx.globalAlpha = alpha
      ctx.lineWidth = clamp(1.0 + (g.efficiency - 1) * 2.4, 0.9, 3.2)
      ctx.strokeStyle = color
      ctx.shadowColor = color
      ctx.shadowBlur = 14 + clamp((g.perception - 1) * 20, -6, 10)

      ctx.beginPath()
      ctx.moveTo(tipX, tipY)
      ctx.lineTo(leftX, leftY)
      ctx.lineTo(rightX, rightY)
      ctx.closePath()
      ctx.stroke()
      ctx.restore()

      if (opts.visuals.vectors) {
        ctx.save()
        ctx.globalAlpha = 0.5
        ctx.strokeStyle = color
        ctx.lineWidth = 1
        ctx.beginPath()
        ctx.moveTo(b.x, b.y)
        ctx.lineTo(b.x + b.vx * 0.14, b.y + b.vy * 0.14)
        ctx.stroke()
        ctx.restore()
      }

      if (opts.visuals.perception) {
        const pr = perceptionForBoid(b)
        ctx.save()
        ctx.globalAlpha = 0.08
        ctx.strokeStyle = color
        ctx.lineWidth = 1
        ctx.beginPath()
        ctx.arc(b.x, b.y, pr, 0, Math.PI * 2)
        ctx.stroke()
        ctx.restore()
      }

      if (opts.visuals.fov) {
        const pr = perceptionForBoid(b)
        const half = fovForBoid(b)
        ctx.save()
        ctx.globalAlpha = 0.08
        ctx.strokeStyle = color
        ctx.lineWidth = 1
        ctx.beginPath()
        ctx.moveTo(b.x, b.y)
        ctx.arc(b.x, b.y, pr, b.dir - half, b.dir + half)
        ctx.closePath()
        ctx.stroke()
        ctx.restore()
      }
    }

    // Boids
    for (const b of boids) {
      drawBoidArrow(b)
    }

    // Particles
    for (const p of particles) {
      const a = clamp(p.life / 0.7, 0, 1)
      ctx.save()
      ctx.globalAlpha = a
      ctx.fillStyle = p.color
      ctx.shadowColor = p.color
      ctx.shadowBlur = 10
      ctx.beginPath()
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2)
      ctx.fill()
      ctx.restore()
    }

    if (opts.visuals.grid) {
      ctx.save()
      ctx.globalAlpha = 0.06
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)'
      ctx.lineWidth = 1
      const cellSize = boidGrid.cellSize
      for (let x = 0; x < simW; x += cellSize) {
        ctx.beginPath()
        ctx.moveTo(x, 0)
        ctx.lineTo(x, simH)
        ctx.stroke()
      }
      for (let y = 0; y < simH; y += cellSize) {
        ctx.beginPath()
        ctx.moveTo(0, y)
        ctx.lineTo(simW, y)
        ctx.stroke()
      }
      ctx.restore()
    }
  }

  // --- UI wiring ---

  function setSelectedSpecies(species: Species) {
    selectedSpecies = species
    els.btnHerb.classList.toggle('selected', species === 'herbivore')
    els.btnPred.classList.toggle('selected', species === 'predator')
    els.btnScav.classList.toggle('selected', species === 'scavenger')
  }

  document.getElementById('bottomBar')?.addEventListener('click', (e) => {
    const target = e.target as HTMLElement | null
    const btn = target?.closest('button[data-species]') as HTMLButtonElement | null
    const species = btn?.dataset?.species as Species | undefined
    if (species) setSelectedSpecies(species)
  })

  function openPanel() {
    els.panel.hidden = false
  }

  function closePanel() {
    els.panel.hidden = true
  }

  els.btnMenu.addEventListener('click', openPanel)
  els.btnClose.addEventListener('click', closePanel)

  const tabs = Array.from(document.querySelectorAll('.tab')) as HTMLButtonElement[]
  const tabContentEls: Record<string, HTMLDivElement> = {
    presets: els.tabPresets,
    visuals: els.tabVisuals,
    settings: els.tabSettings,
    about: els.tabAbout,
  }

  function selectTab(name: string) {
    for (const tab of tabs) tab.classList.toggle('selected', tab.dataset.tab === name)
    for (const [k, el] of Object.entries(tabContentEls)) el.hidden = k !== name
  }

  for (const tab of tabs) {
    tab.addEventListener('click', () => {
      const name = tab.dataset.tab
      if (name) selectTab(name)
    })
  }
  // Settings
  function syncSettingsLabels() {
    // Keep controls in sync with state (presets or programmatic changes).
    els.reproRate.value = opts.reproduction.rate.toFixed(2)
    els.decompYield.value = String(opts.decomposition.yield)
    els.mutationRate.value = opts.genetics.mutationRate.toFixed(2)

    els.geneBudget.value = opts.genetics.budget.toFixed(2)
    els.metabolism.value = opts.energy.metabolism.toFixed(2)
    els.predSatiation.value = opts.reproduction.predatorSatiationSeconds.toFixed(2)
    els.predHunger.value = opts.reproduction.predatorHungerThreshold.toFixed(2)

    els.simSpeed.value = opts.simSpeed.toFixed(1)

    els.reproRateValue.textContent = opts.reproduction.rate.toFixed(2)
    els.decompYieldValue.textContent = String(opts.decomposition.yield)
    els.mutationRateValue.textContent = opts.genetics.mutationRate.toFixed(2)

    els.geneBudgetValue.textContent = opts.genetics.budget.toFixed(2)
    els.metabolismValue.textContent = `${opts.energy.metabolism.toFixed(2)}x`
    els.predSatiationValue.textContent = `${opts.reproduction.predatorSatiationSeconds.toFixed(2)}s`
    els.predHungerValue.textContent = opts.reproduction.predatorHungerThreshold.toFixed(2)

    els.simSpeedValue.textContent = `${opts.simSpeed.toFixed(1)}x`
  }

  function bindSlider(input: HTMLInputElement, setter: (v: number) => void, parse: (s: string) => number = parseFloat) {
    input.addEventListener('input', () => {
      setter(parse(input.value))
      syncSettingsLabels()
    })
  }

  bindSlider(els.reproRate, (v) => (opts.reproduction.rate = v))
  bindSlider(
    els.decompYield,
    (v) => (opts.decomposition.yield = v),
    (s) => parseInt(s, 10),
  )
  bindSlider(els.mutationRate, (v) => (opts.genetics.mutationRate = v))
  bindSlider(els.geneBudget, (v) => (opts.genetics.budget = v))
  bindSlider(els.metabolism, (v) => (opts.energy.metabolism = v))
  bindSlider(els.predSatiation, (v) => (opts.reproduction.predatorSatiationSeconds = v))
  bindSlider(els.predHunger, (v) => (opts.reproduction.predatorHungerThreshold = v))
  bindSlider(els.simSpeed, (v) => (opts.simSpeed = v))

  els.togTrails.addEventListener('change', () => (opts.visuals.trails = els.togTrails.checked))
  els.togFov.addEventListener('change', () => (opts.visuals.fov = els.togFov.checked))
  els.togVectors.addEventListener('change', () => (opts.visuals.vectors = els.togVectors.checked))
  els.togPerception.addEventListener('change', () => (opts.visuals.perception = els.togPerception.checked))
  els.togGrid.addEventListener('change', () => (opts.visuals.grid = els.togGrid.checked))

  els.wallTop.addEventListener('change', () => (opts.walls.top = els.wallTop.checked))
  els.wallRight.addEventListener('change', () => (opts.walls.right = els.wallRight.checked))
  els.wallBottom.addEventListener('change', () => (opts.walls.bottom = els.wallBottom.checked))
  els.wallLeft.addEventListener('change', () => (opts.walls.left = els.wallLeft.checked))

  let paused = false
  els.btnPause.addEventListener('click', () => {
    paused = !paused
    els.btnPause.textContent = paused ? 'Play' : 'Pause'
  })

  els.btnClear.addEventListener('click', () => {
    applyPresetBalancedFromSeed(undefined)
  })

  // Presets
  function applyPresetBalancedFromSeed(seed?: number) {
    beginPreset()

    const rng = seed != null ? seededRandom(seed) : undefined

    // 30 herbivores, 5 predators, 8 scavengers, 15 food
    for (let i = 0; i < 15; i++) spawnFood(rand(20, simW - 20), rand(20, simH - 20))

    for (let i = 0; i < 30; i++) spawnBoid('herbivore', rand(0, simW), rand(0, simH), rng ? randomGenes(rng) : undefined)
    for (let i = 0; i < 5; i++) spawnBoid('predator', rand(0, simW), rand(0, simH), rng ? randomGenes(rng) : undefined)
    for (let i = 0; i < 8; i++) spawnBoid('scavenger', rand(0, simW), rand(0, simH), rng ? randomGenes(rng) : undefined)

    const note = seed != null ? `Seed: ${seed}` : ''
    els.seedNote.textContent = note
  }

  function applyPresetGenesis() {
    beginPreset()
    for (let i = 0; i < 5; i++) spawnFood(rand(20, simW - 20), rand(20, simH - 20))

    els.seedNote.textContent = ''
  }

  function applyPresetPredatorParadise() {
    beginPreset()
    for (let i = 0; i < 30; i++) spawnFood(rand(20, simW - 20), rand(20, simH - 20))
    for (let i = 0; i < 100; i++) spawnBoid('herbivore', rand(0, simW), rand(0, simH))
    for (let i = 0; i < 3; i++) spawnBoid('predator', rand(0, simW), rand(0, simH))
    for (let i = 0; i < 15; i++) spawnBoid('scavenger', rand(0, simW), rand(0, simH))

    els.seedNote.textContent = ''
  }

  function applyPresetHerbBloom() {
    beginPreset()

    // Lots of food + herbivores, a few scavengers, almost no predators.
    for (let i = 0; i < 120; i++) spawnFood(rand(20, simW - 20), rand(20, simH - 20))

    for (let i = 0; i < 160; i++) spawnBoid('herbivore', rand(0, simW), rand(0, simH))
    for (let i = 0; i < 18; i++) spawnBoid('scavenger', rand(0, simW), rand(0, simH))
    for (let i = 0; i < 2; i++) spawnBoid('predator', rand(0, simW), rand(0, simH))

    els.seedNote.textContent = ''
  }

  function applyPresetScavFeast() {
    beginPreset()

    // Start with lots of carrion to create an immediate scavenger economy.
    for (let i = 0; i < 30; i++) {
      carrion.push({ x: rand(20, simW - 20), y: rand(20, simH - 20), mass: 0.9 + Math.random() * 1.4, age: 0 })
    }

    for (let i = 0; i < 40; i++) spawnFood(rand(20, simW - 20), rand(20, simH - 20))

    for (let i = 0; i < 40; i++) spawnBoid('herbivore', rand(0, simW), rand(0, simH))
    for (let i = 0; i < 80; i++) spawnBoid('scavenger', rand(0, simW), rand(0, simH))
    for (let i = 0; i < 6; i++) spawnBoid('predator', rand(0, simW), rand(0, simH))

    els.seedNote.textContent = ''
  }

  function applyPresetMegaswarm() {
    beginPreset()

    // Big populations tuned for spectacle.
    // Trails can be expensive; consider disabling them if FPS dips.
    for (let i = 0; i < 140; i++) spawnFood(rand(20, simW - 20), rand(20, simH - 20))

    for (let i = 0; i < 420; i++) spawnBoid('herbivore', rand(0, simW), rand(0, simH))
    for (let i = 0; i < 40; i++) spawnBoid('predator', rand(0, simW), rand(0, simH))
    for (let i = 0; i < 80; i++) spawnBoid('scavenger', rand(0, simW), rand(0, simH))

    els.seedNote.textContent = ''
  }

  function applyPresetExtinctionEvent() {
    beginPreset()
    for (let i = 0; i < 10; i++) spawnFood(rand(20, simW - 20), rand(20, simH - 20))
    for (let i = 0; i < 30; i++) spawnBoid('herbivore', rand(0, simW), rand(0, simH))
    for (let i = 0; i < 20; i++) spawnBoid('predator', rand(0, simW), rand(0, simH))
    for (let i = 0; i < 5; i++) spawnBoid('scavenger', rand(0, simW), rand(0, simH))

    els.seedNote.textContent = ''
  }

  function applyPresetEvolutionLab() {
    beginPreset()
    const rng = seededRandom(Math.floor(Math.random() * 1000000))

    for (let i = 0; i < 25; i++) spawnFood(rand(20, simW - 20), rand(20, simH - 20))

    // Wide variance + 2x mutation rate
    opts.genetics.mutationRate = clamp(defaultOpts.genetics.mutationRate * 2, 0.05, 0.25)

    for (let i = 0; i < 50; i++) spawnBoid('herbivore', rand(0, simW), rand(0, simH), genesForEvolutionLab(rng))
    for (let i = 0; i < 10; i++) spawnBoid('predator', rand(0, simW), rand(0, simH), genesForEvolutionLab(rng))
    for (let i = 0; i < 15; i++) spawnBoid('scavenger', rand(0, simW), rand(0, simH), genesForEvolutionLab(rng))

    syncSettingsLabels()
    els.seedNote.textContent = 'Evolution Lab: wide genes + higher mutation'
  }

  els.presetBalanced.addEventListener('click', () => applyPresetBalancedFromSeed(undefined))
  els.presetGenesis.addEventListener('click', applyPresetGenesis)
  els.presetHerbBloom.addEventListener('click', applyPresetHerbBloom)
  els.presetScavFeast.addEventListener('click', applyPresetScavFeast)
  els.presetPredator.addEventListener('click', applyPresetPredatorParadise)
  els.presetExtinction.addEventListener('click', applyPresetExtinctionEvent)
  els.presetMegaswarm.addEventListener('click', applyPresetMegaswarm)
  els.presetEvolutionLab.addEventListener('click', applyPresetEvolutionLab)

  els.btnRandomSeed.addEventListener('click', () => {
    els.seedInput.value = String(Math.floor(Math.random() * 1000000))
  })

  els.btnApplySeed.addEventListener('click', () => {
    const seed = parseInt(els.seedInput.value, 10)
    if (Number.isFinite(seed)) applyPresetBalancedFromSeed(seed)
  })

  // Performance banner actions (stub)
  els.btnReduce.addEventListener('click', () => {
    boids = boids.filter((_, i) => i % 2 === 0)
    els.perfBanner.hidden = true
  })

  els.btnDisableTrails.addEventListener('click', () => {
    opts.visuals.trails = false
    els.togTrails.checked = false
    els.perfBanner.hidden = true
  })

  els.btnDismiss.addEventListener('click', () => {
    els.perfBanner.hidden = true
  })

  // Pointer interactions: tap and long-press cluster
  let pressTimer: number | null = null
  let clusterTimer: number | null = null
  let pressPoint: { x: number; y: number } | null = null
  let clusterCount = 0
  let clusterProgress = 0

  function getCanvasPoint(e: PointerEvent): { x: number; y: number } {
    const rect = els.canvas.getBoundingClientRect()
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top,
    }
  }

  function startCluster(point: { x: number; y: number }) {
    clusterCount = 1
    clusterProgress = 0
    clusterTimer = window.setInterval(() => {
      clusterCount = Math.min(20, clusterCount + 1)
      clusterProgress = clusterCount / 20
    }, 100)
  }

  function flushCluster(point: { x: number; y: number }) {
    const n = clusterCount
    for (let i = 0; i < n; i++) {
      const a = Math.random() * Math.PI * 2
      const r = Math.random() * 12
      spawnBoid(selectedSpecies, point.x + Math.cos(a) * r, point.y + Math.sin(a) * r)
    }
    clusterProgress = 0
  }

  function onPointerMove(e: PointerEvent) {
    if (!pressPoint) return
    pressPoint = getCanvasPoint(e)
  }

  function endPointerInteraction() {
    if (pressTimer) window.clearTimeout(pressTimer)
    pressTimer = null

    const hadCluster = clusterTimer != null
    if (clusterTimer) window.clearInterval(clusterTimer)
    clusterTimer = null

    if (hadCluster && pressPoint) {
      flushCluster(pressPoint)
    }

    clusterCount = 0
    clusterProgress = 0
    pressPoint = null

    els.canvas.removeEventListener('pointermove', onPointerMove)
  }

  els.canvas.addEventListener('pointerdown', (e) => {
    els.canvas.setPointerCapture(e.pointerId)
    pressPoint = getCanvasPoint(e)

    clusterCount = 1
    clusterProgress = 0

    // Tap spawns immediately; hold accumulates additional ones.
    spawnBoid(selectedSpecies, pressPoint.x, pressPoint.y)

    pressTimer = window.setTimeout(() => {
      if (!pressPoint) return
      startCluster(pressPoint)
    }, 250)

    els.canvas.addEventListener('pointermove', onPointerMove)
  })

  els.canvas.addEventListener('pointerup', endPointerInteraction)
  els.canvas.addEventListener('pointercancel', endPointerInteraction)

  // --- Main loop ---

  let lastT = performance.now()
  let fpsSmoothed = 60
  let lowFpsStart: number | null = null

  const neighborScratch: number[] = []

  function maxSpeedForBoid(b: Boid): number {
    return opts.boids.baseMaxSpeed[b.species] * b.genes.speed * mobilityScaleForBoid(b)
  }

  function maxForceForBoid(b: Boid): number {
    return opts.boids.baseMaxForce[b.species] * (0.8 + 0.4 * b.genes.speed) * mobilityScaleForBoid(b)
  }

  function perceptionForBoid(b: Boid): number {
    return opts.boids.perception[b.species] * b.genes.perception
  }

  function fovForBoid(b: Boid): number {
    return (opts.boids.fov[b.species] * Math.PI) / 180 / 2
  }

  function separationRadiusForBoid(b: Boid): number {
    return opts.boids.separation[b.species]
  }

  function drainPerSecondForBoid(b: Boid): number {
    const base = b.species === 'predator' ? opts.energy.predatorDrain : b.species === 'scavenger' ? opts.energy.scavengerDrain : opts.energy.herbivoreDrain

    // Movement cost: faster movement drains more.
    const speedNow = len({ x: b.vx, y: b.vy })
    const speedMax = Math.max(1, maxSpeedForBoid(b))
    const speedRatio = clamp(speedNow / speedMax, 0, 1)

    // efficiency stretches energy (lower drain), but speed fights it
    const movementMultiplier = 0.75 + 1.1 * speedRatio * speedRatio

    return ((base * movementMultiplier) / b.genes.efficiency) * opts.energy.metabolism
  }

  function predatorBiteDamage(predator: Boid, prey: Boid): number {
    const maturity = maturityForBoid(prey)
    const health = clamp(prey.energy / Math.max(1, prey.maxEnergy), 0, 1)

    // Tougher prey (older + healthier) takes more bites.
    const toughness = clamp(0.65 + 0.75 * maturity + 0.45 * health, 0.65, 1.85)
    const baseDamage = 55

    // Predator efficiency converts to stronger bites.
    const scaled = baseDamage * (1.85 / toughness) * (0.85 + 0.3 * predator.genes.efficiency)
    return clamp(scaled, 18, 120)
  }

  function predatorBiteEnergyGain(predator: Boid, prey: Boid, damage: number): number {
    const ratio = clamp(damage / Math.max(1, prey.maxEnergy), 0, 1)
    return opts.energy.eatHerbivoreGain * ratio * predator.genes.efficiency
  }

  function applyBounds(b: Boid) {
    const pad = 1

    if (opts.walls.left) {
      if (b.x < pad) {
        b.x = pad
        b.vx = Math.abs(b.vx)
      }
    } else if (b.x < 0) {
      b.x += simW
    }

    if (opts.walls.right) {
      if (b.x > simW - pad) {
        b.x = simW - pad
        b.vx = -Math.abs(b.vx)
      }
    } else if (b.x > simW) {
      b.x -= simW
    }

    if (opts.walls.top) {
      if (b.y < pad) {
        b.y = pad
        b.vy = Math.abs(b.vy)
      }
    } else if (b.y < 0) {
      b.y += simH
    }

    if (opts.walls.bottom) {
      if (b.y > simH - pad) {
        b.y = simH - pad
        b.vy = -Math.abs(b.vy)
      }
    } else if (b.y > simH) {
      b.y -= simH
    }
  }

  function inFov(b: Boid, dx: number, dy: number): boolean {
    const ang = Math.atan2(dy, dx)
    const d = Math.abs(angleDelta(ang, b.dir))
    return d <= fovForBoid(b)
  }

  function steerToward(b: Boid, tx: number, ty: number, weight: number): Vec {
    const dx = tx - b.x
    const dy = ty - b.y
    if (dx === 0 && dy === 0) return { x: 0, y: 0 }

    const desired = normalize({ x: dx, y: dy })
    const desiredV = { x: desired.x * maxSpeedForBoid(b), y: desired.y * maxSpeedForBoid(b) }
    const steer = { x: desiredV.x - b.vx, y: desiredV.y - b.vy }
    const limited = clampLen(steer, maxForceForBoid(b))
    return { x: limited.x * weight, y: limited.y * weight }
  }

  function steerAway(b: Boid, fx: number, fy: number, weight: number): Vec {
    const dx = b.x - fx
    const dy = b.y - fy
    if (dx === 0 && dy === 0) return { x: 0, y: 0 }
    const desired = normalize({ x: dx, y: dy })
    const desiredV = { x: desired.x * maxSpeedForBoid(b), y: desired.y * maxSpeedForBoid(b) }
    const steer = { x: desiredV.x - b.vx, y: desiredV.y - b.vy }
    const limited = clampLen(steer, maxForceForBoid(b))
    return { x: limited.x * weight, y: limited.y * weight }
  }

  function addParticle(x: number, y: number, color: string) {
    const count = 6
    for (let i = 0; i < count; i++) {
      const a = Math.random() * Math.PI * 2
      const s = 40 + Math.random() * 80
      particles.push({ x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s, life: 0.35 + Math.random() * 0.35, color, size: 1.2 + Math.random() * 1.8 })
    }
  }

  function updateParticles(dtSeconds: number) {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i]
      p.life -= dtSeconds
      if (p.life <= 0) {
        particles.splice(i, 1)
        continue
      }
      p.x += p.vx * dtSeconds
      p.y += p.vy * dtSeconds
      p.vx *= 0.92
      p.vy *= 0.92
    }
  }

  function removeIndicesInPlace<T>(arr: T[], toRemove: Set<number>) {
    if (toRemove.size === 0) return

    let w = 0
    for (let i = 0; i < arr.length; i++) {
      if (toRemove.has(i)) continue
      arr[w] = arr[i]
      w++
    }
    arr.length = w
  }

  function findNearestIndex<T extends { x: number; y: number }>(
    grid: SpatialGrid,
    arr: T[],
    fromX: number,
    fromY: number,
    queryRadius: number,
    ignore?: Set<number>,
  ): { index: number; d2: number } | null {
    neighborScratch.length = 0
    grid.query(fromX, fromY, queryRadius, neighborScratch)

    let bestIndex = -1
    let bestD2 = Infinity

    for (const i of neighborScratch) {
      if (ignore?.has(i)) continue
      const o = arr[i]
      if (!o) continue
      const d2 = distSq(fromX, fromY, o.x, o.y)
      if (d2 < bestD2) {
        bestD2 = d2
        bestIndex = i
      }
    }

    return bestIndex >= 0 ? { index: bestIndex, d2: bestD2 } : null
  }

  function update(dtSeconds: number) {
    // rebuild grids (indices must remain stable within this tick)
    boidGrid.clear()
    foodGrid.clear()
    carrionGrid.clear()

    for (let i = 0; i < boids.length; i++) boidGrid.insert(boids[i].x, boids[i].y, i)
    for (let i = 0; i < food.length; i++) foodGrid.insert(food[i].x, food[i].y, i)
    for (let i = 0; i < carrion.length; i++) carrionGrid.insert(carrion[i].x, carrion[i].y, i)

    const boidsToRemove = new Set<number>()
    const foodToRemove = new Set<number>()
    const carrionToRemove = new Set<number>()

    // food growth
    const expectedFood = opts.world.foodSpawnRate * dtSeconds
    if (Math.random() < expectedFood) {
      spawnFood(rand(20, simW - 20), rand(20, simH - 20))
    }

    // carrion decay -> food (decomposition)
    for (let i = 0; i < carrion.length; i++) {
      if (carrionToRemove.has(i)) continue
      const c = carrion[i]
      if (!c) continue

      c.age += dtSeconds
      if (c.age > opts.world.carrionDecaySeconds) {
        carrionToRemove.add(i)
        spawnDecompositionFood(c.x, c.y)
      }
    }

    // boids step
    for (let i = 0; i < boids.length; i++) {
      if (boidsToRemove.has(i)) continue
      const b = boids[i]
      if (!b) continue

      b.age += dtSeconds
      b.cooldown.eat = Math.max(0, b.cooldown.eat - dtSeconds)
      b.cooldown.reproduce = Math.max(0, b.cooldown.reproduce - dtSeconds)
      b.cooldown.hunt = Math.max(0, b.cooldown.hunt - dtSeconds)

      // eating interactions (simple)
      if (b.cooldown.eat <= 0) {
        if (b.species === 'herbivore') {
          const nearest = findNearestIndex(foodGrid, food, b.x, b.y, opts.interaction.herbivoreEatQueryRadius, foodToRemove)
          if (nearest && nearest.d2 < opts.interaction.herbivoreEatRadius * opts.interaction.herbivoreEatRadius) {
            const f = food[nearest.index]
            if (f) {
              foodToRemove.add(nearest.index)
              b.energy = clamp(b.energy + opts.energy.eatFoodGain * b.genes.efficiency, 0, b.maxEnergy)
              b.cooldown.eat = 0.25
              addParticle(f.x, f.y, opts.colors.herbivore)
            }
          }
        } else if (b.species === 'predator') {
          neighborScratch.length = 0
          boidGrid.query(b.x, b.y, opts.interaction.predatorAttackQueryRadius, neighborScratch)

          let killIndex = -1
          let killD2 = Infinity

          for (const bi of neighborScratch) {
            if (bi === i) continue
            if (boidsToRemove.has(bi)) continue
            const o = boids[bi]
            if (!o || o.species !== 'herbivore') continue
            const d2 = distSq(b.x, b.y, o.x, o.y)
            if (d2 < killD2) {
              killD2 = d2
              killIndex = bi
            }
          }

          if (killIndex >= 0 && killD2 < opts.interaction.predatorAttackRadius * opts.interaction.predatorAttackRadius) {
            const prey = boids[killIndex]
            if (prey && !boidsToRemove.has(killIndex)) {
              const damage = predatorBiteDamage(b, prey)
              prey.energy -= damage

              b.energy = clamp(b.energy + predatorBiteEnergyGain(b, prey, damage), 0, b.maxEnergy)
              b.cooldown.eat = 1

              addParticle(prey.x, prey.y, opts.colors.predator)

              if (prey.energy <= 0) {
                boidsToRemove.add(killIndex)
                counters.hunts++
                counters.deaths++
                carrion.push({ x: prey.x, y: prey.y, mass: 1.1, age: 0 })

                // satiation: briefly stop pursuing new prey
                b.cooldown.hunt = opts.reproduction.predatorSatiationSeconds
              }
            }
          }
        } else if (b.species === 'scavenger') {
          const nearest = findNearestIndex(carrionGrid, carrion, b.x, b.y, opts.interaction.scavengerEatQueryRadius, carrionToRemove)
          if (nearest && nearest.d2 < opts.interaction.scavengerEatRadius * opts.interaction.scavengerEatRadius) {
            const c = carrion[nearest.index]
            if (c && !carrionToRemove.has(nearest.index)) {
              const take = Math.min(c.mass, opts.interaction.carrionTakeAmount)
              c.mass -= take
              b.energy = clamp(b.energy + take * opts.interaction.carrionEnergyMultiplier * b.genes.efficiency, 0, b.maxEnergy)
              b.cooldown.eat = 0.3
              addParticle(c.x, c.y, opts.colors.scavenger)
              if (c.mass <= opts.interaction.carrionDepletionThreshold) {
                carrionToRemove.add(nearest.index)
                spawnDecompositionFood(c.x, c.y)
              }
            }
          }
        }
      }

      // reproduction
      if (shouldReproduce(b, dtSeconds)) {
        const mateIndex = findMateIndex(i, b, boidsToRemove)
        if (mateIndex != null) {
          const mate = boids[mateIndex]
          if (mate) {
            // Only create one child per pair per tick
            if (i < mateIndex) {
              spawnChildFromParents(b, mate)
            }
          }
        } else {
          spawnChildFromParent(b)
        }
      }

      // energy drain
      b.energy -= drainPerSecondForBoid(b) * dtSeconds

      if (b.energy <= 0) {
        // death -> carrion
        counters.deaths++
        const mass = b.species === 'predator' ? 2.1 : b.species === 'scavenger' ? 1.4 : 1.1
        carrion.push({ x: b.x, y: b.y, mass, age: 0 })
        addParticle(b.x, b.y, opts.colors.dead)
        boidsToRemove.add(i)
        continue
      }

      // neighborhood
      neighborScratch.length = 0
      const pr = perceptionForBoid(b)
      boidGrid.query(b.x, b.y, pr, neighborScratch)

      const prevDir = b.dir
      let sepX = 0
      let sepY = 0
      let aliX = 0
      let aliY = 0
      let cohX = 0
      let cohY = 0
      let neighborCount = 0

      const sepR = separationRadiusForBoid(b)
      const sepRSq = sepR * sepR

      let fleeX = 0
      let fleeY = 0

      let chaseTargetX = 0
      let chaseTargetY = 0
      let chaseTargetD2 = Infinity
      let hasChase = false

      const predatorHuntEnabled = b.species === 'predator' && b.cooldown.hunt <= 0 && b.energy < b.maxEnergy * opts.reproduction.predatorHungerThreshold

      for (const j of neighborScratch) {
        if (j === i) continue
        if (boidsToRemove.has(j)) continue
        const o = boids[j]
        if (!o) continue

        const d2 = distSq(b.x, b.y, o.x, o.y)
        if (d2 > pr * pr) continue

        const dx = o.x - b.x
        const dy = o.y - b.y
        if (!inFov(b, dx, dy)) continue

        neighborCount++
        aliX += o.vx
        aliY += o.vy
        cohX += o.x
        cohY += o.y

        if (d2 < sepRSq) {
          const inv = 1 / Math.max(1e-6, d2)
          sepX -= dx * inv
          sepY -= dy * inv
        }

        if ((b.species === 'herbivore' || b.species === 'scavenger') && o.species === 'predator') {
          const s = 1 / Math.max(1e-6, d2)
          fleeX -= dx * s
          fleeY -= dy * s
        }

        if (predatorHuntEnabled && o.species === 'herbivore') {
          // chase nearest herbivore
          if (d2 < chaseTargetD2) {
            chaseTargetD2 = d2
            chaseTargetX = o.x
            chaseTargetY = o.y
            hasChase = true
          }
        }
      }

      const steer: Vec = { x: 0, y: 0 }

      if (neighborCount > 0) {
        // alignment
        const ali = normalize({ x: aliX / neighborCount, y: aliY / neighborCount })
        steer.x += (ali.x * maxSpeedForBoid(b) - b.vx) * opts.boids.alignment[b.species]
        steer.y += (ali.y * maxSpeedForBoid(b) - b.vy) * opts.boids.alignment[b.species]

        // cohesion
        const center = { x: cohX / neighborCount, y: cohY / neighborCount }
        const coh = steerToward(b, center.x, center.y, opts.boids.cohesion[b.species])
        steer.x += coh.x
        steer.y += coh.y

        // separation
        const sep = normalize({ x: sepX, y: sepY })
        steer.x += sep.x * maxSpeedForBoid(b) * 0.55
        steer.y += sep.y * maxSpeedForBoid(b) * 0.55
      }

      // species-specific goals
      if (b.species === 'herbivore') {
        // forage toward nearest food
        const nearestFood = findNearestIndex(foodGrid, food, b.x, b.y, pr * 1.25, foodToRemove)
        if (nearestFood) {
          const f = food[nearestFood.index]
          if (f) {
            const v = steerToward(b, f.x, f.y, opts.boids.forage.herbivore)
            steer.x += v.x
            steer.y += v.y
          }
        }

        // flee from predators (panic scales with age + health)
        const flee = normalize({ x: fleeX, y: fleeY })
        const panicBase = clamp(len({ x: fleeX, y: fleeY }) * 2.2, 0, 1)
        const maturity = maturityForBoid(b)
        const health = clamp(b.energy / Math.max(1, b.maxEnergy), 0, 1)
        const panic = clamp(panicBase * (1.15 - 0.25 * maturity) * (1.25 - 0.55 * health), 0, 1.45)
        const fleeWeight = opts.boids.flee.herbivore * (1 + 1.35 * panic)
        steer.x += flee.x * maxSpeedForBoid(b) * fleeWeight
        steer.y += flee.y * maxSpeedForBoid(b) * fleeWeight
      } else if (b.species === 'predator') {
        if (hasChase) {
          const v = steerToward(b, chaseTargetX, chaseTargetY, opts.boids.chase.predator)
          steer.x += v.x
          steer.y += v.y
        }
      } else if (b.species === 'scavenger') {
        // scavenge toward nearest carrion
        const nearestCarrion = findNearestIndex(carrionGrid, carrion, b.x, b.y, pr * 1.25, carrionToRemove)
        if (nearestCarrion) {
          const c = carrion[nearestCarrion.index]
          if (c) {
            const v = steerToward(b, c.x, c.y, opts.boids.scavenge.scavenger)
            steer.x += v.x
            steer.y += v.y
          }
        }

        // mild avoidance of predators
        const flee = normalize({ x: fleeX, y: fleeY })
        steer.x += flee.x * maxSpeedForBoid(b) * opts.boids.flee.scavenger
        steer.y += flee.y * maxSpeedForBoid(b) * opts.boids.flee.scavenger
      }

      // wander (deterministic-ish)
      const w = opts.boids.wander[b.species]
      steer.x += (Math.cos(b.dir + Math.sin(b.age * 0.7)) * maxSpeedForBoid(b) - b.vx) * w
      steer.y += (Math.sin(b.dir + Math.cos(b.age * 0.8)) * maxSpeedForBoid(b) - b.vy) * w

      // integrate
      const accel = clampLen(steer, maxForceForBoid(b))
      b.vx += accel.x * dtSeconds
      b.vy += accel.y * dtSeconds

      const v = clampLen({ x: b.vx, y: b.vy }, maxSpeedForBoid(b))
      b.vx = v.x
      b.vy = v.y

      b.x += b.vx * dtSeconds
      b.y += b.vy * dtSeconds

      b.dir = heading(b.vx, b.vy)
      if (lenSq(v) < 0.0001) b.dir = prevDir

      applyBounds(b)

      if (opts.visuals.trails) {
        b.trail.push({ x: b.x, y: b.y })
      } else {
        b.trail.clear()
      }
    }

    removeIndicesInPlace(food, foodToRemove)
    removeIndicesInPlace(carrion, carrionToRemove)
    removeIndicesInPlace(boids, boidsToRemove)

    if (food.length > opts.world.foodMax) food.splice(0, food.length - opts.world.foodMax)
    if (carrion.length > opts.world.carrionMax) carrion.splice(0, carrion.length - opts.world.carrionMax)

    updateParticles(dtSeconds)
  }

  function syncStats() {
    let herb = 0
    let pred = 0
    let scav = 0
    for (const b of boids) {
      if (b.species === 'herbivore') herb++
      else if (b.species === 'predator') pred++
      else scav++
    }

    els.herb.textContent = String(herb)
    els.pred.textContent = String(pred)
    els.scav.textContent = String(scav)
    els.food.textContent = String(food.length)
    els.carrion.textContent = String(carrion.length)

    els.births.textContent = String(counters.births)
    els.deaths.textContent = String(counters.deaths)
    els.hunts.textContent = String(counters.hunts)
    els.decomp.textContent = String(counters.decomp)

    els.fps.textContent = fpsSmoothed.toFixed(0)
  }

  function tick(now: number) {
    const dt = Math.min(0.05, (now - lastT) / 1000)
    lastT = now

    const fps = 1 / Math.max(1e-6, dt)
    fpsSmoothed = fpsSmoothed * 0.9 + fps * 0.1

    if (!paused) {
      update(dt * opts.simSpeed)
    }

    draw()
    syncStats()

    // Perf warning: <20 fps for 3s
    if (fpsSmoothed < 20) {
      if (lowFpsStart == null) lowFpsStart = now
      if (now - lowFpsStart > 3000) {
        els.perfText.textContent = `Low performance detected (${fpsSmoothed.toFixed(0)} fps). Consider reducing population or disabling trails.`
        els.perfBanner.hidden = false
      }
    } else {
      lowFpsStart = null
      if (!els.perfBanner.hidden) els.perfBanner.hidden = true
    }

    requestAnimationFrame(tick)
  }

  // Init
  syncSettingsLabels()
  selectTab('presets')

  // Seed from URL, if present
  const url = new URL(window.location.href)
  const seedParam = url.searchParams.get('seed')
  if (seedParam) {
    els.seedInput.value = seedParam
    const seed = parseInt(seedParam, 10)
    if (Number.isFinite(seed)) {
      applyPresetBalancedFromSeed(seed)
    } else {
      applyPresetBalancedFromSeed(undefined)
    }
  } else {
    applyPresetBalancedFromSeed(undefined)
  }

  requestAnimationFrame(tick)
</script>
