---

---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Triangulation Stipple Dithering</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet" />
    <style>
      :root {
        --font-sans: 'Nunito', sans-serif;
        --font-mono: 'ServerMono', monospace;
        --color-white: hsl(0, 0%, 92%);
        --color-gray-lighter: hsl(0, 0%, 82%);
        --color-gray-light: hsl(0, 0%, 68%);
        --color-gray: hsl(0, 0%, 54%);
        --color-gray-dark: hsl(0, 0%, 28%);
        --color-gray-darker: hsl(0, 0%, 17%);
        --color-black: hsl(0, 0%, 7%);
        --color-akira-red: #e12120;
        color-scheme: dark;
        --theme-bg: light-dark(var(--color-white), var(--color-black));
        --theme-border: light-dark(var(--color-gray-lighter), var(--color-gray-darker));
        --theme-text: light-dark(var(--color-black), var(--color-white));
        --theme-text-subtle: light-dark(var(--color-gray-darker), var(--color-gray-lighter));
        --theme-text-dim: light-dark(var(--color-gray-dark), var(--color-gray-light));
        --theme-accent: var(--color-akira-red);
        --theme-accent-light: hsl(from var(--color-akira-red) h s calc(l + 15));
        --theme-accent-dark: hsl(from var(--color-akira-red) h s calc(l - 15));
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: var(--font-sans);
        background: var(--theme-bg);
        color: var(--theme-text);
        padding: 20px;
      }

      .container {
        display: flex;
        flex-direction: column;
        gap: 20px;
        align-items: center;
        width: 100%;
        max-width: 1800px;
        margin: 0 auto;
      }

      .canvases {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
        justify-content: center;
      }

      canvas {
        border: 2px solid var(--theme-border);
        border-radius: 8px;
        max-width: 100%;
        height: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }

      .controls {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: center;
      }

      button {
        background: var(--theme-accent);
        color: var(--color-white);
        border: none;
        padding: 10px 20px;
        border-radius: 6px;
        font-family: var(--font-sans);
        font-size: 14px;
        cursor: pointer;
        transition: background 0.2s;
      }

      button:hover {
        background: var(--theme-accent-light);
      }

      button:active {
        background: var(--theme-accent-dark);
      }

      input[type='file'] {
        display: none;
      }

      label {
        color: var(--theme-text-subtle);
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      input[type='range'] {
        width: 150px;
      }

      .info {
        color: var(--theme-text-dim);
        font-size: 13px;
        text-align: center;
      }

      .file-label {
        background: var(--theme-accent);
        color: var(--color-white);
        padding: 10px 20px;
        border-radius: 6px;
        font-family: var(--font-sans);
        font-size: 14px;
        cursor: pointer;
        transition: background 0.2s;
      }

      .file-label:hover {
        background: var(--theme-accent-light);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="canvases">
        <canvas id="sourceCanvas" width="800" height="800"></canvas>
        <canvas id="outputCanvas" width="800" height="800"></canvas>
      </div>

      <div class="controls">
        <label class="file-label">
          Upload Image
          <input type="file" id="fileInput" accept="image/*" />
        </label>
        <button id="regenerate">Generate</button>
        <label>
          Grid Size:
          <input type="range" id="gridSize" min="8" max="64" value="24" step="4" />
          <span id="gridSizeValue">24</span>
        </label>
        <label>
          Subdivisions:
          <input type="range" id="subdivisions" min="2" max="8" value="5" step="1" />
          <span id="subdivisionsValue">5</span>
        </label>
        <label>
          Dot Size:
          <input type="range" id="dotSize" min="0.3" max="3" value="1.2" step="0.1" />
          <span id="dotSizeValue">1.2</span>
        </label>
      </div>

      <div class="info">Region-based triangulation stippling â€” segments image by brightness, then stipples each region</div>
    </div>

    <script>
      const sourceCanvas = document.getElementById('sourceCanvas')
      const outputCanvas = document.getElementById('outputCanvas')
      const sourceCtx = sourceCanvas.getContext('2d')
      const outputCtx = outputCanvas.getContext('2d')
      const fileInput = document.getElementById('fileInput')
      const gridSizeSlider = document.getElementById('gridSize')
      const gridSizeValue = document.getElementById('gridSizeValue')
      const subdivisionsSlider = document.getElementById('subdivisions')
      const subdivisionsValue = document.getElementById('subdivisionsValue')
      const dotSizeSlider = document.getElementById('dotSize')
      const dotSizeValue = document.getElementById('dotSizeValue')
      const regenerateBtn = document.getElementById('regenerate')

      let gridSize = parseInt(gridSizeSlider.value)
      let maxSubdivisions = parseInt(subdivisionsSlider.value)
      let dotSize = parseFloat(dotSizeSlider.value)
      let sourceImage = null
      let imageData = null
      let dots = []

      // Calculate centroid of three points
      function centroid(p1, p2, p3) {
        return {
          x: (p1.x + p2.x + p3.x) / 3,
          y: (p1.y + p2.y + p3.y) / 3,
        }
      }

      // Calculate distance between two points
      function distance(p1, p2) {
        return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2)
      }

      // Get brightness at a point (0 = black, 1 = white)
      function getBrightness(x, y) {
        if (!imageData) return 0.5

        const ix = Math.floor(x)
        const iy = Math.floor(y)

        if (ix < 0 || ix >= sourceCanvas.width || iy < 0 || iy >= sourceCanvas.height) {
          return 1
        }

        const index = (iy * sourceCanvas.width + ix) * 4
        const r = imageData.data[index]
        const g = imageData.data[index + 1]
        const b = imageData.data[index + 2]

        // Convert to grayscale
        return (r + g + b) / (3 * 255)
      }

      // Get average brightness of a region
      function getRegionBrightness(x, y, w, h) {
        let total = 0
        let count = 0
        const step = 2

        for (let dy = 0; dy < h; dy += step) {
          for (let dx = 0; dx < w; dx += step) {
            total += getBrightness(x + dx, y + dy)
            count++
          }
        }

        return count > 0 ? total / count : 0.5
      }

      // Recursive stippling within a bounded region
      function stippleRegion(p1, p2, p3, depth, maxDepth, regionBrightness) {
        const avgDist = (distance(p1, p2) + distance(p2, p3) + distance(p3, p1)) / 3
        if (avgDist < 2) return

        const center = centroid(p1, p2, p3)

        // If we've reached max depth or triangle is small enough, place dot and stop
        if (depth >= maxDepth) {
          const darkness = 1 - regionBrightness
          if (darkness > 0.1) {
            const opacity = 0.5 + darkness * 0.5
            dots.push({
              x: center.x,
              y: center.y,
              opacity: opacity,
              size: dotSize,
            })
          }
          return
        }

        // Otherwise, recurse into three new triangles without placing a dot here
        stippleRegion(p1, p2, center, depth + 1, maxDepth, regionBrightness)
        stippleRegion(p2, p3, center, depth + 1, maxDepth, regionBrightness)
        stippleRegion(p3, p1, center, depth + 1, maxDepth, regionBrightness)
      }

      function generate() {
        if (!sourceImage) return

        dots = []

        // Clear output canvas
        outputCtx.fillStyle = '#ebebeb'
        outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height)

        const w = outputCanvas.width
        const h = outputCanvas.height

        const cellW = w / gridSize
        const cellH = h / gridSize

        // Divide canvas into grid and analyze each cell
        for (let row = 0; row < gridSize; row++) {
          for (let col = 0; col < gridSize; col++) {
            const x = col * cellW
            const y = row * cellH

            // Get average brightness of this cell
            const brightness = getRegionBrightness(x, y, cellW, cellH)
            const darkness = 1 - brightness

            // Determine subdivision depth based on darkness
            // Darker regions get MORE subdivisions (more dots)
            // Light regions get FEWER subdivisions (fewer dots)
            const subdivDepth = Math.max(1, Math.floor(darkness * maxSubdivisions))

            // Create initial triangle for this cell
            const topLeft = { x: x, y: y }
            const topRight = { x: x + cellW, y: y }
            const bottomLeft = { x: x, y: y + cellH }
            const bottomRight = { x: x + cellW, y: y + cellH }
            const center = { x: x + cellW / 2, y: y + cellH / 2 }

            // Stipple this cell with triangulation
            stippleRegion(topLeft, topRight, center, 0, subdivDepth, brightness)
            stippleRegion(topRight, bottomRight, center, 0, subdivDepth, brightness)
            stippleRegion(bottomRight, bottomLeft, center, 0, subdivDepth, brightness)
            stippleRegion(bottomLeft, topLeft, center, 0, subdivDepth, brightness)
          }
        }

        console.log(`Generated ${dots.length} dots`)

        // Draw all dots
        dots.forEach((dot) => {
          outputCtx.fillStyle = `rgba(18, 18, 18, ${dot.opacity})`
          outputCtx.beginPath()
          outputCtx.arc(dot.x, dot.y, dot.size, 0, Math.PI * 2)
          outputCtx.fill()
        })
      }

      function loadImage(file) {
        const reader = new FileReader()
        reader.onload = (e) => {
          const img = new Image()
          img.onload = () => {
            sourceImage = img

            // Draw source image
            sourceCtx.fillStyle = '#ebebeb'
            sourceCtx.fillRect(0, 0, sourceCanvas.width, sourceCanvas.height)

            const scale = Math.min(sourceCanvas.width / img.width, sourceCanvas.height / img.height)
            const w = img.width * scale
            const h = img.height * scale
            const x = (sourceCanvas.width - w) / 2
            const y = (sourceCanvas.height - h) / 2

            sourceCtx.drawImage(img, x, y, w, h)

            // Get image data for brightness sampling
            imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height)

            generate()
          }
          img.src = e.target.result
        }
        reader.readAsDataURL(file)
      }

      fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          loadImage(e.target.files[0])
        }
      })

      gridSizeSlider.addEventListener('input', (e) => {
        gridSize = parseInt(e.target.value)
        gridSizeValue.textContent = gridSize
        if (sourceImage) generate()
      })

      subdivisionsSlider.addEventListener('input', (e) => {
        maxSubdivisions = parseInt(e.target.value)
        subdivisionsValue.textContent = maxSubdivisions
        if (sourceImage) generate()
      })

      dotSizeSlider.addEventListener('input', (e) => {
        dotSize = parseFloat(e.target.value)
        dotSizeValue.textContent = dotSize
        if (sourceImage) generate()
      })

      regenerateBtn.addEventListener('click', () => {
        if (sourceImage) generate()
      })

      // Load a default gradient to demonstrate
      function createDefaultImage() {
        sourceCtx.fillStyle = '#ebebeb'
        sourceCtx.fillRect(0, 0, sourceCanvas.width, sourceCanvas.height)

        // Create a circular gradient
        const gradient = sourceCtx.createRadialGradient(
          sourceCanvas.width / 2,
          sourceCanvas.height / 2,
          50,
          sourceCanvas.width / 2,
          sourceCanvas.height / 2,
          200,
        )
        gradient.addColorStop(0, '#121212')
        gradient.addColorStop(1, '#ebebeb')

        sourceCtx.fillStyle = gradient
        sourceCtx.fillRect(0, 0, sourceCanvas.width, sourceCanvas.height)

        imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height)

        const img = new Image()
        img.src = sourceCanvas.toDataURL()
        img.onload = () => {
          sourceImage = img
          generate()
        }
      }

      // Initialize with default image
      createDefaultImage()
    </script>
  </body>
</html>
