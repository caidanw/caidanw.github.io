---
import Layout from '../../layouts/Layout.astro'
import HeaderLayout from '../../layouts/HeaderLayout.astro'
---

<HeaderLayout title="Orbit Simulation">
  <main>
    <h1>Orbit Simulation</h1>
    <p>Simple orbital mechanics using Euler integration</p>

    <div class="controls">
      <button id="reset">Reset</button>
      <label>
        Speed: <input type="range" id="speed" min="0.1" max="5" step="0.1" value="1" />
        <span id="speedValue">1.0x</span>
      </label>
      <label>
        Trail: <input type="range" id="trailLength" min="20" max="200" step="10" value="50" />
        <span id="trailLengthValue">50</span>
      </label>
    </div>

    <div class="controls">
      <label>
        GM: <input type="range" id="gm" min="0.1" max="3" step="0.1" value="1" />
        <span id="gmValue">1.0</span>
      </label>
      <label>
        dt: <input type="range" id="dt" min="0.05" max="0.5" step="0.05" value="0.25" />
        <span id="dtValue">0.25</span>
      </label>
      <label>
        Init X: <input type="range" id="initX" min="0.5" max="2" step="0.1" value="1" />
        <span id="initXValue">1.0</span>
      </label>
      <label>
        Init Vy: <input type="range" id="initVy" min="0.5" max="1.5" step="0.05" value="0.97" />
        <span id="initVyValue">0.97</span>
      </label>
    </div>

    <canvas id="orbitCanvas" width="800" height="800"></canvas>
  </main>
</HeaderLayout>

<style>
  main {
    max-width: 900px;
    margin: 0 auto;
  }

  h1 {
    margin-bottom: 0.5rem;
  }

  p {
    color: #666;
    margin-bottom: 2rem;
  }

  .controls {
    display: flex;
    gap: 2rem;
    align-items: center;
    margin-bottom: 1rem;
  }

  button {
    padding: 0.5rem 1rem;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
  }

  button:hover {
    background: #0056b3;
  }

  label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  input[type='range'] {
    width: 150px;
  }

  #orbitCanvas {
    border: 1px solid #ccc;
    display: block;
    background: #000;
  }
</style>

<script>
  const canvas = document.getElementById('orbitCanvas') as HTMLCanvasElement
  const ctx = canvas.getContext('2d')!
  const resetBtn = document.getElementById('reset') as HTMLButtonElement
  const speedSlider = document.getElementById('speed') as HTMLInputElement
  const speedValue = document.getElementById('speedValue') as HTMLSpanElement
  const trailLengthSlider = document.getElementById('trailLength') as HTMLInputElement
  const trailLengthValue = document.getElementById('trailLengthValue') as HTMLSpanElement
  const gmSlider = document.getElementById('gm') as HTMLInputElement
  const gmValue = document.getElementById('gmValue') as HTMLSpanElement
  const dtSlider = document.getElementById('dt') as HTMLInputElement
  const dtValue = document.getElementById('dtValue') as HTMLSpanElement
  const initXSlider = document.getElementById('initX') as HTMLInputElement
  const initXValue = document.getElementById('initXValue') as HTMLSpanElement
  const initVySlider = document.getElementById('initVy') as HTMLInputElement
  const initVyValue = document.getElementById('initVyValue') as HTMLSpanElement

  // Simulation parameters
  let GM = 1.0
  let dt = 0.25
  const scale = 150 // pixels per unit

  // Initial state values
  let initialX = 1.0
  let initialVy = 0.97

  // Current state
  let x = [initialX, 0]
  let v = [0.24, initialVy]

  // Trail for visualization
  const trail: [number, number][] = []
  let maxTrailLength = 50

  let animationSpeed = 1.0
  let animationId: number

  // Convert simulation coordinates to canvas coordinates
  function toCanvasCoords(simX: number, simY: number): [number, number] {
    return [
      canvas.width / 2 + simX * scale,
      canvas.height / 2 - simY * scale, // Flip Y axis
    ]
  }

  // Simulate one step using Euler method
  function step() {
    // Calculate acceleration: a = -GM * x / ||x||^3
    const r = Math.sqrt(x[0] * x[0] + x[1] * x[1])
    const r3 = r * r * r

    const a = [(-GM * x[0]) / r3, (-GM * x[1]) / r3]

    // Update velocity: v_new = v + a * dt
    v = [v[0] + a[0] * dt, v[1] + a[1] * dt]

    // Update position: x_new = x + v * dt
    x = [x[0] + v[0] * dt, x[1] + v[1] * dt]

    // Add to trail
    trail.push([x[0], x[1]])
    if (trail.length > maxTrailLength) {
      trail.shift()
    }
  }

  // Draw the simulation
  function draw() {
    // Clear canvas fully
    ctx.fillStyle = '#000'
    ctx.fillRect(0, 0, canvas.width, canvas.height)

    // Draw central body (sun/planet)
    const [centerX, centerY] = toCanvasCoords(0, 0)
    ctx.fillStyle = '#ffff00'
    ctx.beginPath()
    ctx.arc(centerX, centerY, 10, 0, Math.PI * 2)
    ctx.fill()

    // Draw trail with fading effect
    if (trail.length > 1) {
      for (let i = 1; i < trail.length; i++) {
        const alpha = (i / trail.length) * 0.8
        ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`
        ctx.lineWidth = 2
        ctx.beginPath()
        const [x1, y1] = toCanvasCoords(trail[i - 1][0], trail[i - 1][1])
        const [x2, y2] = toCanvasCoords(trail[i][0], trail[i][1])
        ctx.moveTo(x1, y1)
        ctx.lineTo(x2, y2)
        ctx.stroke()
      }
    }

    // Draw orbiting body
    const [bodyX, bodyY] = toCanvasCoords(x[0], x[1])
    ctx.fillStyle = '#ff0000'
    ctx.beginPath()
    ctx.arc(bodyX, bodyY, 5, 0, Math.PI * 2)
    ctx.fill()

    // Draw info text
    ctx.fillStyle = '#fff'
    ctx.font = '14px monospace'
    ctx.fillText(`Position: (${x[0].toFixed(3)}, ${x[1].toFixed(3)})`, 10, 20)
    ctx.fillText(`Velocity: (${v[0].toFixed(3)}, ${v[1].toFixed(3)})`, 10, 40)
    const speed = Math.sqrt(v[0] * v[0] + v[1] * v[1])
    ctx.fillText(`Speed: ${speed.toFixed(3)}`, 10, 60)
    const r = Math.sqrt(x[0] * x[0] + x[1] * x[1])
    ctx.fillText(`Distance: ${r.toFixed(3)}`, 10, 80)
  }

  // Animation loop
  function animate() {
    // Run multiple steps based on animation speed
    const stepsPerFrame = Math.ceil(animationSpeed)
    for (let i = 0; i < stepsPerFrame; i++) {
      step()
    }

    draw()
    animationId = requestAnimationFrame(animate)
  }

  // Reset simulation
  function reset() {
    x = [initialX, 0]
    v = [0.24, initialVy]
    trail.length = 0
  }

  // Event listeners
  resetBtn.addEventListener('click', reset)

  speedSlider.addEventListener('input', () => {
    animationSpeed = parseFloat(speedSlider.value)
    speedValue.textContent = `${animationSpeed.toFixed(1)}x`
  })

  trailLengthSlider.addEventListener('input', () => {
    maxTrailLength = parseInt(trailLengthSlider.value)
    trailLengthValue.textContent = maxTrailLength.toString()
  })

  gmSlider.addEventListener('input', () => {
    GM = parseFloat(gmSlider.value)
    gmValue.textContent = GM.toFixed(1)
  })

  dtSlider.addEventListener('input', () => {
    dt = parseFloat(dtSlider.value)
    dtValue.textContent = dt.toFixed(2)
  })

  initXSlider.addEventListener('input', () => {
    initialX = parseFloat(initXSlider.value)
    initXValue.textContent = initialX.toFixed(1)
    reset()
  })

  initVySlider.addEventListener('input', () => {
    initialVy = parseFloat(initVySlider.value)
    initVyValue.textContent = initialVy.toFixed(2)
    reset()
  })

  // Start animation
  animate()
</script>
