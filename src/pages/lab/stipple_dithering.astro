---
import Layout from '../../layouts/Layout.astro'
---

<Layout title="Stipple Dithering">
  <div class="container">
    <canvas id="sourceCanvas" width="400" height="400" style="display: none;"></canvas>
    <canvas id="outputCanvas" width="800" height="800"></canvas>

    <div class="controls">
      <label class="file-label">
        Upload Image
        <input type="file" id="fileInput" accept="image/*" />
      </label>
      <button id="download">Download</button>
      <label>
        Density:
        <input type="range" id="density" min="1" max="1000" value="500" step="1" />
        <span id="densityValue">50</span>
      </label>
      <label>
        Dot Size:
        <input type="range" id="dotSize" min="0.3" max="3" value="1.2" step="0.1" />
        <span id="dotSizeValue">1.2</span>
      </label>
      <label>
        Darkness Threshold:
        <input type="range" id="darknessThreshold" min="0.05" max="0.5" value="0.15" step="0.05" />
        <span id="darknessThresholdValue">0.15</span>
      </label>
      <label>
        Method:
        <select id="method">
          <option value="quadtree">Quadtree Subdivision</option>
          <option value="random">Weighted Random</option>
          <option value="voronoi">Voronoi</option>
          <option value="hybrid">Hybrid Subdivision</option>
          <option value="grid">Grid-Based</option>
          <option value="organic">Organic Random</option>
        </select>
      </label>
    </div>

    <div id="loadingIndicator" class="loading-indicator hidden">Generating...</div>

    <div id="imageSizeInfo" class="image-size-info hidden"></div>

    <div class="info">Adaptive stippling with 6 different algorithms — switch methods to compare approaches</div>
  </div>
</Layout>

<script>
  // Constants
  const BACKGROUND_COLOR = '#ebebeb'
  const DOT_COLOR = '#121212'
  const MIN_DARKNESS_THRESHOLD = 0.05
  const MIN_DISTANCE_THRESHOLD = 2
  const HARD_MAX_RECURSION_DEPTH = 15
  const DEFAULT_BRIGHTNESS = 0.5
  const DEBOUNCE_DELAY = 200
  const BRIGHTNESS_SAMPLE_STEP = 4
  const MAX_CANVAS_DIMENSION = 1200 // Max width or height for performance

  // Generic helper to get and type-check DOM elements
  function getElement<T extends HTMLElement>(id: string, type: new () => T): T {
    const element = document.getElementById(id)
    if (!element) {
      throw new Error(`Element with id '${id}' not found`)
    }
    if (!(element instanceof type)) {
      throw new Error(`Element '${id}' is not a ${type.name}`)
    }
    return element
  }

  // Convenience functions for common element types
  const getCanvas = (id: string) => getElement(id, HTMLCanvasElement)
  const getInput = (id: string) => getElement(id, HTMLInputElement)
  const getButton = (id: string) => getElement(id, HTMLButtonElement)
  const getSelect = (id: string) => getElement(id, HTMLSelectElement)
  const getSpan = (id: string) => getElement(id, HTMLSpanElement)
  const getDiv = (id: string) => getElement(id, HTMLDivElement)

  // Get all DOM elements with automatic type checking
  const sourceCanvas = getCanvas('sourceCanvas')
  const outputCanvas = getCanvas('outputCanvas')
  const fileInput = getInput('fileInput')
  const densitySlider = getInput('density')
  const densityValue = getSpan('densityValue')
  const dotSizeSlider = getInput('dotSize')
  const dotSizeValue = getSpan('dotSizeValue')
  const darknessThresholdSlider = getInput('darknessThreshold')
  const darknessThresholdValue = getSpan('darknessThresholdValue')
  const methodSelect = getSelect('method')
  const downloadBtn = getButton('download')
  const loadingIndicator = getDiv('loadingIndicator')
  const imageSizeInfo = getDiv('imageSizeInfo')

  const sourceCtx = sourceCanvas.getContext('2d')
  const outputCtx = outputCanvas.getContext('2d')

  if (!sourceCtx || !outputCtx) {
    throw new Error('Could not get canvas contexts')
  }

  let density = parseInt(densitySlider.value)
  let dotSize = parseFloat(dotSizeSlider.value)
  let darknessThreshold = parseFloat(darknessThresholdSlider.value)
  let method: 'quadtree' | 'random' | 'voronoi' | 'hybrid' | 'grid' | 'organic' = 'quadtree'
  let sourceImage: HTMLImageElement | null = null
  let imageData: ImageData | null = null
  let brightnessCache: Float32Array | null = null
  let cacheWidth = 0
  let cacheHeight = 0
  let dots: { x: number; y: number; opacity: number; size: number }[] = []
  let isGenerating = false
  let cancelGeneration = false

  interface Point {
    x: number
    y: number
  }

  interface Triangle {
    p1: Point
    p2: Point
    p3: Point
  }

  interface SpatialGrid {
    cellSize: number
    cols: number
    rows: number
    cells: Map<string, Array<{ x: number; y: number; size: number }>>
  }

  // Calculate luminance using perceptual formula
  function calculateLuminance(r: number, g: number, b: number): number {
    return (0.299 * r + 0.587 * g + 0.114 * b) / 255
  }

  // Build brightness cache with downsampling
  function buildBrightnessCache() {
    if (!imageData) return

    cacheWidth = Math.ceil(sourceCanvas.width / BRIGHTNESS_SAMPLE_STEP)
    cacheHeight = Math.ceil(sourceCanvas.height / BRIGHTNESS_SAMPLE_STEP)
    brightnessCache = new Float32Array(cacheWidth * cacheHeight)

    for (let y = 0; y < cacheHeight; y++) {
      for (let x = 0; x < cacheWidth; x++) {
        const px = Math.min(x * BRIGHTNESS_SAMPLE_STEP, sourceCanvas.width - 1)
        const py = Math.min(y * BRIGHTNESS_SAMPLE_STEP, sourceCanvas.height - 1)
        const index = (py * sourceCanvas.width + px) * 4

        const r = imageData.data[index]
        const g = imageData.data[index + 1]
        const b = imageData.data[index + 2]

        brightnessCache[y * cacheWidth + x] = calculateLuminance(r, g, b)
      }
    }
  }

  // Get brightness from cache
  function getBrightness(x: number, y: number): number {
    if (!brightnessCache) return DEFAULT_BRIGHTNESS

    const cx = Math.floor(x / BRIGHTNESS_SAMPLE_STEP)
    const cy = Math.floor(y / BRIGHTNESS_SAMPLE_STEP)

    if (cx < 0 || cx >= cacheWidth || cy < 0 || cy >= cacheHeight) {
      return 1
    }

    return brightnessCache[cy * cacheWidth + cx]
  }

  // Get average brightness of a region
  function getRegionBrightness(x: number, y: number, w: number, h: number): number {
    let total = 0
    let count = 0

    const startX = Math.floor(x / BRIGHTNESS_SAMPLE_STEP)
    const startY = Math.floor(y / BRIGHTNESS_SAMPLE_STEP)
    const endX = Math.ceil((x + w) / BRIGHTNESS_SAMPLE_STEP)
    const endY = Math.ceil((y + h) / BRIGHTNESS_SAMPLE_STEP)

    for (let cy = startY; cy < endY; cy++) {
      for (let cx = startX; cx < endX; cx++) {
        if (cx >= 0 && cx < cacheWidth && cy >= 0 && cy < cacheHeight) {
          total += brightnessCache![cy * cacheWidth + cx]
          count++
        }
      }
    }

    return count > 0 ? total / count : DEFAULT_BRIGHTNESS
  }

  // Calculate centroid of three points
  function centroid(p1: Point, p2: Point, p3: Point): Point {
    return {
      x: (p1.x + p2.x + p3.x) / 3,
      y: (p1.y + p2.y + p3.y) / 3,
    }
  }

  // Calculate distance between two points
  function distance(p1: Point, p2: Point): number {
    return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2)
  }

  // Spatial grid helpers for Organic Random
  function createSpatialGrid(w: number, h: number, minRadius: number): SpatialGrid {
    const cellSize = minRadius * 2
    const cols = Math.ceil(w / cellSize)
    const rows = Math.ceil(h / cellSize)

    return {
      cellSize,
      cols,
      rows,
      cells: new Map(),
    }
  }

  function getCellKey(x: number, y: number, grid: SpatialGrid): string {
    const col = Math.floor(x / grid.cellSize)
    const row = Math.floor(y / grid.cellSize)
    return `${col},${row}`
  }

  function addToGrid(dot: { x: number; y: number; size: number }, grid: SpatialGrid) {
    const key = getCellKey(dot.x, dot.y, grid)
    if (!grid.cells.has(key)) {
      grid.cells.set(key, [])
    }
    grid.cells.get(key)!.push(dot)
  }

  function isTooClose(x: number, y: number, radius: number, grid: SpatialGrid): boolean {
    const col = Math.floor(x / grid.cellSize)
    const row = Math.floor(y / grid.cellSize)

    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const key = `${col + dx},${row + dy}`
        const cellDots = grid.cells.get(key)

        if (cellDots) {
          for (const dot of cellDots) {
            const dist = Math.sqrt((x - dot.x) ** 2 + (y - dot.y) ** 2)
            const combinedRadius = radius + dot.size * 1.5
            if (dist < combinedRadius) return true
          }
        }
      }
    }

    return false
  }

  function calculateMinRadius(): number {
    const baseRadius = 10 - (density / 100) * 8
    return Math.max(2, baseRadius)
  }

  function calculateDotSize(darkness: number): number {
    const baseSize = dotSize
    const multiplier = 0.4 + darkness * 1.3
    return baseSize * multiplier
  }

  // Recursive stippling within a bounded region
  function stippleRegionRecursive(p1: Point, p2: Point, p3: Point, depth: number, maxDepth: number, regionBrightness: number) {
    // Hard limit to prevent stack overflow
    if (depth >= HARD_MAX_RECURSION_DEPTH) return

    const avgDist = (distance(p1, p2) + distance(p2, p3) + distance(p3, p1)) / 3
    if (avgDist < MIN_DISTANCE_THRESHOLD) return

    const center = centroid(p1, p2, p3)

    // If we've reached max depth, place dot and stop
    if (depth >= maxDepth) {
      const darkness = 1 - regionBrightness
      if (darkness > MIN_DARKNESS_THRESHOLD) {
        // More accurate opacity mapping
        const opacity = Math.pow(darkness, 0.8)
        dots.push({
          x: center.x,
          y: center.y,
          opacity: opacity,
          size: dotSize,
        })
      }
      return
    }

    // Recurse into three new triangles
    stippleRegionRecursive(p1, p2, center, depth + 1, maxDepth, regionBrightness)
    stippleRegionRecursive(p2, p3, center, depth + 1, maxDepth, regionBrightness)
    stippleRegionRecursive(p3, p1, center, depth + 1, maxDepth, regionBrightness)
  }

  // Delaunay triangulation helper functions
  function circumcircle(p1: Point, p2: Point, p3: Point) {
    const ax = p1.x - p3.x
    const ay = p1.y - p3.y
    const bx = p2.x - p3.x
    const by = p2.y - p3.y

    const m = 2 * (ax * by - ay * bx)
    if (Math.abs(m) < 1e-10) return null

    const s1 = ax * ax + ay * ay
    const s2 = bx * bx + by * by

    const cx = p3.x + (by * s1 - ay * s2) / m
    const cy = p3.y + (ax * s2 - bx * s1) / m
    const r = Math.sqrt((cx - p1.x) ** 2 + (cy - p1.y) ** 2)

    return { x: cx, y: cy, r }
  }

  function pointInCircumcircle(p: Point, t: Triangle): boolean {
    const circle = circumcircle(t.p1, t.p2, t.p3)
    if (!circle) return false
    return distance(p, circle) < circle.r
  }

  function trianglesEqual(t1: Triangle, t2: Triangle): boolean {
    const points1 = [t1.p1, t1.p2, t1.p3].sort((a, b) => a.x - b.x || a.y - b.y)
    const points2 = [t2.p1, t2.p2, t2.p3].sort((a, b) => a.x - b.x || a.y - b.y)
    return points1.every((p, i) => p.x === points2[i].x && p.y === points2[i].y)
  }

  // Bowyer-Watson Delaunay triangulation
  function delaunayTriangulation(points: Point[]): Triangle[] {
    if (points.length < 3) return []

    // Create super triangle
    const minX = Math.min(...points.map((p) => p.x))
    const minY = Math.min(...points.map((p) => p.y))
    const maxX = Math.max(...points.map((p) => p.x))
    const maxY = Math.max(...points.map((p) => p.y))

    const dx = maxX - minX
    const dy = maxY - minY
    const deltaMax = Math.max(dx, dy) * 2

    const superTriangle: Triangle = {
      p1: { x: minX - deltaMax, y: minY - 1 },
      p2: { x: minX + deltaMax * 2, y: minY - 1 },
      p3: { x: minX + dx / 2, y: maxY + deltaMax },
    }

    let triangles: Triangle[] = [superTriangle]

    // Add each point
    for (const point of points) {
      const badTriangles: Triangle[] = []

      // Find bad triangles
      for (const triangle of triangles) {
        if (pointInCircumcircle(point, triangle)) {
          badTriangles.push(triangle)
        }
      }

      // Find boundary polygon
      const edges: Array<[Point, Point]> = []
      for (const triangle of badTriangles) {
        edges.push([triangle.p1, triangle.p2])
        edges.push([triangle.p2, triangle.p3])
        edges.push([triangle.p3, triangle.p1])
      }

      // Remove duplicate edges
      const uniqueEdges = edges.filter((edge, i) => {
        return !edges.some((otherEdge, j) => {
          if (i === j) return false
          return edge[0] === otherEdge[1] && edge[1] === otherEdge[0]
        })
      })

      // Remove bad triangles
      triangles = triangles.filter((t) => !badTriangles.includes(t))

      // Add new triangles
      for (const edge of uniqueEdges) {
        triangles.push({ p1: edge[0], p2: edge[1], p3: point })
      }
    }

    // Remove triangles that share vertices with super triangle
    return triangles.filter((t) => {
      return (
        t.p1 !== superTriangle.p1 &&
        t.p1 !== superTriangle.p2 &&
        t.p1 !== superTriangle.p3 &&
        t.p2 !== superTriangle.p1 &&
        t.p2 !== superTriangle.p2 &&
        t.p2 !== superTriangle.p3 &&
        t.p3 !== superTriangle.p1 &&
        t.p3 !== superTriangle.p2 &&
        t.p3 !== superTriangle.p3
      )
    })
  }

  function generatePointsForRegion(x: number, y: number, w: number, h: number, brightness: number): Point[] {
    const darkness = 1 - brightness
    const numPoints = Math.max(1, Math.round(darkness * density * 5))
    const points: Point[] = []

    for (let i = 0; i < numPoints; i++) {
      points.push({
        x: x + Math.random() * w,
        y: y + Math.random() * h,
      })
    }

    return points
  }

  function stippleRegionDelaunay(x: number, y: number, w: number, h: number, brightness: number) {
    const points = generatePointsForRegion(x, y, w, h, brightness)
    if (points.length === 0) return

    const triangles = delaunayTriangulation(points)
    const darkness = 1 - brightness

    if (darkness > MIN_DARKNESS_THRESHOLD) {
      const opacity = Math.pow(darkness, 0.8)

      for (const tri of triangles) {
        const center = centroid(tri.p1, tri.p2, tri.p3)
        dots.push({
          x: center.x,
          y: center.y,
          opacity: opacity,
          size: dotSize,
        })
      }
    }
  }

  // METHOD 1: Pure Quadtree Subdivision
  function quadtreeSubdivision(x: number, y: number, w: number, h: number, depth: number) {
    if (cancelGeneration) return
    if (depth >= density + 5) return

    const brightness = getRegionBrightness(x, y, w, h)
    const darkness = 1 - brightness
    const minSize = 10

    if (w < minSize || h < minSize) {
      if (darkness > MIN_DARKNESS_THRESHOLD) {
        const opacity = Math.pow(darkness, 0.8)
        dots.push({
          x: x + w / 2,
          y: y + h / 2,
          opacity: opacity,
          size: dotSize,
        })
      }
      return
    }

    const shouldSubdivide = darkness > 0.15 && depth < density

    if (shouldSubdivide) {
      const hw = w / 2
      const hh = h / 2
      quadtreeSubdivision(x, y, hw, hh, depth + 1)
      quadtreeSubdivision(x + hw, y, hw, hh, depth + 1)
      quadtreeSubdivision(x, y + hh, hw, hh, depth + 1)
      quadtreeSubdivision(x + hw, y + hh, hw, hh, depth + 1)
    } else {
      if (darkness > MIN_DARKNESS_THRESHOLD) {
        const opacity = Math.pow(darkness, 0.8)
        dots.push({
          x: x + w / 2,
          y: y + h / 2,
          opacity: opacity,
          size: dotSize,
        })
      }
    }
  }

  // METHOD 2: Weighted Random Sampling
  function weightedRandomSampling(w: number, h: number) {
    const totalPoints = density * 1000
    const samples = totalPoints * 2

    for (let i = 0; i < samples; i++) {
      if (cancelGeneration) return

      const x = Math.random() * w
      const y = Math.random() * h
      const brightness = getBrightness(x, y)
      const darkness = 1 - brightness

      // Accept point with probability proportional to darkness
      if (Math.random() < darkness && darkness > MIN_DARKNESS_THRESHOLD) {
        const opacity = Math.pow(darkness, 0.8)
        dots.push({
          x: x,
          y: y,
          opacity: opacity,
          size: dotSize,
        })

        if (dots.length >= totalPoints) break
      }
    }
  }

  // METHOD 3: Voronoi (using Delaunay dual)
  function voronoiStippling(w: number, h: number) {
    // Generate initial random points weighted by darkness
    const initialPoints: Point[] = []
    const numSeeds = density * 100

    for (let i = 0; i < numSeeds * 3; i++) {
      if (cancelGeneration) return

      const x = Math.random() * w
      const y = Math.random() * h
      const brightness = getBrightness(x, y)
      const darkness = 1 - brightness

      if (Math.random() < darkness && darkness > MIN_DARKNESS_THRESHOLD) {
        initialPoints.push({ x, y })
        if (initialPoints.length >= numSeeds) break
      }
    }

    // Create Delaunay triangulation
    const triangles = delaunayTriangulation(initialPoints)

    // Place dots at triangle centroids
    for (const tri of triangles) {
      if (cancelGeneration) return

      const center = centroid(tri.p1, tri.p2, tri.p3)
      const brightness = getBrightness(center.x, center.y)
      const darkness = 1 - brightness

      if (darkness > MIN_DARKNESS_THRESHOLD) {
        const opacity = Math.pow(darkness, 0.8)
        dots.push({
          x: center.x,
          y: center.y,
          opacity: opacity,
          size: dotSize,
        })
      }
    }
  }

  // METHOD 4: Hybrid Subdivision + Sampling
  function hybridSubdivision(x: number, y: number, w: number, h: number, depth: number) {
    if (cancelGeneration) return
    if (depth >= density + 3) return

    const brightness = getRegionBrightness(x, y, w, h)
    const darkness = 1 - brightness
    const minSize = 20

    if (w < minSize || h < minSize) {
      // Place multiple random dots in this region based on darkness
      const numDots = Math.max(1, Math.floor(darkness * 5))
      for (let i = 0; i < numDots; i++) {
        if (darkness > MIN_DARKNESS_THRESHOLD) {
          const opacity = Math.pow(darkness, 0.8)
          dots.push({
            x: x + Math.random() * w,
            y: y + Math.random() * h,
            opacity: opacity,
            size: dotSize,
          })
        }
      }
      return
    }

    const shouldSubdivide = darkness > 0.15 && depth < density

    if (shouldSubdivide) {
      const hw = w / 2
      const hh = h / 2
      hybridSubdivision(x, y, hw, hh, depth + 1)
      hybridSubdivision(x + hw, y, hw, hh, depth + 1)
      hybridSubdivision(x, y + hh, hw, hh, depth + 1)
      hybridSubdivision(x + hw, y + hh, hw, hh, depth + 1)
    } else {
      // Place multiple dots in this region
      const numDots = Math.max(1, Math.floor(darkness * density))
      for (let i = 0; i < numDots; i++) {
        if (darkness > MIN_DARKNESS_THRESHOLD) {
          const opacity = Math.pow(darkness, 0.8)
          dots.push({
            x: x + Math.random() * w,
            y: y + Math.random() * h,
            opacity: opacity,
            size: dotSize,
          })
        }
      }
    }
  }

  // METHOD 5: Grid-Based with Recursive Subdivision
  function gridBasedStippling(w: number, h: number) {
    const gridSize = Math.max(5, 50 - density * 4) // Higher density = smaller grid
    const cols = Math.ceil(w / gridSize)
    const rows = Math.ceil(h / gridSize)

    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        if (cancelGeneration) return

        const x = col * gridSize
        const y = row * gridSize
        const cellW = Math.min(gridSize, w - x)
        const cellH = Math.min(gridSize, h - y)

        const brightness = getRegionBrightness(x, y, cellW, cellH)
        const darkness = 1 - brightness

        if (darkness > MIN_DARKNESS_THRESHOLD) {
          // Recursively subdivide this grid cell
          gridCellRecursive(x, y, cellW, cellH, brightness, 0, density)
        }
      }
    }
  }

  function gridCellRecursive(x: number, y: number, w: number, h: number, brightness: number, depth: number, maxDepth: number) {
    if (cancelGeneration) return
    if (depth >= maxDepth || depth >= HARD_MAX_RECURSION_DEPTH) {
      const darkness = 1 - brightness
      if (darkness > MIN_DARKNESS_THRESHOLD) {
        const opacity = Math.pow(darkness, 0.8)
        dots.push({
          x: x + w / 2,
          y: y + h / 2,
          opacity: opacity,
          size: dotSize,
        })
      }
      return
    }

    const avgDist = (w + h) / 2
    if (avgDist < MIN_DISTANCE_THRESHOLD) return

    const hw = w / 2
    const hh = h / 2

    gridCellRecursive(x, y, hw, hh, brightness, depth + 1, maxDepth)
    gridCellRecursive(x + hw, y, hw, hh, brightness, depth + 1, maxDepth)
    gridCellRecursive(x, y + hh, hw, hh, brightness, depth + 1, maxDepth)
    gridCellRecursive(x + hw, y + hh, hw, hh, brightness, depth + 1, maxDepth)
  }

  // METHOD 6: Organic Random (Dart Throwing + Poisson Disk)
  function organicRandomSampling(w: number, h: number) {
    const targetDots = density * 10
    const maxAttempts = targetDots * 20

    const minRadius = calculateMinRadius()
    const grid = createSpatialGrid(w, h, minRadius)

    let attempts = 0
    while (dots.length < targetDots && attempts < maxAttempts) {
      if (cancelGeneration) return
      attempts++

      const x = Math.random() * w
      const y = Math.random() * h

      const brightness = getBrightness(x, y)
      const darkness = 1 - brightness

      if (darkness < darknessThreshold) continue

      const dotSizeForPoint = calculateDotSize(darkness)
      const effectiveRadius = Math.max(minRadius, dotSizeForPoint * 1.5)

      if (isTooClose(x, y, effectiveRadius, grid)) continue

      const opacity = Math.pow(darkness, 0.8)
      const dot = {
        x: x,
        y: y,
        opacity: opacity,
        size: dotSizeForPoint,
      }

      dots.push(dot)
      addToGrid(dot, grid)
    }
  }

  async function generateProgressively() {
    if (!sourceImage || isGenerating) return

    isGenerating = true
    cancelGeneration = false
    dots = []

    loadingIndicator.classList.remove('hidden')

    try {
      outputCtx.save()
      outputCtx.fillStyle = BACKGROUND_COLOR
      outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height)
      outputCtx.restore()

      const w = outputCanvas.width
      const h = outputCanvas.height

      // Route to appropriate method
      switch (method) {
        case 'quadtree':
          quadtreeSubdivision(0, 0, w, h, 0)
          break
        case 'random':
          weightedRandomSampling(w, h)
          break
        case 'voronoi':
          voronoiStippling(w, h)
          break
        case 'hybrid':
          hybridSubdivision(0, 0, w, h, 0)
          break
        case 'grid':
          gridBasedStippling(w, h)
          break
        case 'organic':
          organicRandomSampling(w, h)
          break
      }

      renderDots()

      console.log(`Generated ${dots.length} dots using ${method} method`)
    } catch (error) {
      console.error('Error during generation:', error)
    } finally {
      loadingIndicator.classList.add('hidden')
      isGenerating = false
    }
  }

  function renderDots() {
    // Clear and redraw
    outputCtx.save()
    outputCtx.fillStyle = BACKGROUND_COLOR
    outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height)

    // Draw all dots
    dots.forEach((dot) => {
      outputCtx.fillStyle = `rgba(18, 18, 18, ${dot.opacity})`
      outputCtx.beginPath()
      outputCtx.arc(dot.x, dot.y, dot.size, 0, Math.PI * 2)
      outputCtx.fill()
    })

    outputCtx.restore()
  }

  function loadImage(file: File) {
    const reader = new FileReader()

    reader.onerror = () => {
      console.error('Error reading file')
      alert('Failed to read image file')
    }

    reader.onload = (e) => {
      const img = new Image()

      img.onerror = () => {
        console.error('Error loading image')
        alert('Failed to load image')
      }

      img.onload = () => {
        try {
          sourceImage = img

          // Calculate optimal canvas size
          const scale = Math.min(MAX_CANVAS_DIMENSION / img.width, MAX_CANVAS_DIMENSION / img.height, 1)
          const canvasWidth = Math.floor(img.width * scale)
          const canvasHeight = Math.floor(img.height * scale)

          // Show image size info
          if (scale < 1) {
            imageSizeInfo.textContent = `Image downscaled from ${img.width}×${img.height} to ${canvasWidth}×${canvasHeight} for performance`
            imageSizeInfo.classList.remove('hidden')
          } else {
            imageSizeInfo.textContent = `Processing at ${canvasWidth}×${canvasHeight}`
            imageSizeInfo.classList.remove('hidden')
          }

          // Resize both canvases to match image aspect ratio
          sourceCanvas.width = canvasWidth
          sourceCanvas.height = canvasHeight
          outputCanvas.width = canvasWidth
          outputCanvas.height = canvasHeight

          // Draw source image
          sourceCtx.save()
          sourceCtx.fillStyle = BACKGROUND_COLOR
          sourceCtx.fillRect(0, 0, sourceCanvas.width, sourceCanvas.height)
          sourceCtx.drawImage(img, 0, 0, canvasWidth, canvasHeight)
          sourceCtx.restore()

          // Get image data for brightness sampling
          imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height)
          buildBrightnessCache()

          generateProgressively()
        } catch (error) {
          console.error('Error processing image:', error)
          alert('Failed to process image')
        }
      }

      const result = e.target?.result
      if (typeof result === 'string') {
        img.src = result
      }
    }

    reader.readAsDataURL(file)
  }

  function downloadImage() {
    try {
      const link = document.createElement('a')
      link.download = 'stipple-dithering.png'
      link.href = outputCanvas.toDataURL('image/png')
      link.click()
    } catch (error) {
      console.error('Error downloading image:', error)
      alert('Failed to download image')
    }
  }

  // Debounce helper
  function debounce<T extends (...args: any[]) => any>(func: T, delay: number) {
    let timeoutId: ReturnType<typeof setTimeout>
    return function (this: any, ...args: Parameters<T>) {
      clearTimeout(timeoutId)
      timeoutId = setTimeout(() => func.apply(this, args), delay)
    }
  }

  const debouncedGenerate = debounce(() => {
    if (sourceImage) {
      cancelGeneration = true
      setTimeout(() => generateProgressively(), 50)
    }
  }, DEBOUNCE_DELAY)

  // Event listeners
  fileInput.addEventListener('change', (e) => {
    if (!(e.target instanceof HTMLInputElement)) return
    if (e.target.files && e.target.files.length > 0) {
      loadImage(e.target.files[0])
    }
  })

  densitySlider.addEventListener('input', (e) => {
    if (!(e.target instanceof HTMLInputElement)) return
    density = parseInt(e.target.value)
    densityValue.textContent = density.toString()
    debouncedGenerate()
  })

  dotSizeSlider.addEventListener('input', (e) => {
    if (!(e.target instanceof HTMLInputElement)) return
    dotSize = parseFloat(e.target.value)
    dotSizeValue.textContent = dotSize.toFixed(1)
    debouncedGenerate()
  })

  darknessThresholdSlider.addEventListener('input', (e) => {
    if (!(e.target instanceof HTMLInputElement)) return
    darknessThreshold = parseFloat(e.target.value)
    darknessThresholdValue.textContent = darknessThreshold.toFixed(2)
    debouncedGenerate()
  })

  methodSelect.addEventListener('change', (e) => {
    if (!(e.target instanceof HTMLSelectElement)) return
    method = e.target.value as 'quadtree' | 'random' | 'voronoi' | 'hybrid' | 'grid' | 'organic'
    debouncedGenerate()
  })

  downloadBtn.addEventListener('click', downloadImage)

  // Load a default gradient to demonstrate
  function createDefaultImage() {
    try {
      // Set initial canvas size
      const initialSize = 800
      sourceCanvas.width = initialSize
      sourceCanvas.height = initialSize
      outputCanvas.width = initialSize
      outputCanvas.height = initialSize

      sourceCtx.save()
      sourceCtx.fillStyle = BACKGROUND_COLOR
      sourceCtx.fillRect(0, 0, sourceCanvas.width, sourceCanvas.height)

      // Create a circular gradient
      const gradient = sourceCtx.createRadialGradient(sourceCanvas.width / 2, sourceCanvas.height / 2, 50, sourceCanvas.width / 2, sourceCanvas.height / 2, 200)
      gradient.addColorStop(0, DOT_COLOR)
      gradient.addColorStop(1, BACKGROUND_COLOR)

      sourceCtx.fillStyle = gradient
      sourceCtx.fillRect(0, 0, sourceCanvas.width, sourceCanvas.height)
      sourceCtx.restore()

      imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height)
      buildBrightnessCache()

      const img = new Image()
      img.onerror = () => {
        console.error('Error loading default image')
      }
      img.onload = () => {
        sourceImage = img
        generateProgressively()
      }
      img.src = sourceCanvas.toDataURL()
    } catch (error) {
      console.error('Error creating default image:', error)
    }
  }

  // Initialize with default image
  createDefaultImage()
</script>

<style>
  .container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    align-items: center;
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    min-height: 100dvh;
  }

  #outputCanvas {
    border: 2px solid var(--theme-border);
    border-radius: 8px;
    max-width: 95vw;
    max-height: 80vh;
    width: auto;
    height: auto;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  }

  .controls {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }

  button {
    background: var(--theme-accent);
    color: var(--color-white);
    border: none;
    padding: 10px 20px;
    border-radius: 6px;
    font-family: var(--font-sans);
    font-size: 14px;
    cursor: pointer;
    transition: background 0.2s;
  }

  button:hover {
    background: var(--theme-accent-light);
  }

  button:active {
    background: var(--theme-accent-dark);
  }

  input[type='file'] {
    display: none;
  }

  label {
    color: var(--theme-text-subtle);
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  input[type='range'] {
    width: 150px;
  }

  select {
    background: var(--theme-bg);
    color: var(--theme-text);
    border: 1px solid var(--theme-border);
    padding: 4px 8px;
    border-radius: 4px;
    font-family: var(--font-sans);
    font-size: 14px;
    cursor: pointer;
  }

  .info {
    color: var(--theme-text-dim);
    font-size: 13px;
    text-align: center;
  }

  .file-label {
    background: var(--theme-accent);
    color: var(--color-white);
    padding: 10px 20px;
    border-radius: 6px;
    font-family: var(--font-sans);
    font-size: 14px;
    cursor: pointer;
    transition: background 0.2s;
  }

  .file-label:hover {
    background: var(--theme-accent-light);
  }

  .loading-indicator {
    color: var(--theme-accent);
    font-size: 14px;
    font-weight: 600;
    padding: 8px 16px;
    background: var(--theme-bg);
    border: 1px solid var(--theme-border);
    border-radius: 6px;
  }

  .loading-indicator.hidden {
    display: none;
  }

  .image-size-info {
    color: var(--theme-text-subtle);
    font-size: 13px;
    text-align: center;
    padding: 4px 12px;
    background: var(--theme-bg);
    border: 1px solid var(--theme-border);
    border-radius: 4px;
  }

  .image-size-info.hidden {
    display: none;
  }
</style>
