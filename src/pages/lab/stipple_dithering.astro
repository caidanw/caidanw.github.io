---
import Layout from '../../layouts/Layout.astro'
---

<Layout title="Stipple Dithering">
  <div class="container">
    <div class="canvases">
      <canvas id="sourceCanvas" width="800" height="800"></canvas>
      <canvas id="outputCanvas" width="800" height="800"></canvas>
    </div>

    <div class="controls">
      <label class="file-label">
        Upload Image
        <input type="file" id="fileInput" accept="image/*" />
      </label>
      <button id="regenerate">Generate</button>
      <label>
        Grid Size:
        <input type="range" id="gridSize" min="8" max="64" value="24" step="4" />
        <span id="gridSizeValue">24</span>
      </label>
      <label>
        Subdivisions:
        <input type="range" id="subdivisions" min="2" max="8" value="5" step="1" />
        <span id="subdivisionsValue">5</span>
      </label>
      <label>
        Dot Size:
        <input type="range" id="dotSize" min="0.3" max="3" value="1.2" step="0.1" />
        <span id="dotSizeValue">1.2</span>
      </label>
    </div>

    <div class="info">Region-based triangulation stippling â€” segments image by brightness, then stipples each region</div>
  </div>
</Layout>

<script>
  const sourceCanvas = document.getElementById('sourceCanvas') as HTMLCanvasElement
  const outputCanvas = document.getElementById('outputCanvas') as HTMLCanvasElement
  const sourceCtx = sourceCanvas.getContext('2d')!
  const outputCtx = outputCanvas.getContext('2d')!
  const fileInput = document.getElementById('fileInput') as HTMLInputElement
  const gridSizeSlider = document.getElementById('gridSize') as HTMLInputElement
  const gridSizeValue = document.getElementById('gridSizeValue') as HTMLSpanElement
  const subdivisionsSlider = document.getElementById('subdivisions') as HTMLInputElement
  const subdivisionsValue = document.getElementById('subdivisionsValue') as HTMLSpanElement
  const dotSizeSlider = document.getElementById('dotSize') as HTMLInputElement
  const dotSizeValue = document.getElementById('dotSizeValue') as HTMLSpanElement
  const regenerateBtn = document.getElementById('regenerate') as HTMLButtonElement

  let gridSize = parseInt(gridSizeSlider.value)
  let maxSubdivisions = parseInt(subdivisionsSlider.value)
  let dotSize = parseFloat(dotSizeSlider.value)
  let sourceImage: HTMLImageElement | null = null
  let imageData: ImageData | null = null
  let dots: { x: number; y: number; opacity: number; size: number }[] = []

  interface Point {
    x: number
    y: number
  }

  // Calculate centroid of three points
  function centroid(p1: Point, p2: Point, p3: Point): Point {
    return {
      x: (p1.x + p2.x + p3.x) / 3,
      y: (p1.y + p2.y + p3.y) / 3,
    }
  }

  // Calculate distance between two points
  function distance(p1: Point, p2: Point): number {
    return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2)
  }

  // Get brightness at a point (0 = black, 1 = white)
  function getBrightness(x: number, y: number): number {
    if (!imageData) return 0.5

    const ix = Math.floor(x)
    const iy = Math.floor(y)

    if (ix < 0 || ix >= sourceCanvas.width || iy < 0 || iy >= sourceCanvas.height) {
      return 1
    }

    const index = (iy * sourceCanvas.width + ix) * 4
    const r = imageData.data[index]
    const g = imageData.data[index + 1]
    const b = imageData.data[index + 2]

    // Convert to grayscale
    return (r + g + b) / (3 * 255)
  }

  // Get average brightness of a region
  function getRegionBrightness(x: number, y: number, w: number, h: number): number {
    let total = 0
    let count = 0
    const step = 2

    for (let dy = 0; dy < h; dy += step) {
      for (let dx = 0; dx < w; dx += step) {
        total += getBrightness(x + dx, y + dy)
        count++
      }
    }

    return count > 0 ? total / count : 0.5
  }

  // Recursive stippling within a bounded region
  function stippleRegion(p1: Point, p2: Point, p3: Point, depth: number, maxDepth: number, regionBrightness: number) {
    const avgDist = (distance(p1, p2) + distance(p2, p3) + distance(p3, p1)) / 3
    if (avgDist < 2) return

    const center = centroid(p1, p2, p3)

    // If we've reached max depth or triangle is small enough, place dot and stop
    if (depth >= maxDepth) {
      const darkness = 1 - regionBrightness
      if (darkness > 0.1) {
        const opacity = 0.5 + darkness * 0.5
        dots.push({
          x: center.x,
          y: center.y,
          opacity: opacity,
          size: dotSize,
        })
      }
      return
    }

    // Otherwise, recurse into three new triangles without placing a dot here
    stippleRegion(p1, p2, center, depth + 1, maxDepth, regionBrightness)
    stippleRegion(p2, p3, center, depth + 1, maxDepth, regionBrightness)
    stippleRegion(p3, p1, center, depth + 1, maxDepth, regionBrightness)
  }

  function generate() {
    if (!sourceImage) return

    dots = []

    // Clear output canvas
    outputCtx.fillStyle = '#ebebeb'
    outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height)

    const w = outputCanvas.width
    const h = outputCanvas.height

    const cellW = w / gridSize
    const cellH = h / gridSize

    // Divide canvas into grid and analyze each cell
    for (let row = 0; row < gridSize; row++) {
      for (let col = 0; col < gridSize; col++) {
        const x = col * cellW
        const y = row * cellH

        // Get average brightness of this cell
        const brightness = getRegionBrightness(x, y, cellW, cellH)
        const darkness = 1 - brightness

        // Determine subdivision depth based on darkness
        // Darker regions get MORE subdivisions (more dots)
        // Light regions get FEWER subdivisions (fewer dots)
        const subdivDepth = Math.max(1, Math.floor(darkness * maxSubdivisions))

        // Create initial triangle for this cell
        const topLeft = { x: x, y: y }
        const topRight = { x: x + cellW, y: y }
        const bottomLeft = { x: x, y: y + cellH }
        const bottomRight = { x: x + cellW, y: y + cellH }
        const center = { x: x + cellW / 2, y: y + cellH / 2 }

        // Stipple this cell with triangulation
        stippleRegion(topLeft, topRight, center, 0, subdivDepth, brightness)
        stippleRegion(topRight, bottomRight, center, 0, subdivDepth, brightness)
        stippleRegion(bottomRight, bottomLeft, center, 0, subdivDepth, brightness)
        stippleRegion(bottomLeft, topLeft, center, 0, subdivDepth, brightness)
      }
    }

    console.log(`Generated ${dots.length} dots`)

    // Draw all dots
    dots.forEach((dot) => {
      outputCtx.fillStyle = `rgba(18, 18, 18, ${dot.opacity})`
      outputCtx.beginPath()
      outputCtx.arc(dot.x, dot.y, dot.size, 0, Math.PI * 2)
      outputCtx.fill()
    })
  }

  function loadImage(file: File) {
    const reader = new FileReader()
    reader.onload = (e) => {
      const img = new Image()
      img.onload = () => {
        sourceImage = img

        // Draw source image
        sourceCtx.fillStyle = '#ebebeb'
        sourceCtx.fillRect(0, 0, sourceCanvas.width, sourceCanvas.height)

        const scale = Math.min(sourceCanvas.width / img.width, sourceCanvas.height / img.height)
        const w = img.width * scale
        const h = img.height * scale
        const x = (sourceCanvas.width - w) / 2
        const y = (sourceCanvas.height - h) / 2

        sourceCtx.drawImage(img, x, y, w, h)

        // Get image data for brightness sampling
        imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height)

        generate()
      }
      img.src = e.target?.result as string
    }
    reader.readAsDataURL(file)
  }

  fileInput.addEventListener('change', (e) => {
    const target = e.target as HTMLInputElement
    if (target.files && target.files.length > 0) {
      loadImage(target.files[0])
    }
  })

  gridSizeSlider.addEventListener('input', (e) => {
    const target = e.target as HTMLInputElement
    gridSize = parseInt(target.value)
    gridSizeValue.textContent = gridSize.toString()
    if (sourceImage) generate()
  })

  subdivisionsSlider.addEventListener('input', (e) => {
    const target = e.target as HTMLInputElement
    maxSubdivisions = parseInt(target.value)
    subdivisionsValue.textContent = maxSubdivisions.toString()
    if (sourceImage) generate()
  })

  dotSizeSlider.addEventListener('input', (e) => {
    const target = e.target as HTMLInputElement
    dotSize = parseFloat(target.value)
    dotSizeValue.textContent = dotSize.toString()
    if (sourceImage) generate()
  })

  regenerateBtn.addEventListener('click', () => {
    if (sourceImage) generate()
  })

  // Load a default gradient to demonstrate
  function createDefaultImage() {
    sourceCtx.fillStyle = '#ebebeb'
    sourceCtx.fillRect(0, 0, sourceCanvas.width, sourceCanvas.height)

    // Create a circular gradient
    const gradient = sourceCtx.createRadialGradient(sourceCanvas.width / 2, sourceCanvas.height / 2, 50, sourceCanvas.width / 2, sourceCanvas.height / 2, 200)
    gradient.addColorStop(0, '#121212')
    gradient.addColorStop(1, '#ebebeb')

    sourceCtx.fillStyle = gradient
    sourceCtx.fillRect(0, 0, sourceCanvas.width, sourceCanvas.height)

    imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height)

    const img = new Image()
    img.src = sourceCanvas.toDataURL()
    img.onload = () => {
      sourceImage = img
      generate()
    }
  }

  // Initialize with default image
  createDefaultImage()
</script>

<style>
  .container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    align-items: center;
    width: 100%;
    max-width: 1800px;
    margin: 0 auto;
    padding: 20px;
    min-height: 100dvh;
  }

  .canvases {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    justify-content: center;
  }

  canvas {
    border: 2px solid var(--theme-border);
    border-radius: 8px;
    max-width: 100%;
    height: auto;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  }

  .controls {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }

  button {
    background: var(--theme-accent);
    color: var(--color-white);
    border: none;
    padding: 10px 20px;
    border-radius: 6px;
    font-family: var(--font-sans);
    font-size: 14px;
    cursor: pointer;
    transition: background 0.2s;
  }

  button:hover {
    background: var(--theme-accent-light);
  }

  button:active {
    background: var(--theme-accent-dark);
  }

  input[type='file'] {
    display: none;
  }

  label {
    color: var(--theme-text-subtle);
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  input[type='range'] {
    width: 150px;
  }

  .info {
    color: var(--theme-text-dim);
    font-size: 13px;
    text-align: center;
  }

  .file-label {
    background: var(--theme-accent);
    color: var(--color-white);
    padding: 10px 20px;
    border-radius: 6px;
    font-family: var(--font-sans);
    font-size: 14px;
    cursor: pointer;
    transition: background 0.2s;
  }

  .file-label:hover {
    background: var(--theme-accent-light);
  }
</style>
