---
import LabLayout from '../../layouts/LabLayout.astro'
---

<LabLayout title="Region Mapping & Stippling">
  <div class="main-layout">
    <aside class="sidebar">
      <div class="controls">
        <h2>Image Processing</h2>

        <div class="control-group">
          <label>Upload Image</label>
          <input type="file" id="imageInput" accept="image/*" />
        </div>

        <div class="control-group">
          <label>
            Region Size: <span class="slider-value" id="regionSizeValue">1</span>px
          </label>
          <input type="range" id="regionSize" min="1" max="12" value="1" step="1" />
        </div>

        <div class="control-group">
          <label>
            Brightness Levels: <span class="slider-value" id="levelsValue">10</span>
          </label>
          <input type="range" id="levels" min="1" max="50" value="10" step="1" />
        </div>

        <div class="control-group">
          <label>
            Diffusion Amount: <span class="slider-value" id="diffusionValue">0</span>
          </label>
          <input type="range" id="diffusion" min="0" max="10" value="0" step="1" />
        </div>

        <button id="processBtn" disabled>Process Region Map</button>
      </div>

      <div class="controls">
        <h2>Stippling Settings</h2>

        <div class="control-group">
          <label>Stippling Algorithm</label>
          <select id="algorithmSelect">
            <option value="density">Option 1: Direct Density Mapping</option>
            <option value="triangulation">Option 2: Region-Based Triangulation</option>
            <option value="poisson">Option 3: Poisson Disk Sampling</option>
            <option value="hybrid" selected>Option 4: Hybrid (Recommended)</option>
          </select>
        </div>

        <div class="control-group">
          <label>
            Dot Size: <span class="slider-value" id="dotSizeValue">0.8</span>px
          </label>
          <input type="range" id="dotSize" min="0.1" max="4" value="0.8" step="0.1" />
        </div>

        <div class="control-group">
          <label>
            Base Spacing: <span class="slider-value" id="minDistValue">1</span>px
          </label>
          <input type="range" id="minDist" min="0" max="16" value="1" step="0.1" />
        </div>

        <div class="control-group">
          <label>
            Darkness Threshold: <span class="slider-value" id="thresholdValue">0.01</span>
          </label>
          <input type="range" id="threshold" min="0" max="1" value="0.01" step="0.01" />
        </div>

        <div class="control-group">
          <label>
            Max Dots: <span class="slider-value" id="maxDotsValue">30000</span>
          </label>
          <input type="range" id="maxDots" min="500" max="50000" value="30000" step="500" />
        </div>

        <button id="stipplingBtn" disabled>Start Stippling</button>
        <button id="stopBtn" disabled>Stop</button>
        <button id="resetBtn" disabled>Reset Dots</button>

        <div class="info-box">
          <strong>Current dots: <span id="dotCount">0</span></strong>
        </div>
      </div>
    </aside>

    <div class="canvas-grid">
      <div class="canvas-container">
        <canvas id="originalCanvas"></canvas>
        <div class="info-box">
          <strong>Original source image</strong>
          <span class="description">Upload an image to begin</span>
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="brightnessCanvas"></canvas>
        <div class="info-box">
          <strong>Grayscale conversion</strong>
          <span class="description">Shows average brightness values</span>
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="quantizedCanvas"></canvas>
        <div class="info-box">
          <strong>Discrete brightness levels</strong>
          <span class="description">Image divided into <span id="currentLevels">5</span> brightness regions</span>
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="diffusedCanvas"></canvas>
        <div class="info-box">
          <strong>Smoothed transitions</strong>
          <span class="description">Gradual changes between regions</span>
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="thresholdCanvas"></canvas>
        <div class="info-box">
          <strong>Darkness threshold mask</strong>
          <span class="description">White areas receive dots, black areas do not</span>
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="stippledCanvas"></canvas>
        <div class="info-box">
          <strong>Dot placement visualization</strong>
          <span class="description">Algorithm: <span id="currentAlgorithm">Hybrid</span></span>
        </div>
      </div>
    </div>
  </div>
</LabLayout>

<script>
  const imageInput = document.getElementById('imageInput')
  const processBtn = document.getElementById('processBtn')
  const stipplingBtn = document.getElementById('stipplingBtn')
  const stopBtn = document.getElementById('stopBtn')
  const resetBtn = document.getElementById('resetBtn')
  const regionSizeSlider = document.getElementById('regionSize')
  const levelsSlider = document.getElementById('levels')
  const diffusionSlider = document.getElementById('diffusion')
  const algorithmSelect = document.getElementById('algorithmSelect')
  const dotSizeSlider = document.getElementById('dotSize')
  const minDistSlider = document.getElementById('minDist')
  const thresholdSlider = document.getElementById('threshold')
  const maxDotsSlider = document.getElementById('maxDots')

  const originalCanvas = document.getElementById('originalCanvas')
  const brightnessCanvas = document.getElementById('brightnessCanvas')
  const quantizedCanvas = document.getElementById('quantizedCanvas')
  const diffusedCanvas = document.getElementById('diffusedCanvas')
  const thresholdCanvas = document.getElementById('thresholdCanvas')
  const stippledCanvas = document.getElementById('stippledCanvas')

  // Get CSS variable values
  const rootStyles = getComputedStyle(document.documentElement)
  const colorBlack = rootStyles.getPropertyValue('--color-black').trim()
  const colorWhite = rootStyles.getPropertyValue('--color-white').trim()
  const colorGrayDark = rootStyles.getPropertyValue('--color-gray-dark').trim()
  const colorGrayDarker = rootStyles.getPropertyValue('--color-gray-darker').trim()

  // Initialize canvases with checkerboard pattern
  function initializeCanvas(canvas) {
    // Get the display size (CSS size) of the canvas
    const rect = canvas.getBoundingClientRect()
    const size = Math.max(rect.width, 300) // Minimum 300px, but grow with container

    canvas.width = size
    canvas.height = size

    const ctx = canvas.getContext('2d')
    const checkSize = 20 // Size of each checker square

    for (let y = 0; y < size; y += checkSize) {
      for (let x = 0; x < size; x += checkSize) {
        const isEven = (Math.floor(x / checkSize) + Math.floor(y / checkSize)) % 2 === 0
        ctx.fillStyle = isEven ? colorGrayDark : colorGrayDarker
        ctx.fillRect(x, y, checkSize, checkSize)
      }
    }
  }

  // Initialize all canvases
  initializeCanvas(originalCanvas)
  initializeCanvas(brightnessCanvas)
  initializeCanvas(quantizedCanvas)
  initializeCanvas(diffusedCanvas)
  initializeCanvas(thresholdCanvas)
  initializeCanvas(stippledCanvas)

  let currentImage = null
  let regionMapData = null
  let dots = []
  let isRunning = false
  let animationFrame = null
  let spatialGrid = null
  let gridCellSize = 0

  // Debounce utility
  function debounce(func, wait) {
    let timeout
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout)
        func(...args)
      }
      clearTimeout(timeout)
      timeout = setTimeout(later, wait)
    }
  }

  // Auto-process function (skips stippling)
  function autoProcess() {
    if (!currentImage) return

    const numLevels = parseInt(levelsSlider.value)
    const diffusionAmount = parseInt(diffusionSlider.value)

    // Step 1: Create brightness map
    const brightnessData = createBrightnessMap()

    // Step 2: Quantize into regions
    const regionMap = quantizeRegions(brightnessData, numLevels)

    // Step 3: Apply diffusion
    diffuseRegions(regionMap, diffusionAmount)

    // Step 4: Create threshold preview
    createThresholdPreview()
  }

  // Debounced version for sliders
  // const debouncedAutoProcess = debounce(autoProcess, 10)
  const debouncedAutoProcess = autoProcess

  // Update slider values
  regionSizeSlider.addEventListener('input', (e) => {
    document.getElementById('regionSizeValue').textContent = e.target.value
    debouncedAutoProcess()
  })

  levelsSlider.addEventListener('input', (e) => {
    document.getElementById('levelsValue').textContent = e.target.value
    document.getElementById('currentLevels').textContent = e.target.value
    debouncedAutoProcess()
  })

  diffusionSlider.addEventListener('input', (e) => {
    document.getElementById('diffusionValue').textContent = e.target.value
    debouncedAutoProcess()
  })

  dotSizeSlider.addEventListener('input', (e) => {
    document.getElementById('dotSizeValue').textContent = parseFloat(e.target.value).toFixed(1)
    // Redraw dots if they exist
    if (dots.length > 0) {
      drawDots()
    }
  })

  minDistSlider.addEventListener('input', (e) => {
    document.getElementById('minDistValue').textContent = parseFloat(e.target.value).toFixed(1)
    // No auto-update for stippling parameters
  })

  thresholdSlider.addEventListener('input', (e) => {
    document.getElementById('thresholdValue').textContent = e.target.value
    createThresholdPreview()
  })

  maxDotsSlider.addEventListener('input', (e) => {
    document.getElementById('maxDotsValue').textContent = e.target.value
    // No auto-update for stippling parameters
  })

  algorithmSelect.addEventListener('change', (e) => {
    const algoNames = {
      density: 'Direct Density Mapping',
      triangulation: 'Region-Based Triangulation',
      poisson: 'Poisson Disk Sampling',
      hybrid: 'Hybrid',
    }
    document.getElementById('currentAlgorithm').textContent = algoNames[e.target.value]
  })

  // Handle image upload
  imageInput.addEventListener('change', (e) => {
    const file = e.target.files[0]
    if (!file) return

    const reader = new FileReader()
    reader.onload = (event) => {
      const img = new Image()
      img.onload = () => {
        currentImage = img

        processBtn.disabled = false
        drawOriginalImage()
        autoProcess()

        stipplingBtn.disabled = false
        resetBtn.disabled = false
      }
      img.src = event.target.result
    }
    reader.readAsDataURL(file)
  })

  // Draw original image
  function drawOriginalImage() {
    const ctx = originalCanvas.getContext('2d')
    const maxWidth = 500
    const scale = Math.min(1, maxWidth / currentImage.width)

    originalCanvas.width = currentImage.width * scale
    originalCanvas.height = currentImage.height * scale

    ctx.drawImage(currentImage, 0, 0, originalCanvas.width, originalCanvas.height)
  }

  // Get brightness value from RGB
  function getBrightness(r, g, b) {
    return (r + g + b) / 3
  }

  // Process image into brightness map
  function createBrightnessMap() {
    const ctx = originalCanvas.getContext('2d', { willReadFrequently: true })
    const imageData = ctx.getImageData(0, 0, originalCanvas.width, originalCanvas.height)
    const data = imageData.data
    const width = originalCanvas.width
    const height = originalCanvas.height

    // Create brightness canvas
    brightnessCanvas.width = width
    brightnessCanvas.height = height
    const brightCtx = brightnessCanvas.getContext('2d')
    const brightImageData = brightCtx.createImageData(width, height)
    const brightData = brightImageData.data

    // Convert to grayscale brightness
    for (let i = 0; i < data.length; i += 4) {
      const brightness = getBrightness(data[i], data[i + 1], data[i + 2])
      brightData[i] = brightness
      brightData[i + 1] = brightness
      brightData[i + 2] = brightness
      brightData[i + 3] = 255
    }

    brightCtx.putImageData(brightImageData, 0, 0)
    return brightImageData
  }

  // Quantize into discrete regions
  function quantizeRegions(brightnessData, numLevels) {
    const regionSize = parseInt(regionSizeSlider.value)
    const width = brightnessData.width
    const height = brightnessData.height
    const data = brightnessData.data

    quantizedCanvas.width = width
    quantizedCanvas.height = height
    const ctx = quantizedCanvas.getContext('2d')
    const quantizedImageData = ctx.createImageData(width, height)
    const quantizedData = quantizedImageData.data

    // Create grid of regions
    const cols = Math.ceil(width / regionSize)
    const rows = Math.ceil(height / regionSize)
    const regionMap = []

    // Calculate average brightness for each region
    for (let ry = 0; ry < rows; ry++) {
      regionMap[ry] = []
      for (let rx = 0; rx < cols; rx++) {
        let sum = 0
        let count = 0

        // Sample all pixels in this region
        for (let py = ry * regionSize; py < Math.min((ry + 1) * regionSize, height); py++) {
          for (let px = rx * regionSize; px < Math.min((rx + 1) * regionSize, width); px++) {
            const idx = (py * width + px) * 4
            sum += data[idx]
            count++
          }
        }

        const avgBrightness = sum / count

        // Quantize to discrete level
        const level = Math.floor((avgBrightness / 255) * numLevels)
        const quantizedValue = (level / numLevels) * 255

        regionMap[ry][rx] = {
          brightness: quantizedValue,
          level: level,
        }
      }
    }

    // Draw quantized regions
    for (let ry = 0; ry < rows; ry++) {
      for (let rx = 0; rx < cols; rx++) {
        const value = regionMap[ry][rx].brightness

        for (let py = ry * regionSize; py < Math.min((ry + 1) * regionSize, height); py++) {
          for (let px = rx * regionSize; px < Math.min((rx + 1) * regionSize, width); px++) {
            const idx = (py * width + px) * 4
            quantizedData[idx] = value
            quantizedData[idx + 1] = value
            quantizedData[idx + 2] = value
            quantizedData[idx + 3] = 255
          }
        }
      }
    }

    ctx.putImageData(quantizedImageData, 0, 0)
    return regionMap
  }

  // Apply diffusion for smooth transitions
  function diffuseRegions(regionMap, diffusionAmount) {
    if (diffusionAmount === 0) {
      // No diffusion, just copy quantized
      const ctx = quantizedCanvas.getContext('2d', { willReadFrequently: true })
      const quantizedData = ctx.getImageData(0, 0, quantizedCanvas.width, quantizedCanvas.height)
      const diffusedCtx = diffusedCanvas.getContext('2d')
      diffusedCanvas.width = quantizedCanvas.width
      diffusedCanvas.height = quantizedCanvas.height
      diffusedCtx.putImageData(quantizedData, 0, 0)
      regionMapData = quantizedData
      return
    }

    const rows = regionMap.length
    const cols = regionMap[0].length
    const regionSize = parseInt(regionSizeSlider.value)
    const width = quantizedCanvas.width
    const height = quantizedCanvas.height

    diffusedCanvas.width = width
    diffusedCanvas.height = height
    const ctx = diffusedCanvas.getContext('2d')
    const diffusedImageData = ctx.createImageData(width, height)
    const diffusedData = diffusedImageData.data

    // Apply gaussian-like blur multiple times
    let currentMap = regionMap.map((row) => row.map((cell) => cell.brightness))

    for (let iteration = 0; iteration < diffusionAmount; iteration++) {
      const newMap = []

      for (let ry = 0; ry < rows; ry++) {
        newMap[ry] = []
        for (let rx = 0; rx < cols; rx++) {
          let sum = currentMap[ry][rx]
          let count = 1

          // Average with neighbors
          const neighbors = [
            [-1, -1],
            [-1, 0],
            [-1, 1],
            [0, -1],
            [0, 1],
            [1, -1],
            [1, 0],
            [1, 1],
          ]

          for (const [dy, dx] of neighbors) {
            const ny = ry + dy
            const nx = rx + dx
            if (ny >= 0 && ny < rows && nx >= 0 && nx < cols) {
              sum += currentMap[ny][nx]
              count++
            }
          }

          newMap[ry][rx] = sum / count
        }
      }

      currentMap = newMap
    }

    // Draw diffused regions
    for (let ry = 0; ry < rows; ry++) {
      for (let rx = 0; rx < cols; rx++) {
        const value = currentMap[ry][rx]

        for (let py = ry * regionSize; py < Math.min((ry + 1) * regionSize, height); py++) {
          for (let px = rx * regionSize; px < Math.min((rx + 1) * regionSize, width); px++) {
            const idx = (py * width + px) * 4
            diffusedData[idx] = value
            diffusedData[idx + 1] = value
            diffusedData[idx + 2] = value
            diffusedData[idx + 3] = 255
          }
        }
      }
    }

    ctx.putImageData(diffusedImageData, 0, 0)
    regionMapData = diffusedImageData
  }

  // Create threshold preview showing which areas will receive dots
  function createThresholdPreview() {
    if (!regionMapData) return

    const threshold = parseFloat(thresholdSlider.value)
    const width = regionMapData.width
    const height = regionMapData.height
    const data = regionMapData.data

    thresholdCanvas.width = width
    thresholdCanvas.height = height
    const ctx = thresholdCanvas.getContext('2d')
    const thresholdImageData = ctx.createImageData(width, height)
    const thresholdData = thresholdImageData.data

    // Create black/white mask based on threshold
    for (let i = 0; i < data.length; i += 4) {
      const brightness = data[i]
      const lightness = brightness / 255

      // White if above threshold (will receive dots), black if below (pure black)
      const value = lightness >= threshold ? 255 : 0

      thresholdData[i] = value
      thresholdData[i + 1] = value
      thresholdData[i + 2] = value
      thresholdData[i + 3] = 255
    }

    ctx.putImageData(thresholdImageData, 0, 0)
  }

  // Process button
  processBtn.addEventListener('click', () => {
    if (!currentImage) return

    const numLevels = parseInt(levelsSlider.value)
    const diffusionAmount = parseInt(diffusionSlider.value)

    // Step 1: Create brightness map
    const brightnessData = createBrightnessMap()

    // Step 2: Quantize into regions
    const regionMap = quantizeRegions(brightnessData, numLevels)

    // Step 3: Apply diffusion
    diffuseRegions(regionMap, diffusionAmount)

    // Step 4: Create threshold preview
    createThresholdPreview()
  })

  // ========== STIPPLING ALGORITHMS ==========

  // Spatial grid for fast nearest neighbor queries
  function initializeSpatialGrid(width, height, minDist) {
    gridCellSize = Math.max(minDist * 2, 10)
    const cols = Math.ceil(width / gridCellSize)
    const rows = Math.ceil(height / gridCellSize)
    spatialGrid = Array.from({ length: rows }, () => Array.from({ length: cols }, () => []))
  }

  function addToGrid(dot) {
    if (!spatialGrid || !gridCellSize) return
    const col = Math.floor(dot.x / gridCellSize)
    const row = Math.floor(dot.y / gridCellSize)
    // Bounds check
    if (row >= 0 && row < spatialGrid.length && col >= 0 && col < spatialGrid[0].length) {
      spatialGrid[row][col].push(dot)
    }
  }

  function clearGrid() {
    if (spatialGrid) {
      for (let row of spatialGrid) {
        for (let cell of row) {
          cell.length = 0
        }
      }
    }
  }

  // Fast distance check using spatial grid - returns squared distance to nearest dot
  function getNearestDotDistSq(x, y) {
    if (!spatialGrid || dots.length === 0) return Infinity

    const col = Math.floor(x / gridCellSize)
    const row = Math.floor(y / gridCellSize)
    let minDistSq = Infinity

    // Check neighboring cells (3x3 grid around point)
    for (let dr = -1; dr <= 1; dr++) {
      for (let dc = -1; dc <= 1; dc++) {
        const r = row + dr
        const c = col + dc
        if (r >= 0 && r < spatialGrid.length && c >= 0 && c < spatialGrid[0].length) {
          const cellDots = spatialGrid[r][c]
          for (const dot of cellDots) {
            const dx = dot.x - x
            const dy = dot.y - y
            const distSq = dx * dx + dy * dy
            if (distSq < minDistSq) {
              minDistSq = distSq
            }
          }
        }
      }
    }

    return minDistSq
  }

  // Check if point is too close to any existing dot using spatial grid
  function isTooClose(x, y, minDistSq) {
    return getNearestDotDistSq(x, y) < minDistSq
  }

  function getRegionBrightness(x, y) {
    if (!regionMapData) return 255
    const width = regionMapData.width
    const height = regionMapData.height
    const px = Math.max(0, Math.min(Math.floor(x), width - 1))
    const py = Math.max(0, Math.min(Math.floor(y), height - 1))
    const idx = (py * width + px) * 4
    return regionMapData.data[idx]
  }

  function drawDots() {
    const ctx = stippledCanvas.getContext('2d')
    // Fill with dark background
    ctx.fillStyle = colorBlack
    ctx.fillRect(0, 0, stippledCanvas.width, stippledCanvas.height)

    // Draw light dots on top
    ctx.fillStyle = colorWhite
    const dotSize = parseFloat(dotSizeSlider.value)

    dots.forEach((dot) => {
      ctx.beginPath()
      ctx.arc(dot.x, dot.y, dotSize, 0, Math.PI * 2)
      ctx.fill()
    })

    document.getElementById('dotCount').textContent = dots.length
  }

  // Algorithm 1: Direct Density Mapping
  function addDotDensity() {
    const width = stippledCanvas.width
    const height = stippledCanvas.height
    const baseMinDist = parseFloat(minDistSlider.value)
    const lightnessThreshold = parseFloat(thresholdSlider.value)

    // Sample random points weighted by brightness (bright areas get more dots)
    for (let attempt = 0; attempt < 20; attempt++) {
      const x = Math.random() * width
      const y = Math.random() * height
      const brightness = getRegionBrightness(x, y)
      const lightness = brightness / 255

      // Skip if too dark
      if (lightness < lightnessThreshold) continue

      // Weight by lightness - brighter areas are more likely to accept dots
      if (Math.random() > lightness) continue

      // Variable min distance based on brightness - bright areas get smaller minDist
      const variableMinDistSq = Math.pow(baseMinDist * (3.0 - lightness * 2.8), 2)

      // Use spatial grid for fast distance check
      if (!isTooClose(x, y, variableMinDistSq)) {
        const dot = { x, y }
        dots.push(dot)
        addToGrid(dot)
        return true
      }
    }
    return false
  }
  // Algorithm 2: Region-Based Triangulation
  function addDotTriangulation() {
    const width = stippledCanvas.width
    const height = stippledCanvas.height
    const baseMinDist = parseInt(minDistSlider.value)
    const lightnessThreshold = parseFloat(thresholdSlider.value)

    // Find largest void
    let bestPoint = null
    let bestLightness = 0
    let maxMinDist = 0

    for (let attempt = 0; attempt < 30; attempt++) {
      const x = Math.random() * width
      const y = Math.random() * height
      const brightness = getRegionBrightness(x, y)
      const lightness = brightness / 255

      // Skip if too dark
      if (lightness < lightnessThreshold) continue

      const minDistSq = getNearestDotDistSq(x, y)
      const weighted = minDistSq * lightness

      if (weighted > maxMinDist) {
        maxMinDist = weighted
        bestPoint = { x, y }
        bestLightness = lightness
      }
    }

    if (!bestPoint || dots.length < 3) {
      if (bestPoint && bestLightness >= lightnessThreshold) {
        dots.push(bestPoint)
        addToGrid(bestPoint)
      }
      return true
    }

    // Find 3 nearest dots - use spatial grid
    const col = Math.floor(bestPoint.x / gridCellSize)
    const row = Math.floor(bestPoint.y / gridCellSize)
    const searchRadius = 5 // Check 5 cells in each direction

    const nearbyDots = []
    for (let dr = -searchRadius; dr <= searchRadius; dr++) {
      for (let dc = -searchRadius; dc <= searchRadius; dc++) {
        const r = row + dr
        const c = col + dc
        if (spatialGrid && r >= 0 && r < spatialGrid.length && c >= 0 && c < spatialGrid[0].length) {
          nearbyDots.push(...spatialGrid[r][c])
        }
      }
    }

    if (nearbyDots.length < 3) {
      // Not enough nearby dots, just place at bestPoint
      const variableMinDistSq = Math.pow(baseMinDist * (3.0 - bestLightness * 2.8), 2)
      if (!isTooClose(bestPoint.x, bestPoint.y, variableMinDistSq)) {
        dots.push(bestPoint)
        addToGrid(bestPoint)
        return true
      }
      return false
    }

    const nearest = nearbyDots
      .map((dot) => ({
        dot,
        dist: (dot.x - bestPoint.x) ** 2 + (dot.y - bestPoint.y) ** 2,
      }))
      .sort((a, b) => a.dist - b.dist)
      .slice(0, 3)

    // Triangulate
    const centroid = {
      x: (nearest[0].dot.x + nearest[1].dot.x + nearest[2].dot.x) / 3,
      y: (nearest[0].dot.y + nearest[1].dot.y + nearest[2].dot.y) / 3,
    }

    // Check brightness at centroid and calculate variable min distance
    const centroidBrightness = getRegionBrightness(centroid.x, centroid.y)
    const centroidLightness = centroidBrightness / 255
    if (centroidLightness < lightnessThreshold) return false

    // Variable min distance based on centroid brightness
    const variableMinDistSq = Math.pow(baseMinDist * (3.0 - centroidLightness * 2.8), 2)

    // Use spatial grid for distance check
    if (!isTooClose(centroid.x, centroid.y, variableMinDistSq)) {
      dots.push(centroid)
      addToGrid(centroid)
      return true
    }
    return false
  }
  // Algorithm 3: Poisson Disk Sampling
  function addDotPoisson() {
    const width = stippledCanvas.width
    const height = stippledCanvas.height
    const lightnessThreshold = parseFloat(thresholdSlider.value)

    for (let attempt = 0; attempt < 30; attempt++) {
      const x = Math.random() * width
      const y = Math.random() * height
      const brightness = getRegionBrightness(x, y)
      const lightness = brightness / 255

      // Skip if too dark
      if (lightness < lightnessThreshold) continue

      // Variable radius based on brightness - bright areas get tighter spacing (smaller minDist)
      const baseMinDist = parseInt(minDistSlider.value)
      const variableMinDistSq = Math.pow(baseMinDist * (3.0 - lightness * 2.8), 2)

      // Use spatial grid for fast distance check
      if (!isTooClose(x, y, variableMinDistSq)) {
        const dot = { x, y }
        dots.push(dot)
        addToGrid(dot)
        return true
      }
    }
    return false
  }

  // Algorithm 4: Hybrid (Optimized)
  function addDotHybrid() {
    const width = stippledCanvas.width
    const height = stippledCanvas.height
    const baseMinDist = parseInt(minDistSlider.value)
    const lightnessThreshold = parseFloat(thresholdSlider.value)

    // Sample points weighted by lightness
    let bestPoint = null
    let bestLightness = 0
    let bestMinDistSq = 0 // Memoize for reuse (Optimization 2)
    let maxScore = 0

    // Optimization 3: Early exit if we've hit max dots
    const maxDots = parseInt(maxDotsSlider.value)
    if (dots.length >= maxDots) return false

    for (let attempt = 0; attempt < 30; attempt++) {
      const x = Math.random() * width
      const y = Math.random() * height
      const brightness = getRegionBrightness(x, y)
      const lightness = brightness / 255

      // Optimization 3: Early exit if too dark
      if (lightness < lightnessThreshold) continue

      // Optimization 1: Use spatial grid for fast nearest neighbor query
      const minDistSq = getNearestDotDistSq(x, y)

      const score = minDistSq * (0.3 + lightness * 0.7)
      if (score > maxScore) {
        maxScore = score
        bestPoint = { x, y }
        bestLightness = lightness
        bestMinDistSq = minDistSq // Store for later reuse
      }
    }

    if (!bestPoint || bestLightness < lightnessThreshold) return false

    // If we have enough dots, triangulate
    if (dots.length >= 3) {
      // Find 3 nearest dots using spatial grid
      // Cap search radius to prevent infinite loops when dots are sparse or bestMinDistSq is Infinity
      const searchRadius = isFinite(bestMinDistSq) ? Math.min(Math.sqrt(bestMinDistSq) * 3, baseMinDist * 20) : baseMinDist * 10 // Reasonable default when no nearby dots
      const col = Math.floor(bestPoint.x / gridCellSize)
      const row = Math.floor(bestPoint.y / gridCellSize)
      const cellRadius = Math.min(Math.ceil(searchRadius / gridCellSize), 10) // Cap at 10 cells

      const nearbyDots = []
      for (let dr = -cellRadius; dr <= cellRadius; dr++) {
        for (let dc = -cellRadius; dc <= cellRadius; dc++) {
          const r = row + dr
          const c = col + dc
          if (spatialGrid && r >= 0 && r < spatialGrid.length && c >= 0 && c < spatialGrid[0].length) {
            nearbyDots.push(...spatialGrid[r][c])
          }
        }
      }

      if (nearbyDots.length >= 3) {
        const nearest = nearbyDots
          .map((dot) => ({
            dot,
            dist: (dot.x - bestPoint.x) ** 2 + (dot.y - bestPoint.y) ** 2,
          }))
          .sort((a, b) => a.dist - b.dist)
          .slice(0, 3)

        const centroid = {
          x: (nearest[0].dot.x + nearest[1].dot.x + nearest[2].dot.x) / 3,
          y: (nearest[0].dot.y + nearest[1].dot.y + nearest[2].dot.y) / 3,
        }

        // Check brightness at centroid
        const centroidBrightness = getRegionBrightness(centroid.x, centroid.y)
        const centroidLightness = centroidBrightness / 255

        if (centroidLightness >= lightnessThreshold) {
          // Variable min distance based on centroid brightness
          const variableMinDistSq = Math.pow(baseMinDist * (3.0 - centroidLightness * 2.8), 2)

          // Optimization 1: Use spatial grid for distance check
          if (!isTooClose(centroid.x, centroid.y, variableMinDistSq)) {
            dots.push(centroid)
            addToGrid(centroid)
            return true
          }
        }
      }
    }

    // Fallback: place at best point with variable minDist
    const fallbackMinDistSq = Math.pow(baseMinDist * (3.0 - bestLightness * 2.8), 2)

    // Optimization 1 & 2: Use spatial grid and already-computed distance
    if (bestMinDistSq >= fallbackMinDistSq && bestLightness >= lightnessThreshold) {
      dots.push(bestPoint)
      addToGrid(bestPoint)
      return true
    }

    return false
  }
  // Animation loop (Optimization 4: Improved batch processing)
  function animate() {
    if (!isRunning) {
      console.log('[ANIMATE] isRunning is false, stopping')
      return
    }

    const maxDots = parseInt(maxDotsSlider.value)
    if (dots.length >= maxDots) {
      console.log('[ANIMATE] Max dots reached:', dots.length, '>=', maxDots)
      stopStippling()
      return
    }

    // Optimization 4: Adaptive batch size - start with more dots per frame, reduce as we get fuller
    const fillRatio = dots.length / maxDots
    const batchSize = fillRatio < 0.5 ? 20 : fillRatio < 0.8 ? 10 : 5

    const startTime = performance.now()
    let successCount = 0
    let attemptCount = 0
    const maxAttempts = batchSize * 3 // Allow some failures before giving up

    console.log('[ANIMATE] Batch starting. Dots:', dots.length, 'FillRatio:', fillRatio.toFixed(2), 'BatchSize:', batchSize)

    while (successCount < batchSize && attemptCount < maxAttempts && dots.length < maxDots) {
      const algorithm = algorithmSelect.value
      let success = false

      switch (algorithm) {
        case 'density':
          success = addDotDensity()
          break
        case 'triangulation':
          success = addDotTriangulation()
          break
        case 'poisson':
          success = addDotPoisson()
          break
        case 'hybrid':
          success = addDotHybrid()
          break
      }

      if (success) successCount++
      attemptCount++

      // Emergency brake - if batch takes > 100ms, something's wrong
      if (performance.now() - startTime > 100) {
        console.error('[ANIMATE] Batch timeout! Took more than 100ms. SuccessCount:', successCount, 'AttemptCount:', attemptCount)
        break
      }
    }

    const elapsed = performance.now() - startTime
    console.log('[ANIMATE] Batch complete. Success:', successCount, 'Attempts:', attemptCount, 'Time:', elapsed.toFixed(2), 'ms')

    drawDots()
    animationFrame = requestAnimationFrame(animate)
  }

  function startStippling() {
    console.log('[START] Starting stippling...')
    if (!regionMapData) {
      console.error('[START] No regionMapData!')
      return
    }

    stippledCanvas.width = diffusedCanvas.width
    stippledCanvas.height = diffusedCanvas.height
    console.log('[START] Canvas size:', stippledCanvas.width, 'x', stippledCanvas.height)

    // Initialize spatial grid with canvas dimensions
    const baseMinDist = parseFloat(minDistSlider.value)
    console.log('[START] Base min distance:', baseMinDist)
    initializeSpatialGrid(stippledCanvas.width, stippledCanvas.height, baseMinDist)
    console.log('[START] Grid initialized. Cell size:', gridCellSize, 'Grid dimensions:', spatialGrid?.length, 'x', spatialGrid?.[0]?.length)

    isRunning = true
    stipplingBtn.disabled = true
    stopBtn.disabled = false
    console.log('[START] Calling animate()...')
    animate()
  }

  function stopStippling() {
    isRunning = false
    stipplingBtn.disabled = false
    stopBtn.disabled = true
    if (animationFrame) {
      cancelAnimationFrame(animationFrame)
      animationFrame = null
    }
  }

  function resetDots() {
    stopStippling()
    dots = []
    clearGrid() // Clear the spatial grid
    const ctx = stippledCanvas.getContext('2d')
    // Reset to dark background
    ctx.fillStyle = colorBlack
    ctx.fillRect(0, 0, stippledCanvas.width, stippledCanvas.height)
    document.getElementById('dotCount').textContent = '0'
  }

  stipplingBtn.addEventListener('click', startStippling)
  stopBtn.addEventListener('click', stopStippling)
  resetBtn.addEventListener('click', resetDots)
</script>

<style>
  header {
    text-align: center;
    margin-bottom: 2rem;
  }

  h1 {
    font-weight: 600;
    margin-bottom: 0.5rem;
  }

  .subtitle {
    color: var(--theme-text-subtle);
    font-size: 0.875rem;
  }

  .main-layout {
    margin: 0.5rem;
    margin-right: 1rem;
    display: flex;
    gap: 1rem;
    flex-direction: column;
  }

  @media (min-width: 1024px) {
    .main-layout {
      flex-direction: row;
      align-items: flex-start;
    }
  }

  .sidebar {
    display: flex;
    flex-direction: column;

    @media (min-width: 1024px) {
      flex: 0 0 auto;
      top: 1rem;
      margin: 0 1rem;
    }
  }

  .controls {
    &:not(:last-child) {
      padding-bottom: 1rem;
    }

    + .controls {
      border-top: 1px solid var(--theme-border);
      padding-top: 1rem;
    }
  }

  .controls h2 {
    margin-bottom: 1rem;
    font-size: 1rem;
    font-weight: 600;
  }

  .control-group {
    margin-bottom: 0.25rem;
    flex-shrink: 0;
  }

  .control-group label {
    display: block;
    color: var(--theme-text-subtle);
  }

  input[type='file'] {
    width: 100%;
    padding: 0.5rem;
    border: 2px dashed var(--theme-border);
    border-radius: 0.25rem;
    font-size: 0.75rem;
    cursor: pointer;
    color: var(--theme-text);
  }

  input[type='range'] {
    accent-color: var(--theme-text-dim);
    width: 100%;
  }

  .control-group select {
    width: 100%;
    padding: 0.625rem;
    border: 1px solid var(--theme-border);
    border-radius: 6px;
    background: var(--theme-bg);
    color: var(--theme-text);
    font-size: 0.875rem;
    cursor: pointer;
  }

  .slider-value {
    display: inline-block;
    color: var(--theme-accent);
    font-family: var(--font-mono);
    font-size: 1.2rem;
    margin-left: 0.5rem;
  }

  button {
    background: var(--theme-accent);
    color: var(--color-white);
    border: none;
    padding: 0.25rem 0.75rem;
    border-radius: 6px;
    font-size: 0.75rem;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s;
    margin-right: 0.5rem;
  }

  button:hover {
    background: var(--theme-accent-light);
  }

  button:active {
    background: var(--theme-accent-dark);
  }

  button:disabled {
    background: var(--color-gray);
    cursor: not-allowed;
    opacity: 0.5;
  }

  .canvas-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 0.5rem;

    @media (min-width: 480px) {
      grid-template-columns: repeat(1, 1fr);
    }

    @media (min-width: 640px) {
      grid-template-columns: repeat(2, 1fr);
    }

    @media (min-width: 768px) {
      flex: 1;
      grid-template-columns: repeat(2, 1fr);
    }

    @media (min-width: 1440px) {
      grid-template-columns: repeat(3, 1fr);
    }

    @media (min-width: 2000px) {
      grid-template-columns: repeat(4, 1fr);
    }
  }

  .canvas-container {
    display: flex;
    flex-direction: column;
    min-width: 0; /* Allow flex items to shrink below content size */
  }

  canvas {
    width: 100%;
    height: auto;
    aspect-ratio: 1 / 1; /* Maintain square aspect ratio */
    display: block;
    object-fit: contain;
    border-radius: 0.25rem;
  }

  .info-box {
    background: var(--theme-bg);
    color: var(--theme-text-dim);
    line-height: 1.2;
    margin-top: 0.25rem;

    .description {
      font-size: 0.85rem;
    }
  }

  .info-box strong {
    display: block;
    color: var(--theme-text);
  }
</style>
