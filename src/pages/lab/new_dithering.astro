---
import Layout from '../../layouts/Layout.astro'
---

<Layout title="Region Mapping & Stippling">
  <div class="container">
    <header>
      <h1>Region Mapping & Stippling</h1>
      <p class="subtitle">Segment images into brightness regions and apply different stippling algorithms</p>
    </header>

    <div class="controls-wrapper">
      <div class="controls">
        <div class="control-group">
          <label>Upload Image</label>
          <input type="file" id="imageInput" accept="image/*" />
        </div>

        <div class="control-group">
          <label>
            Region Size: <span class="slider-value" id="regionSizeValue">20</span>px
          </label>
          <input type="range" id="regionSize" min="1" max="50" value="20" step="1" />
        </div>

        <div class="control-group">
          <label>
            Brightness Levels: <span class="slider-value" id="levelsValue">5</span>
          </label>
          <input type="range" id="levels" min="3" max="10" value="5" step="1" />
        </div>

        <div class="control-group">
          <label>
            Diffusion Amount: <span class="slider-value" id="diffusionValue">3</span>
          </label>
          <input type="range" id="diffusion" min="0" max="10" value="3" step="1" />
        </div>

        <button id="processBtn" disabled>Process Region Map</button>
      </div>

      <div class="controls">
        <h2>Stippling Settings</h2>

        <div class="control-group">
          <label>Stippling Algorithm</label>
          <select id="algorithmSelect">
            <option value="density">Option 1: Direct Density Mapping</option>
            <option value="triangulation">Option 2: Region-Based Triangulation</option>
            <option value="poisson">Option 3: Poisson Disk Sampling</option>
            <option value="hybrid" selected>Option 4: Hybrid (Recommended)</option>
          </select>
        </div>

        <div class="control-group">
          <label>
            Dot Size: <span class="slider-value" id="dotSizeValue">1.5</span>px
          </label>
          <input type="range" id="dotSize" min="0.5" max="4" value="1.5" step="0.5" />
        </div>

        <div class="control-group">
          <label>
            Min Distance: <span class="slider-value" id="minDistValue">6</span>px
          </label>
          <input type="range" id="minDist" min="2" max="15" value="6" step="1" />
        </div>

        <div class="control-group">
          <label>
            Max Dots: <span class="slider-value" id="maxDotsValue">3000</span>
          </label>
          <input type="range" id="maxDots" min="500" max="50000" value="3000" step="500" />
        </div>

        <div class="control-group">
          <button id="stipplingBtn" disabled>Start Stippling</button>
          <button id="stopBtn" disabled>Stop</button>
          <button id="resetBtn" disabled>Reset Dots</button>
        </div>

        <div class="info-box">
          <strong>Current dots: <span id="dotCount">0</span></strong>
        </div>
      </div>
    </div>

    <div class="canvas-grid">
      <div class="canvas-container">
        <h3>Original Image</h3>
        <canvas id="originalCanvas"></canvas>
        <div class="info-box">
          <strong>Original source image</strong>
          Upload an image to begin
        </div>
      </div>

      <div class="canvas-container">
        <h3>Brightness Map</h3>
        <canvas id="brightnessCanvas"></canvas>
        <div class="info-box">
          <strong>Grayscale conversion</strong>
          Shows average brightness values
        </div>
      </div>

      <div class="canvas-container">
        <h3>Region Map (Quantized)</h3>
        <canvas id="quantizedCanvas"></canvas>
        <div class="info-box">
          <strong>Discrete brightness levels</strong>
          Image divided into <span id="currentLevels">5</span> brightness regions
        </div>
      </div>

      <div class="canvas-container">
        <h3>Region Map (Diffused)</h3>
        <canvas id="diffusedCanvas"></canvas>
        <div class="info-box">
          <strong>Smoothed transitions</strong>
          Gradual changes between regions
        </div>
      </div>

      <div class="canvas-container">
        <h3>Stippled Result</h3>
        <canvas id="stippledCanvas"></canvas>
        <div class="info-box">
          <strong>Dot placement visualization</strong>
          Algorithm: <span id="currentAlgorithm">Hybrid</span>
        </div>
      </div>
    </div>
  </div>
</Layout>

<script>
  const imageInput = document.getElementById('imageInput')
  const processBtn = document.getElementById('processBtn')
  const stipplingBtn = document.getElementById('stipplingBtn')
  const stopBtn = document.getElementById('stopBtn')
  const resetBtn = document.getElementById('resetBtn')
  const regionSizeSlider = document.getElementById('regionSize')
  const levelsSlider = document.getElementById('levels')
  const diffusionSlider = document.getElementById('diffusion')
  const algorithmSelect = document.getElementById('algorithmSelect')
  const dotSizeSlider = document.getElementById('dotSize')
  const minDistSlider = document.getElementById('minDist')
  const maxDotsSlider = document.getElementById('maxDots')

  const originalCanvas = document.getElementById('originalCanvas')
  const brightnessCanvas = document.getElementById('brightnessCanvas')
  const quantizedCanvas = document.getElementById('quantizedCanvas')
  const diffusedCanvas = document.getElementById('diffusedCanvas')
  const stippledCanvas = document.getElementById('stippledCanvas')

  let currentImage = null
  let regionMapData = null
  let dots = []
  let isRunning = false
  let animationFrame = null

  // Update slider values
  regionSizeSlider.addEventListener('input', (e) => {
    document.getElementById('regionSizeValue').textContent = e.target.value
  })

  levelsSlider.addEventListener('input', (e) => {
    document.getElementById('levelsValue').textContent = e.target.value
    document.getElementById('currentLevels').textContent = e.target.value
  })

  diffusionSlider.addEventListener('input', (e) => {
    document.getElementById('diffusionValue').textContent = e.target.value
  })

  dotSizeSlider.addEventListener('input', (e) => {
    document.getElementById('dotSizeValue').textContent = e.target.value
  })

  minDistSlider.addEventListener('input', (e) => {
    document.getElementById('minDistValue').textContent = e.target.value
  })

  maxDotsSlider.addEventListener('input', (e) => {
    document.getElementById('maxDotsValue').textContent = e.target.value
  })

  algorithmSelect.addEventListener('change', (e) => {
    const algoNames = {
      density: 'Direct Density Mapping',
      triangulation: 'Region-Based Triangulation',
      poisson: 'Poisson Disk Sampling',
      hybrid: 'Hybrid',
    }
    document.getElementById('currentAlgorithm').textContent = algoNames[e.target.value]
  })

  // Handle image upload
  imageInput.addEventListener('change', (e) => {
    const file = e.target.files[0]
    if (!file) return

    const reader = new FileReader()
    reader.onload = (event) => {
      const img = new Image()
      img.onload = () => {
        currentImage = img
        processBtn.disabled = false
        drawOriginalImage()
      }
      img.src = event.target.result
    }
    reader.readAsDataURL(file)
  })

  // Draw original image
  function drawOriginalImage() {
    const ctx = originalCanvas.getContext('2d')
    const maxWidth = 500
    const scale = Math.min(1, maxWidth / currentImage.width)

    originalCanvas.width = currentImage.width * scale
    originalCanvas.height = currentImage.height * scale

    ctx.drawImage(currentImage, 0, 0, originalCanvas.width, originalCanvas.height)
  }

  // Get brightness value from RGB
  function getBrightness(r, g, b) {
    return (r + g + b) / 3
  }

  // Process image into brightness map
  function createBrightnessMap() {
    const ctx = originalCanvas.getContext('2d')
    const imageData = ctx.getImageData(0, 0, originalCanvas.width, originalCanvas.height)
    const data = imageData.data
    const width = originalCanvas.width
    const height = originalCanvas.height

    // Create brightness canvas
    brightnessCanvas.width = width
    brightnessCanvas.height = height
    const brightCtx = brightnessCanvas.getContext('2d')
    const brightImageData = brightCtx.createImageData(width, height)
    const brightData = brightImageData.data

    // Convert to grayscale brightness
    for (let i = 0; i < data.length; i += 4) {
      const brightness = getBrightness(data[i], data[i + 1], data[i + 2])
      brightData[i] = brightness
      brightData[i + 1] = brightness
      brightData[i + 2] = brightness
      brightData[i + 3] = 255
    }

    brightCtx.putImageData(brightImageData, 0, 0)
    return brightImageData
  }

  // Quantize into discrete regions
  function quantizeRegions(brightnessData, numLevels) {
    const regionSize = parseInt(regionSizeSlider.value)
    const width = brightnessData.width
    const height = brightnessData.height
    const data = brightnessData.data

    quantizedCanvas.width = width
    quantizedCanvas.height = height
    const ctx = quantizedCanvas.getContext('2d')
    const quantizedImageData = ctx.createImageData(width, height)
    const quantizedData = quantizedImageData.data

    // Create grid of regions
    const cols = Math.ceil(width / regionSize)
    const rows = Math.ceil(height / regionSize)
    const regionMap = []

    // Calculate average brightness for each region
    for (let ry = 0; ry < rows; ry++) {
      regionMap[ry] = []
      for (let rx = 0; rx < cols; rx++) {
        let sum = 0
        let count = 0

        // Sample all pixels in this region
        for (let py = ry * regionSize; py < Math.min((ry + 1) * regionSize, height); py++) {
          for (let px = rx * regionSize; px < Math.min((rx + 1) * regionSize, width); px++) {
            const idx = (py * width + px) * 4
            sum += data[idx]
            count++
          }
        }

        const avgBrightness = sum / count

        // Quantize to discrete level
        const level = Math.floor((avgBrightness / 255) * numLevels)
        const quantizedValue = (level / numLevels) * 255

        regionMap[ry][rx] = {
          brightness: quantizedValue,
          level: level,
        }
      }
    }

    // Draw quantized regions
    for (let ry = 0; ry < rows; ry++) {
      for (let rx = 0; rx < cols; rx++) {
        const value = regionMap[ry][rx].brightness

        for (let py = ry * regionSize; py < Math.min((ry + 1) * regionSize, height); py++) {
          for (let px = rx * regionSize; px < Math.min((rx + 1) * regionSize, width); px++) {
            const idx = (py * width + px) * 4
            quantizedData[idx] = value
            quantizedData[idx + 1] = value
            quantizedData[idx + 2] = value
            quantizedData[idx + 3] = 255
          }
        }
      }
    }

    ctx.putImageData(quantizedImageData, 0, 0)
    return regionMap
  }

  // Apply diffusion for smooth transitions
  function diffuseRegions(regionMap, diffusionAmount) {
    if (diffusionAmount === 0) {
      // No diffusion, just copy quantized
      const ctx = quantizedCanvas.getContext('2d')
      const quantizedData = ctx.getImageData(0, 0, quantizedCanvas.width, quantizedCanvas.height)
      const diffusedCtx = diffusedCanvas.getContext('2d')
      diffusedCanvas.width = quantizedCanvas.width
      diffusedCanvas.height = quantizedCanvas.height
      diffusedCtx.putImageData(quantizedData, 0, 0)
      regionMapData = quantizedData
      return
    }

    const rows = regionMap.length
    const cols = regionMap[0].length
    const regionSize = parseInt(regionSizeSlider.value)
    const width = quantizedCanvas.width
    const height = quantizedCanvas.height

    diffusedCanvas.width = width
    diffusedCanvas.height = height
    const ctx = diffusedCanvas.getContext('2d')
    const diffusedImageData = ctx.createImageData(width, height)
    const diffusedData = diffusedImageData.data

    // Apply gaussian-like blur multiple times
    let currentMap = regionMap.map((row) => row.map((cell) => cell.brightness))

    for (let iteration = 0; iteration < diffusionAmount; iteration++) {
      const newMap = []

      for (let ry = 0; ry < rows; ry++) {
        newMap[ry] = []
        for (let rx = 0; rx < cols; rx++) {
          let sum = currentMap[ry][rx]
          let count = 1

          // Average with neighbors
          const neighbors = [
            [-1, -1],
            [-1, 0],
            [-1, 1],
            [0, -1],
            [0, 1],
            [1, -1],
            [1, 0],
            [1, 1],
          ]

          for (const [dy, dx] of neighbors) {
            const ny = ry + dy
            const nx = rx + dx
            if (ny >= 0 && ny < rows && nx >= 0 && nx < cols) {
              sum += currentMap[ny][nx]
              count++
            }
          }

          newMap[ry][rx] = sum / count
        }
      }

      currentMap = newMap
    }

    // Draw diffused regions
    for (let ry = 0; ry < rows; ry++) {
      for (let rx = 0; rx < cols; rx++) {
        const value = currentMap[ry][rx]

        for (let py = ry * regionSize; py < Math.min((ry + 1) * regionSize, height); py++) {
          for (let px = rx * regionSize; px < Math.min((rx + 1) * regionSize, width); px++) {
            const idx = (py * width + px) * 4
            diffusedData[idx] = value
            diffusedData[idx + 1] = value
            diffusedData[idx + 2] = value
            diffusedData[idx + 3] = 255
          }
        }
      }
    }

    ctx.putImageData(diffusedImageData, 0, 0)
    regionMapData = diffusedImageData
  }

  // Process button
  processBtn.addEventListener('click', () => {
    if (!currentImage) return

    const numLevels = parseInt(levelsSlider.value)
    const diffusionAmount = parseInt(diffusionSlider.value)

    // Step 1: Create brightness map
    const brightnessData = createBrightnessMap()

    // Step 2: Quantize into regions
    const regionMap = quantizeRegions(brightnessData, numLevels)

    // Step 3: Apply diffusion
    diffuseRegions(regionMap, diffusionAmount)

    // Enable stippling controls
    stipplingBtn.disabled = false
    resetBtn.disabled = false
  })

  // ========== STIPPLING ALGORITHMS ==========

  function getRegionBrightness(x, y) {
    if (!regionMapData) return 255
    const width = regionMapData.width
    const height = regionMapData.height
    const px = Math.max(0, Math.min(Math.floor(x), width - 1))
    const py = Math.max(0, Math.min(Math.floor(y), height - 1))
    const idx = (py * width + px) * 4
    return regionMapData.data[idx]
  }

  function drawDots() {
    const ctx = stippledCanvas.getContext('2d')
    // Fill with dark background
    ctx.fillStyle = '#000'
    ctx.fillRect(0, 0, stippledCanvas.width, stippledCanvas.height)

    // Draw light dots on top
    ctx.fillStyle = '#fff'
    const dotSize = parseFloat(dotSizeSlider.value)

    dots.forEach((dot) => {
      ctx.beginPath()
      ctx.arc(dot.x, dot.y, dotSize, 0, Math.PI * 2)
      ctx.fill()
    })

    document.getElementById('dotCount').textContent = dots.length
  }

  // Algorithm 1: Direct Density Mapping
  function addDotDensity() {
    const width = stippledCanvas.width
    const height = stippledCanvas.height
    const minDist = parseInt(minDistSlider.value)
    const lightnessThreshold = 0.15

    // Sample random points weighted by brightness (bright areas get more dots)
    for (let attempt = 0; attempt < 20; attempt++) {
      const x = Math.random() * width
      const y = Math.random() * height
      const brightness = getRegionBrightness(x, y)
      const lightness = brightness / 255

      // Skip if too dark
      if (lightness < lightnessThreshold) continue

      // Weight by lightness - brighter areas are more likely to accept dots
      if (Math.random() > lightness) continue

      // Check minimum distance
      let tooClose = false
      for (const dot of dots) {
        const dx = dot.x - x
        const dy = dot.y - y
        if (dx * dx + dy * dy < minDist * minDist) {
          tooClose = true
          break
        }
      }

      if (!tooClose) {
        dots.push({ x, y })
        return true
      }
    }
    return false
  }

  // Algorithm 2: Region-Based Triangulation
  function addDotTriangulation() {
    const width = stippledCanvas.width
    const height = stippledCanvas.height
    const minDist = parseInt(minDistSlider.value)
    const lightnessThreshold = 0.15 // Don't place dots if region is too dark

    // Find largest void
    let bestPoint = null
    let bestLightness = 0
    let maxMinDist = 0

    for (let attempt = 0; attempt < 30; attempt++) {
      const x = Math.random() * width
      const y = Math.random() * height
      const brightness = getRegionBrightness(x, y)
      const lightness = brightness / 255

      // Skip if too dark
      if (lightness < lightnessThreshold) continue

      let minDist = Infinity
      for (const dot of dots) {
        const dx = dot.x - x
        const dy = dot.y - y
        const dist = dx * dx + dy * dy
        if (dist < minDist) minDist = dist
      }

      const weighted = minDist * lightness

      if (weighted > maxMinDist) {
        maxMinDist = weighted
        bestPoint = { x, y }
        bestLightness = lightness
      }
    }

    if (!bestPoint || dots.length < 3) {
      if (bestPoint && bestLightness >= lightnessThreshold) {
        dots.push(bestPoint)
      }
      return true
    }

    // Find 3 nearest dots
    const nearest = dots
      .map((dot) => ({
        dot,
        dist: (dot.x - bestPoint.x) ** 2 + (dot.y - bestPoint.y) ** 2,
      }))
      .sort((a, b) => a.dist - b.dist)
      .slice(0, 3)

    // Triangulate
    const centroid = {
      x: (nearest[0].dot.x + nearest[1].dot.x + nearest[2].dot.x) / 3,
      y: (nearest[0].dot.y + nearest[1].dot.y + nearest[2].dot.y) / 3,
    }

    // Check brightness at centroid
    const centroidBrightness = getRegionBrightness(centroid.x, centroid.y)
    const centroidLightness = centroidBrightness / 255
    if (centroidLightness < 0.15) return false

    // Check min distance
    const minDistSq = parseInt(minDistSlider.value) ** 2
    let tooClose = false
    for (const dot of dots) {
      const dx = dot.x - centroid.x
      const dy = dot.y - centroid.y
      if (dx * dx + dy * dy < minDistSq) {
        tooClose = true
        break
      }
    }

    if (!tooClose) {
      dots.push(centroid)
      return true
    }
    return false
  }

  // Algorithm 3: Poisson Disk Sampling
  function addDotPoisson() {
    const width = stippledCanvas.width
    const height = stippledCanvas.height
    const lightnessThreshold = 0.15 // Don't place dots if region is too dark

    for (let attempt = 0; attempt < 30; attempt++) {
      const x = Math.random() * width
      const y = Math.random() * height
      const brightness = getRegionBrightness(x, y)
      const lightness = brightness / 255

      // Skip if too dark
      if (lightness < lightnessThreshold) continue

      // Variable radius based on brightness - bright areas get tighter spacing (smaller minDist)
      const baseMinDist = parseInt(minDistSlider.value)
      const variableMinDist = baseMinDist * (2.0 - lightness * 1.5)

      let tooClose = false
      for (const dot of dots) {
        const dx = dot.x - x
        const dy = dot.y - y
        if (dx * dx + dy * dy < variableMinDist * variableMinDist) {
          tooClose = true
          break
        }
      }

      if (!tooClose) {
        dots.push({ x, y })
        return true
      }
    }
    return false
  }

  // Algorithm 4: Hybrid
  function addDotHybrid() {
    const width = stippledCanvas.width
    const height = stippledCanvas.height
    const minDistVal = parseInt(minDistSlider.value)
    const lightnessThreshold = 0.15 // Don't place dots if region is too dark

    // Sample points weighted by lightness (inverted)
    let bestPoint = null
    let bestLightness = 0
    let maxScore = 0

    for (let attempt = 0; attempt < 30; attempt++) {
      const x = Math.random() * width
      const y = Math.random() * height
      const brightness = getRegionBrightness(x, y)
      const lightness = brightness / 255

      // Skip if too dark
      if (lightness < lightnessThreshold) continue

      // Find distance to nearest dot
      let minDist = Infinity
      for (const dot of dots) {
        const dx = dot.x - x
        const dy = dot.y - y
        const dist = dx * dx + dy * dy
        if (dist < minDist) minDist = dist
      }

      const score = minDist * (0.3 + lightness * 0.7)
      if (score > maxScore) {
        maxScore = score
        bestPoint = { x, y }
        bestLightness = lightness
      }
    }

    if (!bestPoint || bestLightness < lightnessThreshold) return false

    // If we have enough dots, triangulate
    if (dots.length >= 3) {
      const nearest = dots
        .map((dot) => ({
          dot,
          dist: (dot.x - bestPoint.x) ** 2 + (dot.y - bestPoint.y) ** 2,
        }))
        .filter((d) => d.dist < 10000) // Within ~100px
        .sort((a, b) => a.dist - b.dist)
        .slice(0, 3)

      if (nearest.length >= 3) {
        const centroid = {
          x: (nearest[0].dot.x + nearest[1].dot.x + nearest[2].dot.x) / 3,
          y: (nearest[0].dot.y + nearest[1].dot.y + nearest[2].dot.y) / 3,
        }

        // Check brightness at centroid
        const centroidBrightness = getRegionBrightness(centroid.x, centroid.y)
        const centroidLightness = centroidBrightness / 255
        if (centroidLightness < lightnessThreshold) {
          // Try fallback point instead
          let tooClose = false
          for (const dot of dots) {
            const dx = dot.x - bestPoint.x
            const dy = dot.y - bestPoint.y
            if (dx * dx + dy * dy < minDistVal * minDistVal) {
              tooClose = true
              break
            }
          }
          if (!tooClose && bestLightness >= lightnessThreshold) {
            dots.push(bestPoint)
            return true
          }
          return false
        }

        // Check min distance
        let tooClose = false
        for (const dot of dots) {
          const dx = dot.x - centroid.x
          const dy = dot.y - centroid.y
          if (dx * dx + dy * dy < minDistVal * minDistVal) {
            tooClose = true
            break
          }
        }

        if (!tooClose) {
          dots.push(centroid)
          return true
        }
      }
    }

    // Fallback: place at best point
    let tooClose = false
    for (const dot of dots) {
      const dx = dot.x - bestPoint.x
      const dy = dot.y - bestPoint.y
      if (dx * dx + dy * dy < minDistVal * minDistVal) {
        tooClose = true
        break
      }
    }

    if (!tooClose && bestLightness >= lightnessThreshold) {
      dots.push(bestPoint)
      return true
    }
    return false
  }

  // Animation loop
  function animate() {
    if (!isRunning) return

    const maxDots = parseInt(maxDotsSlider.value)
    if (dots.length >= maxDots) {
      stopStippling()
      return
    }

    // Add multiple dots per frame
    for (let i = 0; i < 10; i++) {
      if (dots.length >= maxDots) break

      const algorithm = algorithmSelect.value
      let success = false

      switch (algorithm) {
        case 'density':
          success = addDotDensity()
          break
        case 'triangulation':
          success = addDotTriangulation()
          break
        case 'poisson':
          success = addDotPoisson()
          break
        case 'hybrid':
          success = addDotHybrid()
          break
      }

      if (!success && dots.length < maxDots * 0.9) {
        // If struggling to place dots, try a few more times
        i--
      }
    }

    drawDots()
    animationFrame = requestAnimationFrame(animate)
  }

  function startStippling() {
    if (!regionMapData) return

    stippledCanvas.width = diffusedCanvas.width
    stippledCanvas.height = diffusedCanvas.height

    isRunning = true
    stipplingBtn.disabled = true
    stopBtn.disabled = false
    animate()
  }

  function stopStippling() {
    isRunning = false
    stipplingBtn.disabled = false
    stopBtn.disabled = true
    if (animationFrame) {
      cancelAnimationFrame(animationFrame)
      animationFrame = null
    }
  }

  function resetDots() {
    stopStippling()
    dots = []
    const ctx = stippledCanvas.getContext('2d')
    // Reset to dark background
    ctx.fillStyle = '#000'
    ctx.fillRect(0, 0, stippledCanvas.width, stippledCanvas.height)
    document.getElementById('dotCount').textContent = '0'
  }

  stipplingBtn.addEventListener('click', startStippling)
  stopBtn.addEventListener('click', stopStippling)
  resetBtn.addEventListener('click', resetDots)
</script>

<style>
  .container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 2rem;
    min-height: 100dvh;
  }

  header {
    text-align: center;
    margin-bottom: 2rem;
  }

  h1 {
    font-weight: 600;
    margin-bottom: 0.5rem;
  }

  .subtitle {
    color: var(--theme-text-subtle);
    font-size: 0.875rem;
  }

  .controls-wrapper {
    display: flex;
    gap: 1.5rem;
    flex-wrap: wrap;
    margin-bottom: 2rem;
  }

  .controls {
    background: var(--theme-bg);
    border: 1px solid var(--theme-border);
    padding: 1rem;
    border-radius: 8px;
    flex: 1 1 auto;
    min-width: 400px;
  }

  .controls h2 {
    margin-bottom: 1rem;
    font-size: 1rem;
    font-weight: 600;
  }

  .control-group {
    margin-bottom: 1.25rem;
    flex-shrink: 0;
  }

  .control-group label {
    display: block;
    font-weight: 500;
    font-size: 0.875rem;
    color: var(--theme-text-subtle);
    margin-bottom: 0.5rem;
  }

  .control-group input[type='file'] {
    width: 100%;
    padding: 0.625rem;
    border: 2px dashed var(--theme-border);
    border-radius: 6px;
    cursor: pointer;
    background: var(--theme-bg);
    color: var(--theme-text);
    font-size: 0.875rem;
  }

  .control-group input[type='range'] {
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: var(--theme-border);
    outline: none;
  }

  .control-group select {
    width: 100%;
    padding: 0.625rem;
    border: 1px solid var(--theme-border);
    border-radius: 6px;
    background: var(--theme-bg);
    color: var(--theme-text);
    font-size: 0.875rem;
    cursor: pointer;
  }

  .slider-value {
    display: inline-block;
    background: var(--theme-accent);
    color: var(--color-white);
    padding: 2px 12px;
    border-radius: 12px;
    font-size: 0.75rem;
    margin-left: 0.5rem;
  }

  button {
    background: var(--theme-accent);
    color: var(--color-white);
    border: none;
    padding: 0.625rem 1.25rem;
    border-radius: 6px;
    font-size: 0.875rem;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s;
    margin-right: 0.5rem;
  }

  button:hover {
    background: var(--theme-accent-light);
  }

  button:active {
    background: var(--theme-accent-dark);
  }

  button:disabled {
    background: var(--color-gray);
    cursor: not-allowed;
    opacity: 0.5;
  }

  .canvas-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 1.5rem;
    margin-bottom: 2rem;
  }
  }

  .canvas-container {
    background: var(--theme-bg);
    border: 1px solid var(--theme-border);
    padding: 1.25rem;
    border-radius: 8px;
  }

  .canvas-container h3 {
    margin-bottom: 1rem;
    font-size: 0.875rem;
    font-weight: 600;
  }

  canvas {
    max-width: 100%;
    border: 1px solid var(--theme-border);
    border-radius: 6px;
    display: block;
  }

  .info-box {
    background: var(--theme-bg);
    border: 1px solid var(--theme-border);
    padding: 0.75rem;
    border-radius: 6px;
    margin-top: 0.75rem;
    font-size: 0.75rem;
    color: var(--theme-text-dim);
  }

  .info-box strong {
    display: block;
    margin-bottom: 0.25rem;
    color: var(--theme-text);
  }
</style>
