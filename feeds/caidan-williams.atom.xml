<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Coding Notebook - Caidan Williams</title><link href="https://mildmelon.github.io/" rel="alternate"></link><link href="https://mildmelon.github.io/feeds/caidan-williams.atom.xml" rel="self"></link><id>https://mildmelon.github.io/</id><updated>2017-12-06T21:23:00-07:00</updated><entry><title>Extending My OOP Understanding</title><link href="https://mildmelon.github.io/extending-my-oop-understanding.html" rel="alternate"></link><published>2017-12-06T21:23:00-07:00</published><updated>2017-12-06T21:23:00-07:00</updated><author><name>Caidan Williams</name></author><id>tag:mildmelon.github.io,2017-12-06:/extending-my-oop-understanding.html</id><summary type="html">&lt;p&gt;There is always more to learn, especially if that focus is on programming.&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;There is always more to learn, especially if that focus is on
programming. The focus of this section will be on Python specific OOP.
This includes understanding how variables work, the "is" syntax, "None"
syntax, "Super" syntax, classes are objects, class vs. instance
variables, private variables, overriding methods, and overriding
built-in methods.&lt;/p&gt;
&lt;p&gt;“Commenting your code is like cleaning your bathroom - you never want to
do it, but it really does create a more pleasant experience for you and
your guests.”&lt;br&gt;
—Ryan Campbel&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;The Underlying Mechanics of Variables&lt;/h3&gt;
&lt;p&gt;Every variable "points" to an object. For example, we can create a new
variable  &lt;code&gt;j&lt;/code&gt;  which we will give an arbitrary value.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; j = 20&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The variable  &lt;code&gt;j&lt;/code&gt;  we created will now point to an integer object that
holds the value of  &lt;code&gt;20&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;If we now assign the variable  &lt;code&gt;j&lt;/code&gt;  to have a new value, we are telling
the compiler we want to create a new integer object with our new desired
value.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; j = 15&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Now that our variable  &lt;code&gt;j&lt;/code&gt;  points to a new integer object with the
value  &lt;code&gt;15&lt;/code&gt; . What happens to the old integer object with the value of 
&lt;code&gt;20&lt;/code&gt; ? The old object is not being used, so it gets discarded. This, in
essence, is Python's garbage collection.&lt;/p&gt;
&lt;p&gt;To elaborate we can have two different variables point to the same
object (int, str, etc.)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; j = 20 &amp;gt;&amp;gt;&amp;gt; k = j &amp;gt;&amp;gt;&amp;gt; print(j) 20 &amp;gt;&amp;gt;&amp;gt; print(k) 20&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Keep in mind that objects are not tied to the variable that originally
created them. So if we delete  &lt;code&gt;j&lt;/code&gt;  after we have assigned  &lt;code&gt;k&lt;/code&gt;  the
same integer object, we will still have the same object as it is still
be used by part of the program. Both  &lt;code&gt;j&lt;/code&gt;  and  &lt;code&gt;k&lt;/code&gt;  point to the same
integer object that holds the value of  &lt;code&gt;20&lt;/code&gt; .&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;"Is"&lt;/h3&gt;
&lt;p&gt;The keyword "is" compares two objects based on their location in memory.
We will create a new class, and then initialize three new instance
objects from the class.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Puppy:   def __init__(self):     self.name = "Alexander II"&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;`&amp;gt;&amp;gt;&amp;gt; pup = Puppy() &amp;gt;&amp;gt;&amp;gt; same_pup = pup &amp;gt;&amp;gt;&amp;gt; print(pup is same_pup) True&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;another_pup = Puppy() &amp;gt;&amp;gt;&amp;gt; print(pup is another_pup) False`&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;Though  &lt;code&gt;pup&lt;/code&gt;  and  &lt;code&gt;another_pup&lt;/code&gt;  are from the class they aren't stored
in the same place in memory. We can see that  &lt;code&gt;pup&lt;/code&gt;  and  &lt;code&gt;same_pup&lt;/code&gt; 
return True because they both point to the same  &lt;code&gt;Puppy&lt;/code&gt;  object in
memory.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(pup)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&gt;&gt;&gt; print(same_pup)&lt;/p&gt;
&lt;p&gt;&gt;&gt;&gt; print(another_pup)&lt;/p&gt;
&lt;p&gt;Here we can see the different locations in memory for the different
objects. We have only initialized two  &lt;code&gt;Puppy&lt;/code&gt;  objects but we have
three variables. Two variables that point to  &lt;code&gt;0x03890B90&lt;/code&gt;  and one
pointing to  &lt;code&gt;0x060A7090&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;"None"&lt;/h3&gt;
&lt;p&gt;This is a built-in constant, it is used to represent the absence of a
value.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x = None &amp;gt;&amp;gt;&amp;gt; print(x) None&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This can be useful when you need to have a variable, but don't have a
value for it yet. You can have your program logic deal with the variable
properly.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;"Super"&lt;/h3&gt;
&lt;p&gt;This built-in function, lets us call a method a class has inherited from
its parent. The basic syntax structure to use the "Super" keyword is
below.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;super().[parent_method]([parameters])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Replace the  &lt;code&gt;parent_method&lt;/code&gt;  with the desired method you wish to call,
that can be found in the parent class. The  &lt;code&gt;parameters&lt;/code&gt;  is what the
parent method takes as arguments.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Are Classes Objects?&lt;/h3&gt;
&lt;p&gt;In Python, classes are objects. When you run a program that defines a
class, Python will turn that class into an object, which can be used in
your program.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Peanut:   pass&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(Peanut)&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Class vs. Instance Variables&lt;/h3&gt;
&lt;p&gt;A class can have two types of variables, class and instance. First, we
will look at instance variables. Instance variables belong to the object
that created them. They are created with the  &lt;code&gt;self&lt;/code&gt;  keyword.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Chicken:   def __init__(self, name):     self.name = name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; phil = Chicken("Phillip") &amp;gt;&amp;gt;&amp;gt; print(phil.name) Phillip&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Instance variables are unique to each object created from a class. Class
variables are not unique, and every object of a certain class can use
that same class's variables.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Chicken:   species = "Bird"   def __init__(self, name):
    self.name = name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; chick = Chicken("Tim") &amp;gt;&amp;gt;&amp;gt; chick2 = Chicken("Jimbo")&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(chick.name) Tim &amp;gt;&amp;gt;&amp;gt; print(chick2.name) Jimbo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(chick.species) Bird &amp;gt;&amp;gt;&amp;gt; print(chick2.species) Bird&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Class variables are useful when you want every object of a class to have
access to a variable.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Private Variables&lt;/h3&gt;
&lt;p&gt;A lot of languages have at least some concept of private variables and
methods. Python is a little different, unlike other languages, Python
does not have syntax specifically for making variables private.
Therefore every variable in Python is public. Though there is a way to
indicate that a variable would like to be kept private, by using a
naming convention. If you have a variable or method the caller should
not access, you should precede its name with an underscore. Python
programmers know if a method or variable has a preceding underscore,
they should not use it, although keep in mind they will still be able to
use it at their own risk.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class PublicPrivateExample:   def __init__(self):
    self.public_variable = "callers know they can access this"
    self._dontusethisvariable = "callers know they shouldn't access
this"   def public_method(self):     # callers know they can use this
method     pass   def _dont_use_this_method(self):     # callers know
they shouldn't use this method     pass&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Overriding Methods&lt;/h3&gt;
&lt;p&gt;When you create a class that inherits a method from a parent, we can
then override the method to have child specific functionality. To
override a parent method, redefine the method with the same arguments,
then add your custom code to the body of the method.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Animal:   def __init__(self):     self.hunger = 100``   def
eat(self, amount):     self.hunger += amount     print("Animal has
eaten")&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Bird(Animal):   def eat(self, amount):     self.hunger += amount
    print("Bird has eaten")&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;You do not need to use the same arguments when overriding a method but
if you don't then calling the child class's method without the correct
arguments, it may end up making a call to the parent's method.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Overriding Built-In Methods&lt;/h3&gt;
&lt;p&gt;Every class in Python automatically inherits from a parent class called
Object. All classes in Python inherit methods from this parent class.
Python's built-in functions use these methods (often called magic
methods) for different situations, such as printing an object.&lt;/p&gt;
&lt;p&gt;We can manipulate how we print an object from a certain class by
modifying the classes magic method  &lt;code&gt;__repr__&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Tree:   def __init__(self, age):     self.age = age   def
__repr__(self):     return("The tree is {} years old".format(self.age))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; tree = Tree(12) &amp;gt;&amp;gt;&amp;gt; print(tree) The tree is 12 years old&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;There are many more built-in methods that are useful in helping keep a
program clean and organized.&lt;/p&gt;
&lt;p&gt;For more info on built-in methods and some clever tricks, check out &lt;a href="https://dbader.org/blog/python-dunder-methods"&gt;Dan
Bader's Blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The official &lt;a href="https://docs.python.org/3/reference/datamodel.html"&gt;Python 3
Docs&lt;/a&gt; have great
(although technical writing) on what they call "special methods".&lt;/p&gt;</content></entry><entry><title>The Four Pillars of Object-Orientated Programming</title><link href="https://mildmelon.github.io/the-four-pillars-of-object-orientated-programming.html" rel="alternate"></link><published>2017-12-06T00:24:00-07:00</published><updated>2017-12-06T00:24:00-07:00</updated><author><name>Caidan Williams</name></author><id>tag:mildmelon.github.io,2017-12-06:/the-four-pillars-of-object-orientated-programming.html</id><summary type="html">&lt;p&gt;For a programming language to be properly considered as OOP, it must contain these four main concepts.&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;For a programming language to be properly considered as OOP, it must
contain these four main concepts. The are four pillars of OOP:
inheritance, polymorphism, abstraction, and encapsulation. Also,
remember that for a programming language to be considered OOP it must be
able to create classes that can interact with each other.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OOP Languages: - Java - Python - Ruby Functional Languages: - PHP -
Haskell - Lisp&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Inheritance&lt;/h3&gt;
&lt;p&gt;When you create a class, you can &lt;em&gt;inherit&lt;/em&gt; another class (which will
allow the new class to have access to the parent class's variables and
methods).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class MotherDuck():   def __init__(self, name, weight, is_hungry):
    # weight is in lbs.     self.name = name     self.weight =
weight     self.is_hungry = is_hungry&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Duckling(MotherDuck):   def cry(self):     print("{name} is
crying!".format(name=self.name))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Now that we have defined both our parent class (MotherDuck) and our
child class (Duckling) we can now observe how they interact with each
other. Notice that when defining the Duckling class we pass it the
argument MotherDuck, this keyword (the parent class name) tells the
compiler that we want all of MotherDuck class variables and methods.&lt;/p&gt;
&lt;p&gt;First, create a new duckling and call its cry method&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt; duckling = Duckling("Jake", 2, False) &amp;gt;&amp;gt;&amp;gt; duckling.cry() Jake is
crying!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Now try to do the same with parent class (MotherDuck)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; mama = MotherDuck("Karen", 5, True) &amp;gt;&amp;gt;&amp;gt; mama.is_hungry True &amp;gt;&amp;gt;&amp;gt;
mama.cry() Traceback (most recent call last):   File "", line 1, in
    mama.cry() AttributeError: 'MotherDuck' object has no attribute
'cry'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Only the child class will be able to use the parent class's variables
and methods, this makes for cleaner code, less redundancy, and more
efficiency.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Polymorphism&lt;/h3&gt;
&lt;p&gt;A great definition of pragmatic polymorphism is, "polymorphism is the
ability (in programming) to present the same interface for different
underlying forms (data types)." An interface refers to one or more
functions or methods. Meaning a function or method that can achieve a
similar result with different data types (eg. string, int, float, bool,
etc.)&lt;/p&gt;
&lt;p&gt;If we look at python's built-in function &lt;code&gt;print()&lt;/code&gt; we know that it will
take any different data type (including classes) and determine what to
appropriately print to the console depending on the used type of data.
This is done without the need to call a seperate function for a specific
data type. eg. &lt;code&gt;print_bool()&lt;/code&gt; &lt;code&gt;print_string()&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Abstraction&lt;/h3&gt;
&lt;p&gt;Abstraction is used in OOP when we create a class and define its
methods. When we define a class, and the methods that go with it, we are
creating an &lt;em&gt;abstraction&lt;/em&gt;. When designing OO programs, we are creating
&lt;em&gt;abstractions&lt;/em&gt; of different concepts that all work together to form our
program. Abstraction allows us to model objects with clear boundaries,
and have them interact with each other.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Encapsulation&lt;/h3&gt;
&lt;p&gt;Encapsulation hides our codes internal data. When code and data have
been encapsulated, it means when it is called, the caller cannot access
the code's internal data. This concept plays a big role in security by
denying access to certain pieces of data.&lt;/p&gt;
&lt;p&gt;This also helps when trying to maintain code that is reliable, such as
changing a data type from a list to a tuple. Trying to directly append
to a tuple will give issues if we are expecting to append to a list. We
can solve this issue by making a function that appends to our desired
data type with a single function. This keeps the list/tuple data secret
while still giving reliable functionality to a program or any clients
that use the code.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Composition&lt;/h3&gt;
&lt;p&gt;This is not one of the four pillars of OOP but it is an important
concept that helps the rest. The composition of a program represents
"has a" relationships, this occurs when one object stores another object
as a variable.&lt;/p&gt;
&lt;p&gt;Let's represent this with an example, we will show the relationship
between a dog and it's owner. A dog "has a(n)" owner.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Dog():   def __init__(self, name, breed, owner):     self.name =
name     self.breed = breed     self.owner = owner&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Person():   def __init__(self, name):     self.name = name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;When we create a new dog object, we pass in a person object as the owner
argument&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; rob = Person("Dread Pirate Roberts") &amp;gt;&amp;gt;&amp;gt; dog = Dog("Kevin",
"Pitbull", rob) &amp;gt;&amp;gt;&amp;gt; print(dog.owner.name) Dread Pirate Roberts&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Now the dog Kevin belongs to the Dread Pirate Roberts, and we can easily
reference the dog's owner.&lt;/p&gt;</content></entry><entry><title>Programming Paradigms</title><link href="https://mildmelon.github.io/programming-paradigms.html" rel="alternate"></link><published>2017-12-04T20:35:00-07:00</published><updated>2017-12-04T20:35:00-07:00</updated><author><name>Caidan Williams</name></author><id>tag:mildmelon.github.io,2017-12-04:/programming-paradigms.html</id><summary type="html">&lt;p&gt;The basic paradigms are imperative programming, functional programming, and object-orientated programming.&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;There are a lot of different programming paradigms, though it is
non-essential to learn all of them right away. The basic paradigms are
imperative programming, functional programming, and object-orientated
programming. There is also the state of a program, which is the where
and what of the variables of a program are at a given time when the
program is being run. Different paradigms have different effects on a
program's state. They also manipulate the way a program's state changes
and how it changes those states.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Imperative Programming&lt;/h3&gt;
&lt;p&gt;This paradigm is fairly easy to understand, though this should probably
never be used professionally unless it's a simple one-off script. To sum
up how this is implemented, "do this, then that". Imperative programs
consist of a sequence of steps that ultimately get closer to a single
solution. Each step is changing the program's state. There are no
functions or classes that are being created and used, only variables are
being created and altered (we only change a program's state when we
modify, remove, introduce new variables to the program).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;xyz&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xyz&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="mi"&gt;15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;h3&gt;Functional Programming&lt;/h3&gt;
&lt;p&gt;As the name suggests, functional programming only uses functions within
the program (variables as well, no classes). More specifically, it
involves functions that when given the same input will always return the
same output. As Mary Rose Cook once said, &lt;em&gt;"Functional code is
characterized by one thing: the absence of side effects. It doesn't rely
on data outside the current function, and it doesn't change data that
exists outside the current function."&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This is an &lt;em&gt;unfunctional&lt;/em&gt; function:&lt;br&gt;
&lt;code&gt;a = 0 def increment():   global a   a += 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Here is a &lt;em&gt;functional&lt;/em&gt; function:&lt;br&gt;
&lt;code&gt;def increment(a):   return a + 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Notice that the unfunctional function pulls the variable &lt;code&gt;a&lt;/code&gt; from
outside of the functions local scope, thus leading to unpredictable
results and changing the state of the program. Whereas the functional
function uses any variable that is passed through its argument, leaving
out any room for unexpected results and not changing the state of the
program.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Object-Orientated Programming&lt;/h3&gt;
&lt;p&gt;This paradigm involves writing programs where you define and create
objects that interact with each other. Strings, integers, and floats are
all examples of objects. You can also define your own objects by using
classes. Think of a class as a blueprint used to create objects. Methods
are like functions, except they are defined in a class and belong to
that class. We can only call a class' method if we first create an
object from the desired class.&lt;/p&gt;
&lt;p&gt;We create a class by using the &lt;em&gt;class&lt;/em&gt; keyword:&lt;br&gt;
&lt;code&gt;class Orange:   print("Orange created!")&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If we create an object based off the &lt;em&gt;Orange&lt;/em&gt; class then it will run any
code inside class that is not a method:&lt;br&gt;
`orange = Orange() print(type(orange)) print(orange) &amp;gt;&amp;gt; Orange created!&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;`&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;</content></entry><entry><title>Organizing Naming Rules &amp; Conventions</title><link href="https://mildmelon.github.io/organizing-naming-rules-conventions.html" rel="alternate"></link><published>2017-11-23T04:27:00-07:00</published><updated>2017-11-23T04:27:00-07:00</updated><author><name>Caidan Williams</name></author><id>tag:mildmelon.github.io,2017-11-23:/organizing-naming-rules-conventions.html</id><summary type="html">&lt;p&gt;When we write code, we must be conscious of our naming conventions, as they hold a lot of meaning and will be seen by others.&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Note:&lt;/h3&gt;
&lt;p&gt;Organize the names we give to our variables, methods, classes, arguments, and packages by following some simple rules
(longer descriptions at the bottom). I refer to these coding objects that I give names as "entities" to keep it simple.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Rules:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The name should fully reveal the intent of its use.&lt;/li&gt;
&lt;li&gt;Names should not misinform the reader.&lt;/li&gt;
&lt;li&gt;Have meaningful distinctions in the name&lt;/li&gt;
&lt;li&gt;Try to make the names pronounceable names when possible, this will help significantly once you start programming
    with others.&lt;/li&gt;
&lt;li&gt;Use names that are easy to find by search.&lt;/li&gt;
&lt;li&gt;No encodings, it can be messy, misleading, and hard to find in a search.&lt;/li&gt;
&lt;li&gt;It's a waste of time to prefix member variables.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3&gt;Rules Explained:&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Names with intent&lt;/strong&gt;&lt;br&gt;
Take time when trying to determine a name. Think about the variable,
method, etc.  and the purpose of it being created, what use it serves
(within the project's scope), and how it is used.  &lt;/p&gt;
&lt;p&gt;PS: If it needs a comment (near its declaration to describe) what it is,
then rename it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Don't misinform&lt;/strong&gt;&lt;br&gt;
Entities will be read by both yourself and possibly other people in the
future. So a name that misinforms the reader about the entity will be
hard to know it's purpose at a later date.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Meaningful Distinctions&lt;/strong&gt;&lt;br&gt;
This is fairly simple, just don't use characters that look like others
if they are not in a word/group. Here is an example of how the lowercase
L can be confused with the number 1.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mo"&gt;01&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;O1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Searchable name&lt;/strong&gt;&lt;br&gt;
Avoid using names that contain single letters and single digits, as this
is harder to search for across a project. If single letters must be
used, say for temporary variables, then only use them as local variables
in short methods.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;No encodings&lt;/strong&gt;&lt;br&gt;
An example of bad encoding, which is illogical, confusing, and is not helpful
for anyone other than the programmer that wrote it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;Z7_DaysLeft&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Prefix member variables&lt;/strong&gt;&lt;br&gt;
There is no need to prefix variables that belong to a class because your
classes (and functions) should be small enough that you wouldn't need to
organize them. They are also easily ignored after a period of time
working with them while making the code look really messy.&lt;br&gt;
---&lt;br&gt;
Example of a prefixed member variable&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Barrel&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;m_weightInLbs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;h3&gt;Wise Words and Quotes:&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;"Do not refer to a grouping of accounts as an accountList unless it’s
actually a List. The word list means something specific to
programmers. If the container holding the accounts is not actually a
List, it may lead to false conclusions. So accountGroup or
bunchOfAccounts or just plain accounts would be better."&lt;/p&gt;
&lt;p&gt;- Robert C. Martin&lt;/p&gt;
&lt;p&gt;"The length of a name should correspond to the size of its scope."&lt;/p&gt;
&lt;p&gt;- Robert C. Martin&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img alt="comment_question" src="../images/comment_question.png"&gt;:&lt;/p&gt;</content></entry><entry><title>The Start of a Journey</title><link href="https://mildmelon.github.io/the-start-of-a-journey.html" rel="alternate"></link><published>2017-11-21T03:51:00-07:00</published><updated>2017-11-21T03:51:00-07:00</updated><author><name>Caidan Williams</name></author><id>tag:mildmelon.github.io,2017-11-21:/the-start-of-a-journey.html</id><summary type="html">&lt;p&gt;Hello, friend.&lt;/p&gt;
&lt;p&gt;This is a start, one which will help shape the next portion of my life.
The purpose of this blog is more of a digital notebook to keep track of
my progress, so I may reflect later upon this and see my improvement. I
will be tracking my …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Hello, friend.&lt;/p&gt;
&lt;p&gt;This is a start, one which will help shape the next portion of my life.
The purpose of this blog is more of a digital notebook to keep track of
my progress, so I may reflect later upon this and see my improvement. I
will be tracking my computer science learning, specifically programming
and software development. Any being is welcome to learn and take away
what they can from this blog.&lt;/p&gt;
&lt;p&gt;Goodbye for now and remember, &lt;em&gt;smile!&lt;/em&gt;&lt;/p&gt;</content></entry></feed>